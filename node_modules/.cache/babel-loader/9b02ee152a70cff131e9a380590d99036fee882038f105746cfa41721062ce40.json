{"ast":null,"code":"import { monitor } from './monitor';\nimport { noop } from './utils/functionUtils';\n/**\n * Read bytes from a ReadableStream until at least `limit` bytes have been read (or until the end of\n * the stream). The callback is invoked with the at most `limit` bytes, and indicates that the limit\n * has been exceeded if more bytes were available.\n */\nexport function readBytesFromStream(stream, callback, options) {\n  var reader = stream.getReader();\n  var chunks = [];\n  var readBytesCount = 0;\n  readMore();\n  function readMore() {\n    reader.read().then(monitor(function (result) {\n      if (result.done) {\n        onDone();\n        return;\n      }\n      if (options.collectStreamBody) {\n        chunks.push(result.value);\n      }\n      readBytesCount += result.value.length;\n      if (readBytesCount > options.bytesLimit) {\n        onDone();\n      } else {\n        readMore();\n      }\n    }), monitor(function (error) {\n      return callback(error);\n    }));\n  }\n  function onDone() {\n    reader.cancel().catch(\n    // we don't care if cancel fails, but we still need to catch the error to avoid reporting it\n    // as an unhandled rejection\n    noop);\n    var bytes;\n    var limitExceeded;\n    if (options.collectStreamBody) {\n      var completeBuffer_1;\n      if (chunks.length === 1) {\n        // optimization: if the response is small enough to fit in a single buffer (provided by the browser), just\n        // use it directly.\n        completeBuffer_1 = chunks[0];\n      } else {\n        // else, we need to copy buffers into a larger buffer to concatenate them.\n        completeBuffer_1 = new Uint8Array(readBytesCount);\n        var offset_1 = 0;\n        chunks.forEach(function (chunk) {\n          completeBuffer_1.set(chunk, offset_1);\n          offset_1 += chunk.length;\n        });\n      }\n      bytes = completeBuffer_1.slice(0, options.bytesLimit);\n      limitExceeded = completeBuffer_1.length > options.bytesLimit;\n    }\n    callback(undefined, bytes, limitExceeded);\n  }\n}","map":{"version":3,"names":["monitor","noop","readBytesFromStream","stream","callback","options","reader","getReader","chunks","readBytesCount","readMore","read","then","result","done","onDone","collectStreamBody","push","value","length","bytesLimit","error","cancel","catch","bytes","limitExceeded","completeBuffer_1","Uint8Array","offset_1","forEach","chunk","set","slice","undefined"],"sources":["D:\\edu'\\Spritle\\spritle\\node_modules\\@datadog\\browser-core\\src\\tools\\readBytesFromStream.ts"],"sourcesContent":["import { monitor } from './monitor'\nimport { noop } from './utils/functionUtils'\n\ntype Options = {\n  bytesLimit: number\n  collectStreamBody?: boolean\n}\n/**\n * Read bytes from a ReadableStream until at least `limit` bytes have been read (or until the end of\n * the stream). The callback is invoked with the at most `limit` bytes, and indicates that the limit\n * has been exceeded if more bytes were available.\n */\nexport function readBytesFromStream(\n  stream: ReadableStream<Uint8Array>,\n  callback: (error?: Error, bytes?: Uint8Array, limitExceeded?: boolean) => void,\n  options: Options\n) {\n  const reader = stream.getReader()\n  const chunks: Uint8Array[] = []\n  let readBytesCount = 0\n\n  readMore()\n\n  function readMore() {\n    reader.read().then(\n      monitor((result: ReadableStreamReadResult<Uint8Array>) => {\n        if (result.done) {\n          onDone()\n          return\n        }\n\n        if (options.collectStreamBody) {\n          chunks.push(result.value)\n        }\n        readBytesCount += result.value.length\n\n        if (readBytesCount > options.bytesLimit) {\n          onDone()\n        } else {\n          readMore()\n        }\n      }),\n      monitor((error) => callback(error))\n    )\n  }\n\n  function onDone() {\n    reader.cancel().catch(\n      // we don't care if cancel fails, but we still need to catch the error to avoid reporting it\n      // as an unhandled rejection\n      noop\n    )\n\n    let bytes: Uint8Array | undefined\n    let limitExceeded: boolean | undefined\n    if (options.collectStreamBody) {\n      let completeBuffer: Uint8Array\n      if (chunks.length === 1) {\n        // optimization: if the response is small enough to fit in a single buffer (provided by the browser), just\n        // use it directly.\n        completeBuffer = chunks[0]\n      } else {\n        // else, we need to copy buffers into a larger buffer to concatenate them.\n        completeBuffer = new Uint8Array(readBytesCount)\n        let offset = 0\n        chunks.forEach((chunk) => {\n          completeBuffer.set(chunk, offset)\n          offset += chunk.length\n        })\n      }\n      bytes = completeBuffer.slice(0, options.bytesLimit)\n      limitExceeded = completeBuffer.length > options.bytesLimit\n    }\n\n    callback(undefined, bytes, limitExceeded)\n  }\n}\n"],"mappings":"AAAA,SAASA,OAAO,QAAQ,WAAW;AACnC,SAASC,IAAI,QAAQ,uBAAuB;AAM5C;;;;;AAKA,OAAM,SAAUC,mBAAmBA,CACjCC,MAAkC,EAClCC,QAA8E,EAC9EC,OAAgB;EAEhB,IAAMC,MAAM,GAAGH,MAAM,CAACI,SAAS,EAAE;EACjC,IAAMC,MAAM,GAAiB,EAAE;EAC/B,IAAIC,cAAc,GAAG,CAAC;EAEtBC,QAAQ,EAAE;EAEV,SAASA,QAAQA,CAAA;IACfJ,MAAM,CAACK,IAAI,EAAE,CAACC,IAAI,CAChBZ,OAAO,CAAC,UAACa,MAA4C;MACnD,IAAIA,MAAM,CAACC,IAAI,EAAE;QACfC,MAAM,EAAE;QACR;MACF;MAEA,IAAIV,OAAO,CAACW,iBAAiB,EAAE;QAC7BR,MAAM,CAACS,IAAI,CAACJ,MAAM,CAACK,KAAK,CAAC;MAC3B;MACAT,cAAc,IAAII,MAAM,CAACK,KAAK,CAACC,MAAM;MAErC,IAAIV,cAAc,GAAGJ,OAAO,CAACe,UAAU,EAAE;QACvCL,MAAM,EAAE;MACV,CAAC,MAAM;QACLL,QAAQ,EAAE;MACZ;IACF,CAAC,CAAC,EACFV,OAAO,CAAC,UAACqB,KAAK;MAAK,OAAAjB,QAAQ,CAACiB,KAAK,CAAC;IAAf,CAAe,CAAC,CACpC;EACH;EAEA,SAASN,MAAMA,CAAA;IACbT,MAAM,CAACgB,MAAM,EAAE,CAACC,KAAK;IACnB;IACA;IACAtB,IAAI,CACL;IAED,IAAIuB,KAA6B;IACjC,IAAIC,aAAkC;IACtC,IAAIpB,OAAO,CAACW,iBAAiB,EAAE;MAC7B,IAAIU,gBAA0B;MAC9B,IAAIlB,MAAM,CAACW,MAAM,KAAK,CAAC,EAAE;QACvB;QACA;QACAO,gBAAc,GAAGlB,MAAM,CAAC,CAAC,CAAC;MAC5B,CAAC,MAAM;QACL;QACAkB,gBAAc,GAAG,IAAIC,UAAU,CAAClB,cAAc,CAAC;QAC/C,IAAImB,QAAM,GAAG,CAAC;QACdpB,MAAM,CAACqB,OAAO,CAAC,UAACC,KAAK;UACnBJ,gBAAc,CAACK,GAAG,CAACD,KAAK,EAAEF,QAAM,CAAC;UACjCA,QAAM,IAAIE,KAAK,CAACX,MAAM;QACxB,CAAC,CAAC;MACJ;MACAK,KAAK,GAAGE,gBAAc,CAACM,KAAK,CAAC,CAAC,EAAE3B,OAAO,CAACe,UAAU,CAAC;MACnDK,aAAa,GAAGC,gBAAc,CAACP,MAAM,GAAGd,OAAO,CAACe,UAAU;IAC5D;IAEAhB,QAAQ,CAAC6B,SAAS,EAAET,KAAK,EAAEC,aAAa,CAAC;EAC3C;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}