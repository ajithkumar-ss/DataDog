{"ast":null,"code":"import { setTimeout } from '../../tools/timer';\nimport { generateUUID } from '../../tools/utils/stringUtils';\nimport { assign } from '../../tools/utils/polyfills';\nimport { expandSessionState, isSessionInExpiredState } from './sessionState';\nexport var LOCK_RETRY_DELAY = 10;\nexport var LOCK_MAX_TRIES = 100;\nvar bufferedOperations = [];\nvar ongoingOperations;\nexport function processSessionStoreOperations(operations, sessionStoreStrategy, numberOfRetries) {\n  var _a;\n  if (numberOfRetries === void 0) {\n    numberOfRetries = 0;\n  }\n  var isLockEnabled = sessionStoreStrategy.isLockEnabled,\n    persistSession = sessionStoreStrategy.persistSession,\n    expireSession = sessionStoreStrategy.expireSession;\n  var persistWithLock = function (session) {\n    return persistSession(assign({}, session, {\n      lock: currentLock\n    }));\n  };\n  var retrieveStore = function () {\n    var session = sessionStoreStrategy.retrieveSession();\n    var lock = session.lock;\n    if (session.lock) {\n      delete session.lock;\n    }\n    return {\n      session: session,\n      lock: lock\n    };\n  };\n  if (!ongoingOperations) {\n    ongoingOperations = operations;\n  }\n  if (operations !== ongoingOperations) {\n    bufferedOperations.push(operations);\n    return;\n  }\n  if (isLockEnabled && numberOfRetries >= LOCK_MAX_TRIES) {\n    next(sessionStoreStrategy);\n    return;\n  }\n  var currentLock;\n  var currentStore = retrieveStore();\n  if (isLockEnabled) {\n    // if someone has lock, retry later\n    if (currentStore.lock) {\n      retryLater(operations, sessionStoreStrategy, numberOfRetries);\n      return;\n    }\n    // acquire lock\n    currentLock = generateUUID();\n    persistWithLock(currentStore.session);\n    // if lock is not acquired, retry later\n    currentStore = retrieveStore();\n    if (currentStore.lock !== currentLock) {\n      retryLater(operations, sessionStoreStrategy, numberOfRetries);\n      return;\n    }\n  }\n  var processedSession = operations.process(currentStore.session);\n  if (isLockEnabled) {\n    // if lock corrupted after process, retry later\n    currentStore = retrieveStore();\n    if (currentStore.lock !== currentLock) {\n      retryLater(operations, sessionStoreStrategy, numberOfRetries);\n      return;\n    }\n  }\n  if (processedSession) {\n    if (isSessionInExpiredState(processedSession)) {\n      expireSession();\n    } else {\n      expandSessionState(processedSession);\n      isLockEnabled ? persistWithLock(processedSession) : persistSession(processedSession);\n    }\n  }\n  if (isLockEnabled) {\n    // correctly handle lock around expiration would require to handle this case properly at several levels\n    // since we don't have evidence of lock issues around expiration, let's just not do the corruption check for it\n    if (!(processedSession && isSessionInExpiredState(processedSession))) {\n      // if lock corrupted after persist, retry later\n      currentStore = retrieveStore();\n      if (currentStore.lock !== currentLock) {\n        retryLater(operations, sessionStoreStrategy, numberOfRetries);\n        return;\n      }\n      persistSession(currentStore.session);\n      processedSession = currentStore.session;\n    }\n  }\n  // call after even if session is not persisted in order to perform operations on\n  // up-to-date session state value => the value could have been modified by another tab\n  (_a = operations.after) === null || _a === void 0 ? void 0 : _a.call(operations, processedSession || currentStore.session);\n  next(sessionStoreStrategy);\n}\nfunction retryLater(operations, sessionStore, currentNumberOfRetries) {\n  setTimeout(function () {\n    processSessionStoreOperations(operations, sessionStore, currentNumberOfRetries + 1);\n  }, LOCK_RETRY_DELAY);\n}\nfunction next(sessionStore) {\n  ongoingOperations = undefined;\n  var nextOperations = bufferedOperations.shift();\n  if (nextOperations) {\n    processSessionStoreOperations(nextOperations, sessionStore);\n  }\n}","map":{"version":3,"names":["setTimeout","generateUUID","assign","expandSessionState","isSessionInExpiredState","LOCK_RETRY_DELAY","LOCK_MAX_TRIES","bufferedOperations","ongoingOperations","processSessionStoreOperations","operations","sessionStoreStrategy","numberOfRetries","isLockEnabled","persistSession","expireSession","persistWithLock","session","lock","currentLock","retrieveStore","retrieveSession","push","next","currentStore","retryLater","processedSession","process","_a","after","call","sessionStore","currentNumberOfRetries","undefined","nextOperations","shift"],"sources":["D:\\edu'\\Spritle\\spritle\\node_modules\\@datadog\\browser-core\\src\\domain\\session\\sessionStoreOperations.ts"],"sourcesContent":["import { setTimeout } from '../../tools/timer'\nimport { generateUUID } from '../../tools/utils/stringUtils'\nimport { assign } from '../../tools/utils/polyfills'\nimport type { SessionStoreStrategy } from './storeStrategies/sessionStoreStrategy'\nimport type { SessionState } from './sessionState'\nimport { expandSessionState, isSessionInExpiredState } from './sessionState'\n\ntype Operations = {\n  process: (sessionState: SessionState) => SessionState | undefined\n  after?: (sessionState: SessionState) => void\n}\n\nexport const LOCK_RETRY_DELAY = 10\nexport const LOCK_MAX_TRIES = 100\nconst bufferedOperations: Operations[] = []\nlet ongoingOperations: Operations | undefined\n\nexport function processSessionStoreOperations(\n  operations: Operations,\n  sessionStoreStrategy: SessionStoreStrategy,\n  numberOfRetries = 0\n) {\n  const { isLockEnabled, persistSession, expireSession } = sessionStoreStrategy\n  const persistWithLock = (session: SessionState) => persistSession(assign({}, session, { lock: currentLock }))\n  const retrieveStore = () => {\n    const session = sessionStoreStrategy.retrieveSession()\n    const lock = session.lock\n\n    if (session.lock) {\n      delete session.lock\n    }\n\n    return {\n      session,\n      lock,\n    }\n  }\n\n  if (!ongoingOperations) {\n    ongoingOperations = operations\n  }\n  if (operations !== ongoingOperations) {\n    bufferedOperations.push(operations)\n    return\n  }\n  if (isLockEnabled && numberOfRetries >= LOCK_MAX_TRIES) {\n    next(sessionStoreStrategy)\n    return\n  }\n  let currentLock: string\n  let currentStore = retrieveStore()\n  if (isLockEnabled) {\n    // if someone has lock, retry later\n    if (currentStore.lock) {\n      retryLater(operations, sessionStoreStrategy, numberOfRetries)\n      return\n    }\n    // acquire lock\n    currentLock = generateUUID()\n    persistWithLock(currentStore.session)\n    // if lock is not acquired, retry later\n    currentStore = retrieveStore()\n    if (currentStore.lock !== currentLock) {\n      retryLater(operations, sessionStoreStrategy, numberOfRetries)\n      return\n    }\n  }\n  let processedSession = operations.process(currentStore.session)\n  if (isLockEnabled) {\n    // if lock corrupted after process, retry later\n    currentStore = retrieveStore()\n    if (currentStore.lock !== currentLock!) {\n      retryLater(operations, sessionStoreStrategy, numberOfRetries)\n      return\n    }\n  }\n  if (processedSession) {\n    if (isSessionInExpiredState(processedSession)) {\n      expireSession()\n    } else {\n      expandSessionState(processedSession)\n      isLockEnabled ? persistWithLock(processedSession) : persistSession(processedSession)\n    }\n  }\n  if (isLockEnabled) {\n    // correctly handle lock around expiration would require to handle this case properly at several levels\n    // since we don't have evidence of lock issues around expiration, let's just not do the corruption check for it\n    if (!(processedSession && isSessionInExpiredState(processedSession))) {\n      // if lock corrupted after persist, retry later\n      currentStore = retrieveStore()\n      if (currentStore.lock !== currentLock!) {\n        retryLater(operations, sessionStoreStrategy, numberOfRetries)\n        return\n      }\n      persistSession(currentStore.session)\n      processedSession = currentStore.session\n    }\n  }\n  // call after even if session is not persisted in order to perform operations on\n  // up-to-date session state value => the value could have been modified by another tab\n  operations.after?.(processedSession || currentStore.session)\n  next(sessionStoreStrategy)\n}\n\nfunction retryLater(operations: Operations, sessionStore: SessionStoreStrategy, currentNumberOfRetries: number) {\n  setTimeout(() => {\n    processSessionStoreOperations(operations, sessionStore, currentNumberOfRetries + 1)\n  }, LOCK_RETRY_DELAY)\n}\n\nfunction next(sessionStore: SessionStoreStrategy) {\n  ongoingOperations = undefined\n  const nextOperations = bufferedOperations.shift()\n  if (nextOperations) {\n    processSessionStoreOperations(nextOperations, sessionStore)\n  }\n}\n"],"mappings":"AAAA,SAASA,UAAU,QAAQ,mBAAmB;AAC9C,SAASC,YAAY,QAAQ,+BAA+B;AAC5D,SAASC,MAAM,QAAQ,6BAA6B;AAGpD,SAASC,kBAAkB,EAAEC,uBAAuB,QAAQ,gBAAgB;AAO5E,OAAO,IAAMC,gBAAgB,GAAG,EAAE;AAClC,OAAO,IAAMC,cAAc,GAAG,GAAG;AACjC,IAAMC,kBAAkB,GAAiB,EAAE;AAC3C,IAAIC,iBAAyC;AAE7C,OAAM,SAAUC,6BAA6BA,CAC3CC,UAAsB,EACtBC,oBAA0C,EAC1CC,eAAmB;;EAAnB,IAAAA,eAAA;IAAAA,eAAA,IAAmB;EAAA;EAEX,IAAAC,aAAa,GAAoCF,oBAAoB,CAAAE,aAAxD;IAAEC,cAAc,GAAoBH,oBAAoB,CAAAG,cAAxC;IAAEC,aAAa,GAAKJ,oBAAoB,CAAAI,aAAzB;EACpD,IAAMC,eAAe,GAAG,SAAAA,CAACC,OAAqB;IAAK,OAAAH,cAAc,CAACZ,MAAM,CAAC,EAAE,EAAEe,OAAO,EAAE;MAAEC,IAAI,EAAEC;IAAW,CAAE,CAAC,CAAC;EAA1D,CAA0D;EAC7G,IAAMC,aAAa,GAAG,SAAAA,CAAA;IACpB,IAAMH,OAAO,GAAGN,oBAAoB,CAACU,eAAe,EAAE;IACtD,IAAMH,IAAI,GAAGD,OAAO,CAACC,IAAI;IAEzB,IAAID,OAAO,CAACC,IAAI,EAAE;MAChB,OAAOD,OAAO,CAACC,IAAI;IACrB;IAEA,OAAO;MACLD,OAAO,EAAAA,OAAA;MACPC,IAAI,EAAAA;KACL;EACH,CAAC;EAED,IAAI,CAACV,iBAAiB,EAAE;IACtBA,iBAAiB,GAAGE,UAAU;EAChC;EACA,IAAIA,UAAU,KAAKF,iBAAiB,EAAE;IACpCD,kBAAkB,CAACe,IAAI,CAACZ,UAAU,CAAC;IACnC;EACF;EACA,IAAIG,aAAa,IAAID,eAAe,IAAIN,cAAc,EAAE;IACtDiB,IAAI,CAACZ,oBAAoB,CAAC;IAC1B;EACF;EACA,IAAIQ,WAAmB;EACvB,IAAIK,YAAY,GAAGJ,aAAa,EAAE;EAClC,IAAIP,aAAa,EAAE;IACjB;IACA,IAAIW,YAAY,CAACN,IAAI,EAAE;MACrBO,UAAU,CAACf,UAAU,EAAEC,oBAAoB,EAAEC,eAAe,CAAC;MAC7D;IACF;IACA;IACAO,WAAW,GAAGlB,YAAY,EAAE;IAC5Be,eAAe,CAACQ,YAAY,CAACP,OAAO,CAAC;IACrC;IACAO,YAAY,GAAGJ,aAAa,EAAE;IAC9B,IAAII,YAAY,CAACN,IAAI,KAAKC,WAAW,EAAE;MACrCM,UAAU,CAACf,UAAU,EAAEC,oBAAoB,EAAEC,eAAe,CAAC;MAC7D;IACF;EACF;EACA,IAAIc,gBAAgB,GAAGhB,UAAU,CAACiB,OAAO,CAACH,YAAY,CAACP,OAAO,CAAC;EAC/D,IAAIJ,aAAa,EAAE;IACjB;IACAW,YAAY,GAAGJ,aAAa,EAAE;IAC9B,IAAII,YAAY,CAACN,IAAI,KAAKC,WAAY,EAAE;MACtCM,UAAU,CAACf,UAAU,EAAEC,oBAAoB,EAAEC,eAAe,CAAC;MAC7D;IACF;EACF;EACA,IAAIc,gBAAgB,EAAE;IACpB,IAAItB,uBAAuB,CAACsB,gBAAgB,CAAC,EAAE;MAC7CX,aAAa,EAAE;IACjB,CAAC,MAAM;MACLZ,kBAAkB,CAACuB,gBAAgB,CAAC;MACpCb,aAAa,GAAGG,eAAe,CAACU,gBAAgB,CAAC,GAAGZ,cAAc,CAACY,gBAAgB,CAAC;IACtF;EACF;EACA,IAAIb,aAAa,EAAE;IACjB;IACA;IACA,IAAI,EAAEa,gBAAgB,IAAItB,uBAAuB,CAACsB,gBAAgB,CAAC,CAAC,EAAE;MACpE;MACAF,YAAY,GAAGJ,aAAa,EAAE;MAC9B,IAAII,YAAY,CAACN,IAAI,KAAKC,WAAY,EAAE;QACtCM,UAAU,CAACf,UAAU,EAAEC,oBAAoB,EAAEC,eAAe,CAAC;QAC7D;MACF;MACAE,cAAc,CAACU,YAAY,CAACP,OAAO,CAAC;MACpCS,gBAAgB,GAAGF,YAAY,CAACP,OAAO;IACzC;EACF;EACA;EACA;EACA,CAAAW,EAAA,GAAAlB,UAAU,CAACmB,KAAK,cAAAD,EAAA,uBAAAA,EAAA,CAAAE,IAAA,CAAApB,UAAA,EAAGgB,gBAAgB,IAAIF,YAAY,CAACP,OAAO,CAAC;EAC5DM,IAAI,CAACZ,oBAAoB,CAAC;AAC5B;AAEA,SAASc,UAAUA,CAACf,UAAsB,EAAEqB,YAAkC,EAAEC,sBAA8B;EAC5GhC,UAAU,CAAC;IACTS,6BAA6B,CAACC,UAAU,EAAEqB,YAAY,EAAEC,sBAAsB,GAAG,CAAC,CAAC;EACrF,CAAC,EAAE3B,gBAAgB,CAAC;AACtB;AAEA,SAASkB,IAAIA,CAACQ,YAAkC;EAC9CvB,iBAAiB,GAAGyB,SAAS;EAC7B,IAAMC,cAAc,GAAG3B,kBAAkB,CAAC4B,KAAK,EAAE;EACjD,IAAID,cAAc,EAAE;IAClBzB,6BAA6B,CAACyB,cAAc,EAAEH,YAAY,CAAC;EAC7D;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}