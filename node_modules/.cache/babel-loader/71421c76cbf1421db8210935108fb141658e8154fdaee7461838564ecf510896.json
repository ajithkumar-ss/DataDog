{"ast":null,"code":"import { setTimeout } from '../tools/timer';\nimport { clocksNow, ONE_MINUTE, ONE_SECOND } from '../tools/utils/timeUtils';\nimport { ONE_MEBI_BYTE, ONE_KIBI_BYTE } from '../tools/utils/byteUtils';\nimport { isServerError } from '../tools/utils/responseUtils';\nimport { ErrorSource } from '../domain/error/error.types';\nexport var MAX_ONGOING_BYTES_COUNT = 80 * ONE_KIBI_BYTE;\nexport var MAX_ONGOING_REQUESTS = 32;\nexport var MAX_QUEUE_BYTES_COUNT = 3 * ONE_MEBI_BYTE;\nexport var MAX_BACKOFF_TIME = ONE_MINUTE;\nexport var INITIAL_BACKOFF_TIME = ONE_SECOND;\nexport function sendWithRetryStrategy(payload, state, sendStrategy, trackType, reportError) {\n  if (state.transportStatus === 0 /* TransportStatus.UP */ && state.queuedPayloads.size() === 0 && state.bandwidthMonitor.canHandle(payload)) {\n    send(payload, state, sendStrategy, {\n      onSuccess: function () {\n        return retryQueuedPayloads(0 /* RetryReason.AFTER_SUCCESS */, state, sendStrategy, trackType, reportError);\n      },\n      onFailure: function () {\n        state.queuedPayloads.enqueue(payload);\n        scheduleRetry(state, sendStrategy, trackType, reportError);\n      }\n    });\n  } else {\n    state.queuedPayloads.enqueue(payload);\n  }\n}\nfunction scheduleRetry(state, sendStrategy, trackType, reportError) {\n  if (state.transportStatus !== 2 /* TransportStatus.DOWN */) {\n    return;\n  }\n  setTimeout(function () {\n    var payload = state.queuedPayloads.first();\n    send(payload, state, sendStrategy, {\n      onSuccess: function () {\n        state.queuedPayloads.dequeue();\n        state.currentBackoffTime = INITIAL_BACKOFF_TIME;\n        retryQueuedPayloads(1 /* RetryReason.AFTER_RESUME */, state, sendStrategy, trackType, reportError);\n      },\n      onFailure: function () {\n        state.currentBackoffTime = Math.min(MAX_BACKOFF_TIME, state.currentBackoffTime * 2);\n        scheduleRetry(state, sendStrategy, trackType, reportError);\n      }\n    });\n  }, state.currentBackoffTime);\n}\nfunction send(payload, state, sendStrategy, _a) {\n  var onSuccess = _a.onSuccess,\n    onFailure = _a.onFailure;\n  state.bandwidthMonitor.add(payload);\n  sendStrategy(payload, function (response) {\n    state.bandwidthMonitor.remove(payload);\n    if (!shouldRetryRequest(response)) {\n      state.transportStatus = 0 /* TransportStatus.UP */;\n      onSuccess();\n    } else {\n      // do not consider transport down if another ongoing request could succeed\n      state.transportStatus = state.bandwidthMonitor.ongoingRequestCount > 0 ? 1 /* TransportStatus.FAILURE_DETECTED */ : 2 /* TransportStatus.DOWN */;\n      payload.retry = {\n        count: payload.retry ? payload.retry.count + 1 : 1,\n        lastFailureStatus: response.status\n      };\n      onFailure();\n    }\n  });\n}\nfunction retryQueuedPayloads(reason, state, sendStrategy, trackType, reportError) {\n  if (reason === 0 /* RetryReason.AFTER_SUCCESS */ && state.queuedPayloads.isFull() && !state.queueFullReported) {\n    reportError({\n      message: \"Reached max \".concat(trackType, \" events size queued for upload: \").concat(MAX_QUEUE_BYTES_COUNT / ONE_MEBI_BYTE, \"MiB\"),\n      source: ErrorSource.AGENT,\n      startClocks: clocksNow()\n    });\n    state.queueFullReported = true;\n  }\n  var previousQueue = state.queuedPayloads;\n  state.queuedPayloads = newPayloadQueue();\n  while (previousQueue.size() > 0) {\n    sendWithRetryStrategy(previousQueue.dequeue(), state, sendStrategy, trackType, reportError);\n  }\n}\nfunction shouldRetryRequest(response) {\n  return response.type !== 'opaque' && (response.status === 0 && !navigator.onLine || response.status === 408 || response.status === 429 || isServerError(response.status));\n}\nexport function newRetryState() {\n  return {\n    transportStatus: 0 /* TransportStatus.UP */,\n    currentBackoffTime: INITIAL_BACKOFF_TIME,\n    bandwidthMonitor: newBandwidthMonitor(),\n    queuedPayloads: newPayloadQueue(),\n    queueFullReported: false\n  };\n}\nfunction newPayloadQueue() {\n  var queue = [];\n  return {\n    bytesCount: 0,\n    enqueue: function (payload) {\n      if (this.isFull()) {\n        return;\n      }\n      queue.push(payload);\n      this.bytesCount += payload.bytesCount;\n    },\n    first: function () {\n      return queue[0];\n    },\n    dequeue: function () {\n      var payload = queue.shift();\n      if (payload) {\n        this.bytesCount -= payload.bytesCount;\n      }\n      return payload;\n    },\n    size: function () {\n      return queue.length;\n    },\n    isFull: function () {\n      return this.bytesCount >= MAX_QUEUE_BYTES_COUNT;\n    }\n  };\n}\nfunction newBandwidthMonitor() {\n  return {\n    ongoingRequestCount: 0,\n    ongoingByteCount: 0,\n    canHandle: function (payload) {\n      return this.ongoingRequestCount === 0 || this.ongoingByteCount + payload.bytesCount <= MAX_ONGOING_BYTES_COUNT && this.ongoingRequestCount < MAX_ONGOING_REQUESTS;\n    },\n    add: function (payload) {\n      this.ongoingRequestCount += 1;\n      this.ongoingByteCount += payload.bytesCount;\n    },\n    remove: function (payload) {\n      this.ongoingRequestCount -= 1;\n      this.ongoingByteCount -= payload.bytesCount;\n    }\n  };\n}","map":{"version":3,"names":["setTimeout","clocksNow","ONE_MINUTE","ONE_SECOND","ONE_MEBI_BYTE","ONE_KIBI_BYTE","isServerError","ErrorSource","MAX_ONGOING_BYTES_COUNT","MAX_ONGOING_REQUESTS","MAX_QUEUE_BYTES_COUNT","MAX_BACKOFF_TIME","INITIAL_BACKOFF_TIME","sendWithRetryStrategy","payload","state","sendStrategy","trackType","reportError","transportStatus","queuedPayloads","size","bandwidthMonitor","canHandle","send","onSuccess","retryQueuedPayloads","onFailure","enqueue","scheduleRetry","first","dequeue","currentBackoffTime","Math","min","_a","add","response","remove","shouldRetryRequest","ongoingRequestCount","retry","count","lastFailureStatus","status","reason","isFull","queueFullReported","message","concat","source","AGENT","startClocks","previousQueue","newPayloadQueue","type","navigator","onLine","newRetryState","newBandwidthMonitor","queue","bytesCount","push","shift","length","ongoingByteCount"],"sources":["D:\\edu'\\Spritle\\Spritle\\node_modules\\@datadog\\browser-core\\src\\transport\\sendWithRetryStrategy.ts"],"sourcesContent":["import type { TrackType } from '../domain/configuration'\nimport { setTimeout } from '../tools/timer'\nimport { clocksNow, ONE_MINUTE, ONE_SECOND } from '../tools/utils/timeUtils'\nimport { ONE_MEBI_BYTE, ONE_KIBI_BYTE } from '../tools/utils/byteUtils'\nimport { isServerError } from '../tools/utils/responseUtils'\nimport type { RawError } from '../domain/error/error.types'\nimport { ErrorSource } from '../domain/error/error.types'\nimport type { Payload, HttpResponse } from './httpRequest'\n\nexport const MAX_ONGOING_BYTES_COUNT = 80 * ONE_KIBI_BYTE\nexport const MAX_ONGOING_REQUESTS = 32\nexport const MAX_QUEUE_BYTES_COUNT = 3 * ONE_MEBI_BYTE\nexport const MAX_BACKOFF_TIME = ONE_MINUTE\nexport const INITIAL_BACKOFF_TIME = ONE_SECOND\n\nconst enum TransportStatus {\n  UP,\n  FAILURE_DETECTED,\n  DOWN,\n}\n\nconst enum RetryReason {\n  AFTER_SUCCESS,\n  AFTER_RESUME,\n}\n\nexport interface RetryState {\n  transportStatus: TransportStatus\n  currentBackoffTime: number\n  bandwidthMonitor: ReturnType<typeof newBandwidthMonitor>\n  queuedPayloads: ReturnType<typeof newPayloadQueue>\n  queueFullReported: boolean\n}\n\ntype SendStrategy = (payload: Payload, onResponse: (r: HttpResponse) => void) => void\n\nexport function sendWithRetryStrategy(\n  payload: Payload,\n  state: RetryState,\n  sendStrategy: SendStrategy,\n  trackType: TrackType,\n  reportError: (error: RawError) => void\n) {\n  if (\n    state.transportStatus === TransportStatus.UP &&\n    state.queuedPayloads.size() === 0 &&\n    state.bandwidthMonitor.canHandle(payload)\n  ) {\n    send(payload, state, sendStrategy, {\n      onSuccess: () => retryQueuedPayloads(RetryReason.AFTER_SUCCESS, state, sendStrategy, trackType, reportError),\n      onFailure: () => {\n        state.queuedPayloads.enqueue(payload)\n        scheduleRetry(state, sendStrategy, trackType, reportError)\n      },\n    })\n  } else {\n    state.queuedPayloads.enqueue(payload)\n  }\n}\n\nfunction scheduleRetry(\n  state: RetryState,\n  sendStrategy: SendStrategy,\n  trackType: TrackType,\n  reportError: (error: RawError) => void\n) {\n  if (state.transportStatus !== TransportStatus.DOWN) {\n    return\n  }\n  setTimeout(() => {\n    const payload = state.queuedPayloads.first()\n    send(payload, state, sendStrategy, {\n      onSuccess: () => {\n        state.queuedPayloads.dequeue()\n        state.currentBackoffTime = INITIAL_BACKOFF_TIME\n        retryQueuedPayloads(RetryReason.AFTER_RESUME, state, sendStrategy, trackType, reportError)\n      },\n      onFailure: () => {\n        state.currentBackoffTime = Math.min(MAX_BACKOFF_TIME, state.currentBackoffTime * 2)\n        scheduleRetry(state, sendStrategy, trackType, reportError)\n      },\n    })\n  }, state.currentBackoffTime)\n}\n\nfunction send(\n  payload: Payload,\n  state: RetryState,\n  sendStrategy: SendStrategy,\n  { onSuccess, onFailure }: { onSuccess: () => void; onFailure: () => void }\n) {\n  state.bandwidthMonitor.add(payload)\n  sendStrategy(payload, (response) => {\n    state.bandwidthMonitor.remove(payload)\n    if (!shouldRetryRequest(response)) {\n      state.transportStatus = TransportStatus.UP\n      onSuccess()\n    } else {\n      // do not consider transport down if another ongoing request could succeed\n      state.transportStatus =\n        state.bandwidthMonitor.ongoingRequestCount > 0 ? TransportStatus.FAILURE_DETECTED : TransportStatus.DOWN\n      payload.retry = {\n        count: payload.retry ? payload.retry.count + 1 : 1,\n        lastFailureStatus: response.status,\n      }\n      onFailure()\n    }\n  })\n}\n\nfunction retryQueuedPayloads(\n  reason: RetryReason,\n  state: RetryState,\n  sendStrategy: SendStrategy,\n  trackType: TrackType,\n  reportError: (error: RawError) => void\n) {\n  if (reason === RetryReason.AFTER_SUCCESS && state.queuedPayloads.isFull() && !state.queueFullReported) {\n    reportError({\n      message: `Reached max ${trackType} events size queued for upload: ${MAX_QUEUE_BYTES_COUNT / ONE_MEBI_BYTE}MiB`,\n      source: ErrorSource.AGENT,\n      startClocks: clocksNow(),\n    })\n    state.queueFullReported = true\n  }\n  const previousQueue = state.queuedPayloads\n  state.queuedPayloads = newPayloadQueue()\n  while (previousQueue.size() > 0) {\n    sendWithRetryStrategy(previousQueue.dequeue()!, state, sendStrategy, trackType, reportError)\n  }\n}\n\nfunction shouldRetryRequest(response: HttpResponse) {\n  return (\n    response.type !== 'opaque' &&\n    ((response.status === 0 && !navigator.onLine) ||\n      response.status === 408 ||\n      response.status === 429 ||\n      isServerError(response.status))\n  )\n}\n\nexport function newRetryState(): RetryState {\n  return {\n    transportStatus: TransportStatus.UP,\n    currentBackoffTime: INITIAL_BACKOFF_TIME,\n    bandwidthMonitor: newBandwidthMonitor(),\n    queuedPayloads: newPayloadQueue(),\n    queueFullReported: false,\n  }\n}\n\nfunction newPayloadQueue() {\n  const queue: Payload[] = []\n  return {\n    bytesCount: 0,\n    enqueue(payload: Payload) {\n      if (this.isFull()) {\n        return\n      }\n      queue.push(payload)\n      this.bytesCount += payload.bytesCount\n    },\n    first() {\n      return queue[0]\n    },\n    dequeue() {\n      const payload = queue.shift()\n      if (payload) {\n        this.bytesCount -= payload.bytesCount\n      }\n      return payload\n    },\n    size() {\n      return queue.length\n    },\n    isFull() {\n      return this.bytesCount >= MAX_QUEUE_BYTES_COUNT\n    },\n  }\n}\n\nfunction newBandwidthMonitor() {\n  return {\n    ongoingRequestCount: 0,\n    ongoingByteCount: 0,\n    canHandle(payload: Payload) {\n      return (\n        this.ongoingRequestCount === 0 ||\n        (this.ongoingByteCount + payload.bytesCount <= MAX_ONGOING_BYTES_COUNT &&\n          this.ongoingRequestCount < MAX_ONGOING_REQUESTS)\n      )\n    },\n    add(payload: Payload) {\n      this.ongoingRequestCount += 1\n      this.ongoingByteCount += payload.bytesCount\n    },\n    remove(payload: Payload) {\n      this.ongoingRequestCount -= 1\n      this.ongoingByteCount -= payload.bytesCount\n    },\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}