{"ast":null,"code":"import { monitor, noop } from '@datadog/browser-core';\nimport { isNodeShadowHost, getMutationObserverConstructor, getParentNode, forEachChildNodes } from '@datadog/browser-rum-core';\nimport { NodePrivacyLevel } from '../../../constants';\nimport { IncrementalSource } from '../../../types';\nimport { getNodePrivacyLevel, getTextContent } from '../privacy';\nimport { getElementInputValue, getSerializedNodeId, hasSerializedNode, nodeAndAncestorsHaveSerializedNode, serializeNodeWithId, serializeAttribute } from '../serialization';\nimport { createMutationBatch } from '../mutationBatch';\nimport { assembleIncrementalSnapshot } from '../assembly';\n/**\n * Buffers and aggregate mutations generated by a MutationObserver into MutationPayload\n */\nexport function trackMutation(mutationCallback, configuration, shadowRootsController, target) {\n  var MutationObserver = getMutationObserverConstructor();\n  if (!MutationObserver) {\n    return {\n      stop: noop,\n      flush: noop\n    };\n  }\n  var mutationBatch = createMutationBatch(function (mutations) {\n    processMutations(mutations.concat(observer.takeRecords()), mutationCallback, configuration, shadowRootsController);\n  });\n  var observer = new MutationObserver(monitor(mutationBatch.addMutations));\n  observer.observe(target, {\n    attributeOldValue: true,\n    attributes: true,\n    characterData: true,\n    characterDataOldValue: true,\n    childList: true,\n    subtree: true\n  });\n  return {\n    stop: function () {\n      observer.disconnect();\n      mutationBatch.stop();\n    },\n    flush: function () {\n      mutationBatch.flush();\n    }\n  };\n}\nfunction processMutations(mutations, mutationCallback, configuration, shadowRootsController) {\n  var nodePrivacyLevelCache = new Map();\n  mutations.filter(function (mutation) {\n    return mutation.type === 'childList';\n  }).forEach(function (mutation) {\n    mutation.removedNodes.forEach(function (removedNode) {\n      traverseRemovedShadowDom(removedNode, shadowRootsController.removeShadowRoot);\n    });\n  });\n  // Discard any mutation with a 'target' node that:\n  // * isn't injected in the current document or isn't known/serialized yet: those nodes are likely\n  // part of a mutation occurring in a parent Node\n  // * should be hidden or ignored\n  var filteredMutations = mutations.filter(function (mutation) {\n    return mutation.target.isConnected && nodeAndAncestorsHaveSerializedNode(mutation.target) && getNodePrivacyLevel(mutation.target, configuration.defaultPrivacyLevel, nodePrivacyLevelCache) !== NodePrivacyLevel.HIDDEN;\n  });\n  var _a = processChildListMutations(filteredMutations.filter(function (mutation) {\n      return mutation.type === 'childList';\n    }), configuration, shadowRootsController, nodePrivacyLevelCache),\n    adds = _a.adds,\n    removes = _a.removes,\n    hasBeenSerialized = _a.hasBeenSerialized;\n  var texts = processCharacterDataMutations(filteredMutations.filter(function (mutation) {\n    return mutation.type === 'characterData' && !hasBeenSerialized(mutation.target);\n  }), configuration, nodePrivacyLevelCache);\n  var attributes = processAttributesMutations(filteredMutations.filter(function (mutation) {\n    return mutation.type === 'attributes' && !hasBeenSerialized(mutation.target);\n  }), configuration, nodePrivacyLevelCache);\n  if (!texts.length && !attributes.length && !removes.length && !adds.length) {\n    return;\n  }\n  mutationCallback(assembleIncrementalSnapshot(IncrementalSource.Mutation, {\n    adds: adds,\n    removes: removes,\n    texts: texts,\n    attributes: attributes\n  }));\n}\nfunction processChildListMutations(mutations, configuration, shadowRootsController, nodePrivacyLevelCache) {\n  // First, we iterate over mutations to collect:\n  //\n  // * nodes that have been added in the document and not removed by a subsequent mutation\n  // * nodes that have been removed from the document but were not added in a previous mutation\n  //\n  // For this second category, we also collect their previous parent (mutation.target) because we'll\n  // need it to emit a 'remove' mutation.\n  //\n  // Those two categories may overlap: if a node moved from a position to another, it is reported as\n  // two mutation records, one with a \"removedNodes\" and the other with \"addedNodes\". In this case,\n  // the node will be in both sets.\n  var addedAndMovedNodes = new Set();\n  var removedNodes = new Map();\n  var _loop_1 = function (mutation) {\n    mutation.addedNodes.forEach(function (node) {\n      addedAndMovedNodes.add(node);\n    });\n    mutation.removedNodes.forEach(function (node) {\n      if (!addedAndMovedNodes.has(node)) {\n        removedNodes.set(node, mutation.target);\n      }\n      addedAndMovedNodes.delete(node);\n    });\n  };\n  for (var _i = 0, mutations_1 = mutations; _i < mutations_1.length; _i++) {\n    var mutation = mutations_1[_i];\n    _loop_1(mutation);\n  }\n  // Then, we sort nodes that are still in the document by topological order, for two reasons:\n  //\n  // * We will serialize each added nodes with their descendants. We don't want to serialize a node\n  // twice, so we need to iterate over the parent nodes first and skip any node that is contained in\n  // a precedent node.\n  //\n  // * To emit \"add\" mutations, we need references to the parent and potential next sibling of each\n  // added node. So we need to iterate over the parent nodes first, and when multiple nodes are\n  // siblings, we want to iterate from last to first. This will ensure that any \"next\" node is\n  // already serialized and have an id.\n  var sortedAddedAndMovedNodes = Array.from(addedAndMovedNodes);\n  sortAddedAndMovedNodes(sortedAddedAndMovedNodes);\n  // Then, we iterate over our sorted node sets to emit mutations. We collect the newly serialized\n  // node ids in a set to be able to skip subsequent related mutations.\n  var serializedNodeIds = new Set();\n  var addedNodeMutations = [];\n  for (var _a = 0, sortedAddedAndMovedNodes_1 = sortedAddedAndMovedNodes; _a < sortedAddedAndMovedNodes_1.length; _a++) {\n    var node = sortedAddedAndMovedNodes_1[_a];\n    if (hasBeenSerialized(node)) {\n      continue;\n    }\n    var parentNodePrivacyLevel = getNodePrivacyLevel(node.parentNode, configuration.defaultPrivacyLevel, nodePrivacyLevelCache);\n    if (parentNodePrivacyLevel === NodePrivacyLevel.HIDDEN || parentNodePrivacyLevel === NodePrivacyLevel.IGNORE) {\n      continue;\n    }\n    var serializedNode = serializeNodeWithId(node, {\n      serializedNodeIds: serializedNodeIds,\n      parentNodePrivacyLevel: parentNodePrivacyLevel,\n      serializationContext: {\n        status: 2 /* SerializationContextStatus.MUTATION */,\n        shadowRootsController: shadowRootsController\n      },\n      configuration: configuration\n    });\n    if (!serializedNode) {\n      continue;\n    }\n    var parentNode = getParentNode(node);\n    addedNodeMutations.push({\n      nextId: getNextSibling(node),\n      parentId: getSerializedNodeId(parentNode),\n      node: serializedNode\n    });\n  }\n  // Finally, we emit remove mutations.\n  var removedNodeMutations = [];\n  removedNodes.forEach(function (parent, node) {\n    if (hasSerializedNode(node)) {\n      removedNodeMutations.push({\n        parentId: getSerializedNodeId(parent),\n        id: getSerializedNodeId(node)\n      });\n    }\n  });\n  return {\n    adds: addedNodeMutations,\n    removes: removedNodeMutations,\n    hasBeenSerialized: hasBeenSerialized\n  };\n  function hasBeenSerialized(node) {\n    return hasSerializedNode(node) && serializedNodeIds.has(getSerializedNodeId(node));\n  }\n  function getNextSibling(node) {\n    var nextSibling = node.nextSibling;\n    while (nextSibling) {\n      if (hasSerializedNode(nextSibling)) {\n        return getSerializedNodeId(nextSibling);\n      }\n      nextSibling = nextSibling.nextSibling;\n    }\n    return null;\n  }\n}\nfunction processCharacterDataMutations(mutations, configuration, nodePrivacyLevelCache) {\n  var _a;\n  var textMutations = [];\n  // Deduplicate mutations based on their target node\n  var handledNodes = new Set();\n  var filteredMutations = mutations.filter(function (mutation) {\n    if (handledNodes.has(mutation.target)) {\n      return false;\n    }\n    handledNodes.add(mutation.target);\n    return true;\n  });\n  // Emit mutations\n  for (var _i = 0, filteredMutations_1 = filteredMutations; _i < filteredMutations_1.length; _i++) {\n    var mutation = filteredMutations_1[_i];\n    var value = mutation.target.textContent;\n    if (value === mutation.oldValue) {\n      continue;\n    }\n    var parentNodePrivacyLevel = getNodePrivacyLevel(getParentNode(mutation.target), configuration.defaultPrivacyLevel, nodePrivacyLevelCache);\n    if (parentNodePrivacyLevel === NodePrivacyLevel.HIDDEN || parentNodePrivacyLevel === NodePrivacyLevel.IGNORE) {\n      continue;\n    }\n    textMutations.push({\n      id: getSerializedNodeId(mutation.target),\n      // TODO: pass a valid \"ignoreWhiteSpace\" argument\n      value: (_a = getTextContent(mutation.target, false, parentNodePrivacyLevel)) !== null && _a !== void 0 ? _a : null\n    });\n  }\n  return textMutations;\n}\nfunction processAttributesMutations(mutations, configuration, nodePrivacyLevelCache) {\n  var attributeMutations = [];\n  // Deduplicate mutations based on their target node and changed attribute\n  var handledElements = new Map();\n  var filteredMutations = mutations.filter(function (mutation) {\n    var handledAttributes = handledElements.get(mutation.target);\n    if (handledAttributes === null || handledAttributes === void 0 ? void 0 : handledAttributes.has(mutation.attributeName)) {\n      return false;\n    }\n    if (!handledAttributes) {\n      handledElements.set(mutation.target, new Set([mutation.attributeName]));\n    } else {\n      handledAttributes.add(mutation.attributeName);\n    }\n    return true;\n  });\n  // Emit mutations\n  var emittedMutations = new Map();\n  for (var _i = 0, filteredMutations_2 = filteredMutations; _i < filteredMutations_2.length; _i++) {\n    var mutation = filteredMutations_2[_i];\n    var uncensoredValue = mutation.target.getAttribute(mutation.attributeName);\n    if (uncensoredValue === mutation.oldValue) {\n      continue;\n    }\n    var privacyLevel = getNodePrivacyLevel(mutation.target, configuration.defaultPrivacyLevel, nodePrivacyLevelCache);\n    var attributeValue = serializeAttribute(mutation.target, privacyLevel, mutation.attributeName, configuration);\n    var transformedValue = void 0;\n    if (mutation.attributeName === 'value') {\n      var inputValue = getElementInputValue(mutation.target, privacyLevel);\n      if (inputValue === undefined) {\n        continue;\n      }\n      transformedValue = inputValue;\n    } else if (typeof attributeValue === 'string') {\n      transformedValue = attributeValue;\n    } else {\n      transformedValue = null;\n    }\n    var emittedMutation = emittedMutations.get(mutation.target);\n    if (!emittedMutation) {\n      emittedMutation = {\n        id: getSerializedNodeId(mutation.target),\n        attributes: {}\n      };\n      attributeMutations.push(emittedMutation);\n      emittedMutations.set(mutation.target, emittedMutation);\n    }\n    emittedMutation.attributes[mutation.attributeName] = transformedValue;\n  }\n  return attributeMutations;\n}\nexport function sortAddedAndMovedNodes(nodes) {\n  nodes.sort(function (a, b) {\n    var position = a.compareDocumentPosition(b);\n    /* eslint-disable no-bitwise */\n    if (position & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n      return -1;\n    } else if (position & Node.DOCUMENT_POSITION_CONTAINS) {\n      return 1;\n    } else if (position & Node.DOCUMENT_POSITION_FOLLOWING) {\n      return 1;\n    } else if (position & Node.DOCUMENT_POSITION_PRECEDING) {\n      return -1;\n    }\n    /* eslint-enable no-bitwise */\n    return 0;\n  });\n}\nfunction traverseRemovedShadowDom(removedNode, shadowDomRemovedCallback) {\n  if (isNodeShadowHost(removedNode)) {\n    shadowDomRemovedCallback(removedNode.shadowRoot);\n  }\n  forEachChildNodes(removedNode, function (childNode) {\n    return traverseRemovedShadowDom(childNode, shadowDomRemovedCallback);\n  });\n}","map":{"version":3,"names":["monitor","noop","isNodeShadowHost","getMutationObserverConstructor","getParentNode","forEachChildNodes","NodePrivacyLevel","IncrementalSource","getNodePrivacyLevel","getTextContent","getElementInputValue","getSerializedNodeId","hasSerializedNode","nodeAndAncestorsHaveSerializedNode","serializeNodeWithId","serializeAttribute","createMutationBatch","assembleIncrementalSnapshot","trackMutation","mutationCallback","configuration","shadowRootsController","target","MutationObserver","stop","flush","mutationBatch","mutations","processMutations","concat","observer","takeRecords","addMutations","observe","attributeOldValue","attributes","characterData","characterDataOldValue","childList","subtree","disconnect","nodePrivacyLevelCache","Map","filter","mutation","type","forEach","removedNodes","removedNode","traverseRemovedShadowDom","removeShadowRoot","filteredMutations","isConnected","defaultPrivacyLevel","HIDDEN","_a","processChildListMutations","adds","removes","hasBeenSerialized","texts","processCharacterDataMutations","processAttributesMutations","length","Mutation","addedAndMovedNodes","Set","addedNodes","node","add","has","set","delete","_i","mutations_1","sortedAddedAndMovedNodes","Array","from","sortAddedAndMovedNodes","serializedNodeIds","addedNodeMutations","sortedAddedAndMovedNodes_1","parentNodePrivacyLevel","parentNode","IGNORE","serializedNode","serializationContext","status","push","nextId","getNextSibling","parentId","removedNodeMutations","parent","id","nextSibling","textMutations","handledNodes","filteredMutations_1","value","textContent","oldValue","attributeMutations","handledElements","handledAttributes","get","attributeName","emittedMutations","filteredMutations_2","uncensoredValue","getAttribute","privacyLevel","attributeValue","transformedValue","inputValue","undefined","emittedMutation","nodes","sort","a","b","position","compareDocumentPosition","Node","DOCUMENT_POSITION_CONTAINED_BY","DOCUMENT_POSITION_CONTAINS","DOCUMENT_POSITION_FOLLOWING","DOCUMENT_POSITION_PRECEDING","shadowDomRemovedCallback","shadowRoot","childNode"],"sources":["D:\\edu'\\Spritle\\Spritle\\node_modules\\@datadog\\browser-rum\\src\\domain\\record\\trackers\\trackMutation.ts"],"sourcesContent":["import { monitor, noop } from '@datadog/browser-core'\nimport type { RumConfiguration } from '@datadog/browser-rum-core'\nimport {\n  isNodeShadowHost,\n  getMutationObserverConstructor,\n  getParentNode,\n  forEachChildNodes,\n} from '@datadog/browser-rum-core'\nimport { NodePrivacyLevel } from '../../../constants'\nimport { IncrementalSource } from '../../../types'\nimport type {\n  BrowserMutationData,\n  AddedNodeMutation,\n  AttributeMutation,\n  RemovedNodeMutation,\n  TextMutation,\n  BrowserIncrementalSnapshotRecord,\n} from '../../../types'\nimport type { NodePrivacyLevelCache } from '../privacy'\nimport { getNodePrivacyLevel, getTextContent } from '../privacy'\nimport type { NodeWithSerializedNode } from '../serialization'\nimport {\n  getElementInputValue,\n  getSerializedNodeId,\n  hasSerializedNode,\n  nodeAndAncestorsHaveSerializedNode,\n  serializeNodeWithId,\n  SerializationContextStatus,\n  serializeAttribute,\n} from '../serialization'\nimport { createMutationBatch } from '../mutationBatch'\nimport type { ShadowRootCallBack, ShadowRootsController } from '../shadowRootsController'\nimport { assembleIncrementalSnapshot } from '../assembly'\nimport type { Tracker } from './types'\n\nexport type MutationCallBack = (incrementalSnapshotRecord: BrowserIncrementalSnapshotRecord) => void\n\ntype WithSerializedTarget<T> = T & { target: NodeWithSerializedNode }\n\n// https://dom.spec.whatwg.org/#interface-mutationrecord\ninterface RumCharacterDataMutationRecord {\n  type: 'characterData'\n  target: Node\n  oldValue: string | null\n}\n\ninterface RumAttributesMutationRecord {\n  type: 'attributes'\n  target: Element\n  oldValue: string | null\n  attributeName: string | null\n}\n\ninterface RumChildListMutationRecord {\n  type: 'childList'\n  target: Node\n  addedNodes: NodeList\n  removedNodes: NodeList\n}\n\nexport type RumMutationRecord =\n  | RumCharacterDataMutationRecord\n  | RumAttributesMutationRecord\n  | RumChildListMutationRecord\n\nexport type MutationTracker = Tracker & { flush: () => void }\n\n/**\n * Buffers and aggregate mutations generated by a MutationObserver into MutationPayload\n */\nexport function trackMutation(\n  mutationCallback: MutationCallBack,\n  configuration: RumConfiguration,\n  shadowRootsController: ShadowRootsController,\n  target: Node\n): MutationTracker {\n  const MutationObserver = getMutationObserverConstructor()\n  if (!MutationObserver) {\n    return { stop: noop, flush: noop }\n  }\n\n  const mutationBatch = createMutationBatch((mutations) => {\n    processMutations(\n      mutations.concat(observer.takeRecords() as RumMutationRecord[]),\n      mutationCallback,\n      configuration,\n      shadowRootsController\n    )\n  })\n\n  const observer = new MutationObserver(monitor(mutationBatch.addMutations) as (callback: MutationRecord[]) => void)\n\n  observer.observe(target, {\n    attributeOldValue: true,\n    attributes: true,\n    characterData: true,\n    characterDataOldValue: true,\n    childList: true,\n    subtree: true,\n  })\n\n  return {\n    stop: () => {\n      observer.disconnect()\n      mutationBatch.stop()\n    },\n    flush: () => {\n      mutationBatch.flush()\n    },\n  }\n}\n\nfunction processMutations(\n  mutations: RumMutationRecord[],\n  mutationCallback: MutationCallBack,\n  configuration: RumConfiguration,\n  shadowRootsController: ShadowRootsController\n) {\n  const nodePrivacyLevelCache: NodePrivacyLevelCache = new Map()\n\n  mutations\n    .filter((mutation): mutation is RumChildListMutationRecord => mutation.type === 'childList')\n    .forEach((mutation) => {\n      mutation.removedNodes.forEach((removedNode) => {\n        traverseRemovedShadowDom(removedNode, shadowRootsController.removeShadowRoot)\n      })\n    })\n\n  // Discard any mutation with a 'target' node that:\n  // * isn't injected in the current document or isn't known/serialized yet: those nodes are likely\n  // part of a mutation occurring in a parent Node\n  // * should be hidden or ignored\n  const filteredMutations = mutations.filter(\n    (mutation): mutation is WithSerializedTarget<RumMutationRecord> =>\n      mutation.target.isConnected &&\n      nodeAndAncestorsHaveSerializedNode(mutation.target) &&\n      getNodePrivacyLevel(mutation.target, configuration.defaultPrivacyLevel, nodePrivacyLevelCache) !==\n        NodePrivacyLevel.HIDDEN\n  )\n\n  const { adds, removes, hasBeenSerialized } = processChildListMutations(\n    filteredMutations.filter(\n      (mutation): mutation is WithSerializedTarget<RumChildListMutationRecord> => mutation.type === 'childList'\n    ),\n    configuration,\n    shadowRootsController,\n    nodePrivacyLevelCache\n  )\n\n  const texts = processCharacterDataMutations(\n    filteredMutations.filter(\n      (mutation): mutation is WithSerializedTarget<RumCharacterDataMutationRecord> =>\n        mutation.type === 'characterData' && !hasBeenSerialized(mutation.target)\n    ),\n    configuration,\n    nodePrivacyLevelCache\n  )\n\n  const attributes = processAttributesMutations(\n    filteredMutations.filter(\n      (mutation): mutation is WithSerializedTarget<RumAttributesMutationRecord> =>\n        mutation.type === 'attributes' && !hasBeenSerialized(mutation.target)\n    ),\n    configuration,\n    nodePrivacyLevelCache\n  )\n\n  if (!texts.length && !attributes.length && !removes.length && !adds.length) {\n    return\n  }\n\n  mutationCallback(\n    assembleIncrementalSnapshot<BrowserMutationData>(IncrementalSource.Mutation, { adds, removes, texts, attributes })\n  )\n}\n\nfunction processChildListMutations(\n  mutations: Array<WithSerializedTarget<RumChildListMutationRecord>>,\n  configuration: RumConfiguration,\n  shadowRootsController: ShadowRootsController,\n  nodePrivacyLevelCache: NodePrivacyLevelCache\n) {\n  // First, we iterate over mutations to collect:\n  //\n  // * nodes that have been added in the document and not removed by a subsequent mutation\n  // * nodes that have been removed from the document but were not added in a previous mutation\n  //\n  // For this second category, we also collect their previous parent (mutation.target) because we'll\n  // need it to emit a 'remove' mutation.\n  //\n  // Those two categories may overlap: if a node moved from a position to another, it is reported as\n  // two mutation records, one with a \"removedNodes\" and the other with \"addedNodes\". In this case,\n  // the node will be in both sets.\n  const addedAndMovedNodes = new Set<Node>()\n  const removedNodes = new Map<Node, NodeWithSerializedNode>()\n  for (const mutation of mutations) {\n    mutation.addedNodes.forEach((node) => {\n      addedAndMovedNodes.add(node)\n    })\n    mutation.removedNodes.forEach((node) => {\n      if (!addedAndMovedNodes.has(node)) {\n        removedNodes.set(node, mutation.target)\n      }\n      addedAndMovedNodes.delete(node)\n    })\n  }\n\n  // Then, we sort nodes that are still in the document by topological order, for two reasons:\n  //\n  // * We will serialize each added nodes with their descendants. We don't want to serialize a node\n  // twice, so we need to iterate over the parent nodes first and skip any node that is contained in\n  // a precedent node.\n  //\n  // * To emit \"add\" mutations, we need references to the parent and potential next sibling of each\n  // added node. So we need to iterate over the parent nodes first, and when multiple nodes are\n  // siblings, we want to iterate from last to first. This will ensure that any \"next\" node is\n  // already serialized and have an id.\n  const sortedAddedAndMovedNodes = Array.from(addedAndMovedNodes)\n  sortAddedAndMovedNodes(sortedAddedAndMovedNodes)\n\n  // Then, we iterate over our sorted node sets to emit mutations. We collect the newly serialized\n  // node ids in a set to be able to skip subsequent related mutations.\n  const serializedNodeIds = new Set<number>()\n\n  const addedNodeMutations: AddedNodeMutation[] = []\n  for (const node of sortedAddedAndMovedNodes) {\n    if (hasBeenSerialized(node)) {\n      continue\n    }\n\n    const parentNodePrivacyLevel = getNodePrivacyLevel(\n      node.parentNode!,\n      configuration.defaultPrivacyLevel,\n      nodePrivacyLevelCache\n    )\n    if (parentNodePrivacyLevel === NodePrivacyLevel.HIDDEN || parentNodePrivacyLevel === NodePrivacyLevel.IGNORE) {\n      continue\n    }\n\n    const serializedNode = serializeNodeWithId(node, {\n      serializedNodeIds,\n      parentNodePrivacyLevel,\n      serializationContext: { status: SerializationContextStatus.MUTATION, shadowRootsController },\n      configuration,\n    })\n    if (!serializedNode) {\n      continue\n    }\n\n    const parentNode = getParentNode(node)!\n    addedNodeMutations.push({\n      nextId: getNextSibling(node),\n      parentId: getSerializedNodeId(parentNode)!,\n      node: serializedNode,\n    })\n  }\n  // Finally, we emit remove mutations.\n  const removedNodeMutations: RemovedNodeMutation[] = []\n  removedNodes.forEach((parent, node) => {\n    if (hasSerializedNode(node)) {\n      removedNodeMutations.push({\n        parentId: getSerializedNodeId(parent),\n        id: getSerializedNodeId(node),\n      })\n    }\n  })\n\n  return { adds: addedNodeMutations, removes: removedNodeMutations, hasBeenSerialized }\n\n  function hasBeenSerialized(node: Node) {\n    return hasSerializedNode(node) && serializedNodeIds.has(getSerializedNodeId(node))\n  }\n\n  function getNextSibling(node: Node): null | number {\n    let nextSibling = node.nextSibling\n    while (nextSibling) {\n      if (hasSerializedNode(nextSibling)) {\n        return getSerializedNodeId(nextSibling)\n      }\n      nextSibling = nextSibling.nextSibling\n    }\n\n    return null\n  }\n}\n\nfunction processCharacterDataMutations(\n  mutations: Array<WithSerializedTarget<RumCharacterDataMutationRecord>>,\n  configuration: RumConfiguration,\n  nodePrivacyLevelCache: NodePrivacyLevelCache\n) {\n  const textMutations: TextMutation[] = []\n\n  // Deduplicate mutations based on their target node\n  const handledNodes = new Set<Node>()\n  const filteredMutations = mutations.filter((mutation) => {\n    if (handledNodes.has(mutation.target)) {\n      return false\n    }\n    handledNodes.add(mutation.target)\n    return true\n  })\n\n  // Emit mutations\n  for (const mutation of filteredMutations) {\n    const value = mutation.target.textContent\n    if (value === mutation.oldValue) {\n      continue\n    }\n\n    const parentNodePrivacyLevel = getNodePrivacyLevel(\n      getParentNode(mutation.target)!,\n      configuration.defaultPrivacyLevel,\n      nodePrivacyLevelCache\n    )\n    if (parentNodePrivacyLevel === NodePrivacyLevel.HIDDEN || parentNodePrivacyLevel === NodePrivacyLevel.IGNORE) {\n      continue\n    }\n\n    textMutations.push({\n      id: getSerializedNodeId(mutation.target),\n      // TODO: pass a valid \"ignoreWhiteSpace\" argument\n      value: getTextContent(mutation.target, false, parentNodePrivacyLevel) ?? null,\n    })\n  }\n\n  return textMutations\n}\n\nfunction processAttributesMutations(\n  mutations: Array<WithSerializedTarget<RumAttributesMutationRecord>>,\n  configuration: RumConfiguration,\n  nodePrivacyLevelCache: NodePrivacyLevelCache\n) {\n  const attributeMutations: AttributeMutation[] = []\n\n  // Deduplicate mutations based on their target node and changed attribute\n  const handledElements = new Map<Element, Set<string>>()\n  const filteredMutations = mutations.filter((mutation) => {\n    const handledAttributes = handledElements.get(mutation.target)\n    if (handledAttributes?.has(mutation.attributeName!)) {\n      return false\n    }\n    if (!handledAttributes) {\n      handledElements.set(mutation.target, new Set([mutation.attributeName!]))\n    } else {\n      handledAttributes.add(mutation.attributeName!)\n    }\n    return true\n  })\n\n  // Emit mutations\n  const emittedMutations = new Map<Element, AttributeMutation>()\n  for (const mutation of filteredMutations) {\n    const uncensoredValue = mutation.target.getAttribute(mutation.attributeName!)\n    if (uncensoredValue === mutation.oldValue) {\n      continue\n    }\n    const privacyLevel = getNodePrivacyLevel(mutation.target, configuration.defaultPrivacyLevel, nodePrivacyLevelCache)\n    const attributeValue = serializeAttribute(mutation.target, privacyLevel, mutation.attributeName!, configuration)\n\n    let transformedValue: string | null\n    if (mutation.attributeName === 'value') {\n      const inputValue = getElementInputValue(mutation.target, privacyLevel)\n      if (inputValue === undefined) {\n        continue\n      }\n      transformedValue = inputValue\n    } else if (typeof attributeValue === 'string') {\n      transformedValue = attributeValue\n    } else {\n      transformedValue = null\n    }\n\n    let emittedMutation = emittedMutations.get(mutation.target)\n    if (!emittedMutation) {\n      emittedMutation = {\n        id: getSerializedNodeId(mutation.target),\n        attributes: {},\n      }\n      attributeMutations.push(emittedMutation)\n      emittedMutations.set(mutation.target, emittedMutation)\n    }\n\n    emittedMutation.attributes[mutation.attributeName!] = transformedValue\n  }\n\n  return attributeMutations\n}\n\nexport function sortAddedAndMovedNodes(nodes: Node[]) {\n  nodes.sort((a, b) => {\n    const position = a.compareDocumentPosition(b)\n    /* eslint-disable no-bitwise */\n    if (position & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n      return -1\n    } else if (position & Node.DOCUMENT_POSITION_CONTAINS) {\n      return 1\n    } else if (position & Node.DOCUMENT_POSITION_FOLLOWING) {\n      return 1\n    } else if (position & Node.DOCUMENT_POSITION_PRECEDING) {\n      return -1\n    }\n    /* eslint-enable no-bitwise */\n    return 0\n  })\n}\n\nfunction traverseRemovedShadowDom(removedNode: Node, shadowDomRemovedCallback: ShadowRootCallBack) {\n  if (isNodeShadowHost(removedNode)) {\n    shadowDomRemovedCallback(removedNode.shadowRoot)\n  }\n  forEachChildNodes(removedNode, (childNode) => traverseRemovedShadowDom(childNode, shadowDomRemovedCallback))\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}