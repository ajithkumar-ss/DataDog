{"ast":null,"code":"import { Observable } from '../tools/observable';\nimport { clearTimeout, setTimeout } from '../tools/timer';\n/**\n * Returns a \"flush controller\", responsible of notifying when flushing a pool of pending data needs\n * to happen. The implementation is designed to support both synchronous and asynchronous usages,\n * but relies on invariants described in each method documentation to keep a coherent state.\n */\nexport function createFlushController(_a) {\n  var messagesLimit = _a.messagesLimit,\n    bytesLimit = _a.bytesLimit,\n    durationLimit = _a.durationLimit,\n    pageExitObservable = _a.pageExitObservable,\n    sessionExpireObservable = _a.sessionExpireObservable;\n  var pageExitSubscription = pageExitObservable.subscribe(function (event) {\n    return flush(event.reason);\n  });\n  var sessionExpireSubscription = sessionExpireObservable.subscribe(function () {\n    return flush('session_expire');\n  });\n  var flushObservable = new Observable(function () {\n    return function () {\n      pageExitSubscription.unsubscribe();\n      sessionExpireSubscription.unsubscribe();\n    };\n  });\n  var currentBytesCount = 0;\n  var currentMessagesCount = 0;\n  function flush(flushReason) {\n    if (currentMessagesCount === 0) {\n      return;\n    }\n    var messagesCount = currentMessagesCount;\n    var bytesCount = currentBytesCount;\n    currentMessagesCount = 0;\n    currentBytesCount = 0;\n    cancelDurationLimitTimeout();\n    flushObservable.notify({\n      reason: flushReason,\n      messagesCount: messagesCount,\n      bytesCount: bytesCount\n    });\n  }\n  var durationLimitTimeoutId;\n  function scheduleDurationLimitTimeout() {\n    if (durationLimitTimeoutId === undefined) {\n      durationLimitTimeoutId = setTimeout(function () {\n        flush('duration_limit');\n      }, durationLimit);\n    }\n  }\n  function cancelDurationLimitTimeout() {\n    clearTimeout(durationLimitTimeoutId);\n    durationLimitTimeoutId = undefined;\n  }\n  return {\n    flushObservable: flushObservable,\n    get messagesCount() {\n      return currentMessagesCount;\n    },\n    /**\n     * Notifies that a message will be added to a pool of pending messages waiting to be flushed.\n     *\n     * This function needs to be called synchronously, right before adding the message, so no flush\n     * event can happen after `notifyBeforeAddMessage` and before adding the message.\n     *\n     * @param estimatedMessageBytesCount: an estimation of the message bytes count once it is\n     * actually added.\n     */\n    notifyBeforeAddMessage: function (estimatedMessageBytesCount) {\n      if (currentBytesCount + estimatedMessageBytesCount >= bytesLimit) {\n        flush('bytes_limit');\n      }\n      // Consider the message to be added now rather than in `notifyAfterAddMessage`, because if no\n      // message was added yet and `notifyAfterAddMessage` is called asynchronously, we still want\n      // to notify when a flush is needed (for example on page exit).\n      currentMessagesCount += 1;\n      currentBytesCount += estimatedMessageBytesCount;\n      scheduleDurationLimitTimeout();\n    },\n    /**\n     * Notifies that a message *was* added to a pool of pending messages waiting to be flushed.\n     *\n     * This function can be called asynchronously after the message was added, but in this case it\n     * should not be called if a flush event occurred in between.\n     *\n     * @param messageBytesCountDiff: the difference between the estimated message bytes count and\n     * its actual bytes count once added to the pool.\n     */\n    notifyAfterAddMessage: function (messageBytesCountDiff) {\n      if (messageBytesCountDiff === void 0) {\n        messageBytesCountDiff = 0;\n      }\n      currentBytesCount += messageBytesCountDiff;\n      if (currentMessagesCount >= messagesLimit) {\n        flush('messages_limit');\n      } else if (currentBytesCount >= bytesLimit) {\n        flush('bytes_limit');\n      }\n    },\n    /**\n     * Notifies that a message was removed from a pool of pending messages waiting to be flushed.\n     *\n     * This function needs to be called synchronously, right after removing the message, so no flush\n     * event can happen after removing the message and before `notifyAfterRemoveMessage`.\n     *\n     * @param messageBytesCount: the message bytes count that was added to the pool. Should\n     * correspond to the sum of bytes counts passed to `notifyBeforeAddMessage` and\n     * `notifyAfterAddMessage`.\n     */\n    notifyAfterRemoveMessage: function (messageBytesCount) {\n      currentBytesCount -= messageBytesCount;\n      currentMessagesCount -= 1;\n      if (currentMessagesCount === 0) {\n        cancelDurationLimitTimeout();\n      }\n    }\n  };\n}","map":{"version":3,"names":["Observable","clearTimeout","setTimeout","createFlushController","_a","messagesLimit","bytesLimit","durationLimit","pageExitObservable","sessionExpireObservable","pageExitSubscription","subscribe","event","flush","reason","sessionExpireSubscription","flushObservable","unsubscribe","currentBytesCount","currentMessagesCount","flushReason","messagesCount","bytesCount","cancelDurationLimitTimeout","notify","durationLimitTimeoutId","scheduleDurationLimitTimeout","undefined","notifyBeforeAddMessage","estimatedMessageBytesCount","notifyAfterAddMessage","messageBytesCountDiff","notifyAfterRemoveMessage","messageBytesCount"],"sources":["D:\\edu'\\Spritle\\Spritle\\node_modules\\@datadog\\browser-core\\src\\transport\\flushController.ts"],"sourcesContent":["import type { PageExitEvent, PageExitReason } from '../browser/pageExitObservable'\nimport { Observable } from '../tools/observable'\nimport type { TimeoutId } from '../tools/timer'\nimport { clearTimeout, setTimeout } from '../tools/timer'\nimport type { Duration } from '../tools/utils/timeUtils'\n\nexport type FlushReason = PageExitReason | 'duration_limit' | 'bytes_limit' | 'messages_limit' | 'session_expire'\n\nexport type FlushController = ReturnType<typeof createFlushController>\nexport interface FlushEvent {\n  reason: FlushReason\n  bytesCount: number\n  messagesCount: number\n}\n\ninterface FlushControllerOptions {\n  messagesLimit: number\n  bytesLimit: number\n  durationLimit: Duration\n  pageExitObservable: Observable<PageExitEvent>\n  sessionExpireObservable: Observable<void>\n}\n\n/**\n * Returns a \"flush controller\", responsible of notifying when flushing a pool of pending data needs\n * to happen. The implementation is designed to support both synchronous and asynchronous usages,\n * but relies on invariants described in each method documentation to keep a coherent state.\n */\nexport function createFlushController({\n  messagesLimit,\n  bytesLimit,\n  durationLimit,\n  pageExitObservable,\n  sessionExpireObservable,\n}: FlushControllerOptions) {\n  const pageExitSubscription = pageExitObservable.subscribe((event) => flush(event.reason))\n  const sessionExpireSubscription = sessionExpireObservable.subscribe(() => flush('session_expire'))\n\n  const flushObservable = new Observable<FlushEvent>(() => () => {\n    pageExitSubscription.unsubscribe()\n    sessionExpireSubscription.unsubscribe()\n  })\n\n  let currentBytesCount = 0\n  let currentMessagesCount = 0\n\n  function flush(flushReason: FlushReason) {\n    if (currentMessagesCount === 0) {\n      return\n    }\n\n    const messagesCount = currentMessagesCount\n    const bytesCount = currentBytesCount\n\n    currentMessagesCount = 0\n    currentBytesCount = 0\n    cancelDurationLimitTimeout()\n\n    flushObservable.notify({\n      reason: flushReason,\n      messagesCount,\n      bytesCount,\n    })\n  }\n\n  let durationLimitTimeoutId: TimeoutId | undefined\n  function scheduleDurationLimitTimeout() {\n    if (durationLimitTimeoutId === undefined) {\n      durationLimitTimeoutId = setTimeout(() => {\n        flush('duration_limit')\n      }, durationLimit)\n    }\n  }\n\n  function cancelDurationLimitTimeout() {\n    clearTimeout(durationLimitTimeoutId)\n    durationLimitTimeoutId = undefined\n  }\n\n  return {\n    flushObservable,\n    get messagesCount() {\n      return currentMessagesCount\n    },\n\n    /**\n     * Notifies that a message will be added to a pool of pending messages waiting to be flushed.\n     *\n     * This function needs to be called synchronously, right before adding the message, so no flush\n     * event can happen after `notifyBeforeAddMessage` and before adding the message.\n     *\n     * @param estimatedMessageBytesCount: an estimation of the message bytes count once it is\n     * actually added.\n     */\n    notifyBeforeAddMessage(estimatedMessageBytesCount: number) {\n      if (currentBytesCount + estimatedMessageBytesCount >= bytesLimit) {\n        flush('bytes_limit')\n      }\n      // Consider the message to be added now rather than in `notifyAfterAddMessage`, because if no\n      // message was added yet and `notifyAfterAddMessage` is called asynchronously, we still want\n      // to notify when a flush is needed (for example on page exit).\n      currentMessagesCount += 1\n      currentBytesCount += estimatedMessageBytesCount\n      scheduleDurationLimitTimeout()\n    },\n\n    /**\n     * Notifies that a message *was* added to a pool of pending messages waiting to be flushed.\n     *\n     * This function can be called asynchronously after the message was added, but in this case it\n     * should not be called if a flush event occurred in between.\n     *\n     * @param messageBytesCountDiff: the difference between the estimated message bytes count and\n     * its actual bytes count once added to the pool.\n     */\n    notifyAfterAddMessage(messageBytesCountDiff = 0) {\n      currentBytesCount += messageBytesCountDiff\n\n      if (currentMessagesCount >= messagesLimit) {\n        flush('messages_limit')\n      } else if (currentBytesCount >= bytesLimit) {\n        flush('bytes_limit')\n      }\n    },\n\n    /**\n     * Notifies that a message was removed from a pool of pending messages waiting to be flushed.\n     *\n     * This function needs to be called synchronously, right after removing the message, so no flush\n     * event can happen after removing the message and before `notifyAfterRemoveMessage`.\n     *\n     * @param messageBytesCount: the message bytes count that was added to the pool. Should\n     * correspond to the sum of bytes counts passed to `notifyBeforeAddMessage` and\n     * `notifyAfterAddMessage`.\n     */\n    notifyAfterRemoveMessage(messageBytesCount: number) {\n      currentBytesCount -= messageBytesCount\n      currentMessagesCount -= 1\n      if (currentMessagesCount === 0) {\n        cancelDurationLimitTimeout()\n      }\n    },\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}