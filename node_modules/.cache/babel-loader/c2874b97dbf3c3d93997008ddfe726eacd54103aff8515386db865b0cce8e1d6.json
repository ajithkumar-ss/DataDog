{"ast":null,"code":"import { cssEscape, getClassList, getParentElement } from '../browser/polyfills';\nimport { DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE } from './action/getActionNameFromElement';\n/**\n * Stable attributes are attributes that are commonly used to identify parts of a UI (ex:\n * component). Those attribute values should not be generated randomly (hardcoded most of the time)\n * and stay the same across deploys. They are not necessarily unique across the document.\n */\nexport var STABLE_ATTRIBUTES = [DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE,\n// Common test attributes (list provided by google recorder)\n'data-testid', 'data-test', 'data-qa', 'data-cy', 'data-test-id', 'data-qa-id', 'data-testing',\n// FullStory decorator attributes:\n'data-component', 'data-element', 'data-source-file'];\n// Selectors to use if they target a single element on the whole document. Those selectors are\n// considered as \"stable\" and uniquely identify an element regardless of the page state. If we find\n// one, we should consider the selector \"complete\" and stop iterating over ancestors.\nvar GLOBALLY_UNIQUE_SELECTOR_GETTERS = [getStableAttributeSelector, getIDSelector];\n// Selectors to use if they target a single element among an element descendants. Those selectors\n// are more brittle than \"globally unique\" selectors and should be combined with ancestor selectors\n// to improve specificity.\nvar UNIQUE_AMONG_CHILDREN_SELECTOR_GETTERS = [getStableAttributeSelector, getClassSelector, getTagNameSelector];\nexport function getSelectorFromElement(targetElement, actionNameAttribute) {\n  var targetElementSelector = '';\n  var element = targetElement;\n  while (element && element.nodeName !== 'HTML') {\n    var globallyUniqueSelector = findSelector(element, GLOBALLY_UNIQUE_SELECTOR_GETTERS, isSelectorUniqueGlobally, actionNameAttribute, targetElementSelector);\n    if (globallyUniqueSelector) {\n      return globallyUniqueSelector;\n    }\n    var uniqueSelectorAmongChildren = findSelector(element, UNIQUE_AMONG_CHILDREN_SELECTOR_GETTERS, isSelectorUniqueAmongSiblings, actionNameAttribute, targetElementSelector);\n    targetElementSelector = uniqueSelectorAmongChildren || combineSelector(getPositionSelector(element), targetElementSelector);\n    element = getParentElement(element);\n  }\n  return targetElementSelector;\n}\nfunction isGeneratedValue(value) {\n  // To compute the \"URL path group\", the backend replaces every URL path parts as a question mark\n  // if it thinks the part is an identifier. The condition it uses is to checks whether a digit is\n  // present.\n  //\n  // Here, we use the same strategy: if a the value contains a digit, we consider it generated. This\n  // strategy might be a bit naive and fail in some cases, but there are many fallbacks to generate\n  // CSS selectors so it should be fine most of the time. We might want to allow customers to\n  // provide their own `isGeneratedValue` at some point.\n  return /[0-9]/.test(value);\n}\nfunction getIDSelector(element) {\n  if (element.id && !isGeneratedValue(element.id)) {\n    return \"#\".concat(cssEscape(element.id));\n  }\n}\nfunction getClassSelector(element) {\n  if (element.tagName === 'BODY') {\n    return;\n  }\n  var classList = getClassList(element);\n  for (var i = 0; i < classList.length; i += 1) {\n    var className = classList[i];\n    if (isGeneratedValue(className)) {\n      continue;\n    }\n    return \"\".concat(cssEscape(element.tagName), \".\").concat(cssEscape(className));\n  }\n}\nfunction getTagNameSelector(element) {\n  return cssEscape(element.tagName);\n}\nfunction getStableAttributeSelector(element, actionNameAttribute) {\n  if (actionNameAttribute) {\n    var selector = getAttributeSelector(actionNameAttribute);\n    if (selector) {\n      return selector;\n    }\n  }\n  for (var _i = 0, STABLE_ATTRIBUTES_1 = STABLE_ATTRIBUTES; _i < STABLE_ATTRIBUTES_1.length; _i++) {\n    var attributeName = STABLE_ATTRIBUTES_1[_i];\n    var selector = getAttributeSelector(attributeName);\n    if (selector) {\n      return selector;\n    }\n  }\n  function getAttributeSelector(attributeName) {\n    if (element.hasAttribute(attributeName)) {\n      return \"\".concat(cssEscape(element.tagName), \"[\").concat(attributeName, \"=\\\"\").concat(cssEscape(element.getAttribute(attributeName)), \"\\\"]\");\n    }\n  }\n}\nfunction getPositionSelector(element) {\n  var sibling = getParentElement(element).firstElementChild;\n  var elementIndex = 1;\n  while (sibling && sibling !== element) {\n    if (sibling.tagName === element.tagName) {\n      elementIndex += 1;\n    }\n    sibling = sibling.nextElementSibling;\n  }\n  return \"\".concat(cssEscape(element.tagName), \":nth-of-type(\").concat(elementIndex, \")\");\n}\nfunction findSelector(element, selectorGetters, predicate, actionNameAttribute, childSelector) {\n  for (var _i = 0, selectorGetters_1 = selectorGetters; _i < selectorGetters_1.length; _i++) {\n    var selectorGetter = selectorGetters_1[_i];\n    var elementSelector = selectorGetter(element, actionNameAttribute);\n    if (!elementSelector) {\n      continue;\n    }\n    var fullSelector = combineSelector(elementSelector, childSelector);\n    if (predicate(element, fullSelector)) {\n      return fullSelector;\n    }\n  }\n}\n/**\n * Check whether the selector is unique among the whole document.\n */\nfunction isSelectorUniqueGlobally(element, selector) {\n  return element.ownerDocument.querySelectorAll(selector).length === 1;\n}\n/**\n * Check whether the selector is unique among the element siblings. In other words, it returns true\n * if \"ELEMENT_PARENT > SELECTOR\" returns a single element.\n *\n * The result will be less accurate on browsers that don't support :scope (i. e. IE): it will check\n * for any element matching the selector contained in the parent (in other words,\n * \"ELEMENT_PARENT SELECTOR\" returns a single element), regardless of whether the selector is a\n * direct descendent of the element parent. This should not impact results too much: if it\n * inaccurately returns false, we'll just fall back to another strategy.\n */\nfunction isSelectorUniqueAmongSiblings(element, selector) {\n  return getParentElement(element).querySelectorAll(supportScopeSelector() ? combineSelector(':scope', selector) : selector).length === 1;\n}\nfunction combineSelector(parent, child) {\n  return child ? \"\".concat(parent, \">\").concat(child) : parent;\n}\nvar supportScopeSelectorCache;\nexport function supportScopeSelector() {\n  if (supportScopeSelectorCache === undefined) {\n    try {\n      document.querySelector(':scope');\n      supportScopeSelectorCache = true;\n    } catch (_a) {\n      supportScopeSelectorCache = false;\n    }\n  }\n  return supportScopeSelectorCache;\n}","map":{"version":3,"names":["cssEscape","getClassList","getParentElement","DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE","STABLE_ATTRIBUTES","GLOBALLY_UNIQUE_SELECTOR_GETTERS","getStableAttributeSelector","getIDSelector","UNIQUE_AMONG_CHILDREN_SELECTOR_GETTERS","getClassSelector","getTagNameSelector","getSelectorFromElement","targetElement","actionNameAttribute","targetElementSelector","element","nodeName","globallyUniqueSelector","findSelector","isSelectorUniqueGlobally","uniqueSelectorAmongChildren","isSelectorUniqueAmongSiblings","combineSelector","getPositionSelector","isGeneratedValue","value","test","id","concat","tagName","classList","i","length","className","selector","getAttributeSelector","_i","STABLE_ATTRIBUTES_1","attributeName","hasAttribute","getAttribute","sibling","firstElementChild","elementIndex","nextElementSibling","selectorGetters","predicate","childSelector","selectorGetters_1","selectorGetter","elementSelector","fullSelector","ownerDocument","querySelectorAll","supportScopeSelector","parent","child","supportScopeSelectorCache","undefined","document","querySelector","_a"],"sources":["D:\\edu'\\Spritle\\Spritle\\node_modules\\@datadog\\browser-rum-core\\src\\domain\\getSelectorFromElement.ts"],"sourcesContent":["import { cssEscape, getClassList, getParentElement } from '../browser/polyfills'\nimport { DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE } from './action/getActionNameFromElement'\n\n/**\n * Stable attributes are attributes that are commonly used to identify parts of a UI (ex:\n * component). Those attribute values should not be generated randomly (hardcoded most of the time)\n * and stay the same across deploys. They are not necessarily unique across the document.\n */\nexport const STABLE_ATTRIBUTES = [\n  DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE,\n  // Common test attributes (list provided by google recorder)\n  'data-testid',\n  'data-test',\n  'data-qa',\n  'data-cy',\n  'data-test-id',\n  'data-qa-id',\n  'data-testing',\n  // FullStory decorator attributes:\n  'data-component',\n  'data-element',\n  'data-source-file',\n]\n\ntype SelectorGetter = (element: Element, actionNameAttribute: string | undefined) => string | undefined\n\n// Selectors to use if they target a single element on the whole document. Those selectors are\n// considered as \"stable\" and uniquely identify an element regardless of the page state. If we find\n// one, we should consider the selector \"complete\" and stop iterating over ancestors.\nconst GLOBALLY_UNIQUE_SELECTOR_GETTERS: SelectorGetter[] = [getStableAttributeSelector, getIDSelector]\n\n// Selectors to use if they target a single element among an element descendants. Those selectors\n// are more brittle than \"globally unique\" selectors and should be combined with ancestor selectors\n// to improve specificity.\nconst UNIQUE_AMONG_CHILDREN_SELECTOR_GETTERS: SelectorGetter[] = [\n  getStableAttributeSelector,\n  getClassSelector,\n  getTagNameSelector,\n]\n\nexport function getSelectorFromElement(targetElement: Element, actionNameAttribute: string | undefined) {\n  let targetElementSelector = ''\n  let element: Element | null = targetElement\n\n  while (element && element.nodeName !== 'HTML') {\n    const globallyUniqueSelector = findSelector(\n      element,\n      GLOBALLY_UNIQUE_SELECTOR_GETTERS,\n      isSelectorUniqueGlobally,\n      actionNameAttribute,\n      targetElementSelector\n    )\n    if (globallyUniqueSelector) {\n      return globallyUniqueSelector\n    }\n\n    const uniqueSelectorAmongChildren = findSelector(\n      element,\n      UNIQUE_AMONG_CHILDREN_SELECTOR_GETTERS,\n      isSelectorUniqueAmongSiblings,\n      actionNameAttribute,\n      targetElementSelector\n    )\n    targetElementSelector =\n      uniqueSelectorAmongChildren || combineSelector(getPositionSelector(element), targetElementSelector)\n\n    element = getParentElement(element)\n  }\n\n  return targetElementSelector\n}\n\nfunction isGeneratedValue(value: string) {\n  // To compute the \"URL path group\", the backend replaces every URL path parts as a question mark\n  // if it thinks the part is an identifier. The condition it uses is to checks whether a digit is\n  // present.\n  //\n  // Here, we use the same strategy: if a the value contains a digit, we consider it generated. This\n  // strategy might be a bit naive and fail in some cases, but there are many fallbacks to generate\n  // CSS selectors so it should be fine most of the time. We might want to allow customers to\n  // provide their own `isGeneratedValue` at some point.\n  return /[0-9]/.test(value)\n}\n\nfunction getIDSelector(element: Element): string | undefined {\n  if (element.id && !isGeneratedValue(element.id)) {\n    return `#${cssEscape(element.id)}`\n  }\n}\n\nfunction getClassSelector(element: Element): string | undefined {\n  if (element.tagName === 'BODY') {\n    return\n  }\n  const classList = getClassList(element)\n  for (let i = 0; i < classList.length; i += 1) {\n    const className = classList[i]\n    if (isGeneratedValue(className)) {\n      continue\n    }\n\n    return `${cssEscape(element.tagName)}.${cssEscape(className)}`\n  }\n}\n\nfunction getTagNameSelector(element: Element): string {\n  return cssEscape(element.tagName)\n}\n\nfunction getStableAttributeSelector(element: Element, actionNameAttribute: string | undefined): string | undefined {\n  if (actionNameAttribute) {\n    const selector = getAttributeSelector(actionNameAttribute)\n    if (selector) {\n      return selector\n    }\n  }\n\n  for (const attributeName of STABLE_ATTRIBUTES) {\n    const selector = getAttributeSelector(attributeName)\n    if (selector) {\n      return selector\n    }\n  }\n\n  function getAttributeSelector(attributeName: string) {\n    if (element.hasAttribute(attributeName)) {\n      return `${cssEscape(element.tagName)}[${attributeName}=\"${cssEscape(element.getAttribute(attributeName)!)}\"]`\n    }\n  }\n}\n\nfunction getPositionSelector(element: Element): string {\n  let sibling = getParentElement(element)!.firstElementChild\n  let elementIndex = 1\n\n  while (sibling && sibling !== element) {\n    if (sibling.tagName === element.tagName) {\n      elementIndex += 1\n    }\n    sibling = sibling.nextElementSibling\n  }\n\n  return `${cssEscape(element.tagName)}:nth-of-type(${elementIndex})`\n}\n\nfunction findSelector(\n  element: Element,\n  selectorGetters: SelectorGetter[],\n  predicate: (element: Element, selector: string) => boolean,\n  actionNameAttribute: string | undefined,\n  childSelector?: string\n) {\n  for (const selectorGetter of selectorGetters) {\n    const elementSelector = selectorGetter(element, actionNameAttribute)\n    if (!elementSelector) {\n      continue\n    }\n    const fullSelector = combineSelector(elementSelector, childSelector)\n    if (predicate(element, fullSelector)) {\n      return fullSelector\n    }\n  }\n}\n\n/**\n * Check whether the selector is unique among the whole document.\n */\nfunction isSelectorUniqueGlobally(element: Element, selector: string): boolean {\n  return element.ownerDocument.querySelectorAll(selector).length === 1\n}\n\n/**\n * Check whether the selector is unique among the element siblings. In other words, it returns true\n * if \"ELEMENT_PARENT > SELECTOR\" returns a single element.\n *\n * The result will be less accurate on browsers that don't support :scope (i. e. IE): it will check\n * for any element matching the selector contained in the parent (in other words,\n * \"ELEMENT_PARENT SELECTOR\" returns a single element), regardless of whether the selector is a\n * direct descendent of the element parent. This should not impact results too much: if it\n * inaccurately returns false, we'll just fall back to another strategy.\n */\nfunction isSelectorUniqueAmongSiblings(element: Element, selector: string): boolean {\n  return (\n    getParentElement(element)!.querySelectorAll(supportScopeSelector() ? combineSelector(':scope', selector) : selector)\n      .length === 1\n  )\n}\n\nfunction combineSelector(parent: string, child: string | undefined): string {\n  return child ? `${parent}>${child}` : parent\n}\n\nlet supportScopeSelectorCache: boolean | undefined\nexport function supportScopeSelector() {\n  if (supportScopeSelectorCache === undefined) {\n    try {\n      document.querySelector(':scope')\n      supportScopeSelectorCache = true\n    } catch {\n      supportScopeSelectorCache = false\n    }\n  }\n  return supportScopeSelectorCache\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}