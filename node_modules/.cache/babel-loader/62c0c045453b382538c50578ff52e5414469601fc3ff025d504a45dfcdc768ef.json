{"ast":null,"code":"import { safeTruncate, isIE, find } from '@datadog/browser-core';\nimport { getParentElement } from '../../browser/polyfills';\n/**\n * Get the action name from the attribute 'data-dd-action-name' on the element or any of its parent.\n * It can also be retrieved from a user defined attribute.\n */\nexport var DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE = 'data-dd-action-name';\nexport function getActionNameFromElement(element, userProgrammaticAttribute) {\n  // Proceed to get the action name in two steps:\n  // * first, get the name programmatically, explicitly defined by the user.\n  // * then, use strategies that are known to return good results. Those strategies will be used on\n  //   the element and a few parents, but it's likely that they won't succeed at all.\n  // * if no name is found this way, use strategies returning less accurate names as a fallback.\n  //   Those are much likely to succeed.\n  return getActionNameFromElementProgrammatically(element, DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE) || userProgrammaticAttribute && getActionNameFromElementProgrammatically(element, userProgrammaticAttribute) || getActionNameFromElementForStrategies(element, userProgrammaticAttribute, priorityStrategies) || getActionNameFromElementForStrategies(element, userProgrammaticAttribute, fallbackStrategies) || '';\n}\nfunction getActionNameFromElementProgrammatically(targetElement, programmaticAttribute) {\n  var elementWithAttribute;\n  // We don't use getActionNameFromElementForStrategies here, because we want to consider all parents,\n  // without limit. It is up to the user to declare a relevant naming strategy.\n  // If available, use element.closest() to match get the attribute from the element or any of its\n  // parent.  Else fallback to a more traditional implementation.\n  if (supportsElementClosest()) {\n    elementWithAttribute = targetElement.closest(\"[\".concat(programmaticAttribute, \"]\"));\n  } else {\n    var element = targetElement;\n    while (element) {\n      if (element.hasAttribute(programmaticAttribute)) {\n        elementWithAttribute = element;\n        break;\n      }\n      element = getParentElement(element);\n    }\n  }\n  if (!elementWithAttribute) {\n    return;\n  }\n  var name = elementWithAttribute.getAttribute(programmaticAttribute);\n  return truncate(normalizeWhitespace(name.trim()));\n}\nvar priorityStrategies = [\n// associated LABEL text\nfunction (element, userProgrammaticAttribute) {\n  // IE does not support element.labels, so we fallback to a CSS selector based on the element id\n  // instead\n  if (supportsLabelProperty()) {\n    if ('labels' in element && element.labels && element.labels.length > 0) {\n      return getTextualContent(element.labels[0], userProgrammaticAttribute);\n    }\n  } else if (element.id) {\n    var label = element.ownerDocument && find(element.ownerDocument.querySelectorAll('label'), function (label) {\n      return label.htmlFor === element.id;\n    });\n    return label && getTextualContent(label, userProgrammaticAttribute);\n  }\n},\n// INPUT button (and associated) value\nfunction (element) {\n  if (element.nodeName === 'INPUT') {\n    var input = element;\n    var type = input.getAttribute('type');\n    if (type === 'button' || type === 'submit' || type === 'reset') {\n      return input.value;\n    }\n  }\n},\n// BUTTON, LABEL or button-like element text\nfunction (element, userProgrammaticAttribute) {\n  if (element.nodeName === 'BUTTON' || element.nodeName === 'LABEL' || element.getAttribute('role') === 'button') {\n    return getTextualContent(element, userProgrammaticAttribute);\n  }\n}, function (element) {\n  return element.getAttribute('aria-label');\n},\n// associated element text designated by the aria-labelledby attribute\nfunction (element, userProgrammaticAttribute) {\n  var labelledByAttribute = element.getAttribute('aria-labelledby');\n  if (labelledByAttribute) {\n    return labelledByAttribute.split(/\\s+/).map(function (id) {\n      return getElementById(element, id);\n    }).filter(function (label) {\n      return Boolean(label);\n    }).map(function (element) {\n      return getTextualContent(element, userProgrammaticAttribute);\n    }).join(' ');\n  }\n}, function (element) {\n  return element.getAttribute('alt');\n}, function (element) {\n  return element.getAttribute('name');\n}, function (element) {\n  return element.getAttribute('title');\n}, function (element) {\n  return element.getAttribute('placeholder');\n},\n// SELECT first OPTION text\nfunction (element, userProgrammaticAttribute) {\n  if ('options' in element && element.options.length > 0) {\n    return getTextualContent(element.options[0], userProgrammaticAttribute);\n  }\n}];\nvar fallbackStrategies = [function (element, userProgrammaticAttribute) {\n  return getTextualContent(element, userProgrammaticAttribute);\n}];\n/**\n * Iterates over the target element and its parent, using the strategies list to get an action name.\n * Each strategies are applied on each element, stopping as soon as a non-empty value is returned.\n */\nvar MAX_PARENTS_TO_CONSIDER = 10;\nfunction getActionNameFromElementForStrategies(targetElement, userProgrammaticAttribute, strategies) {\n  var element = targetElement;\n  var recursionCounter = 0;\n  while (recursionCounter <= MAX_PARENTS_TO_CONSIDER && element && element.nodeName !== 'BODY' && element.nodeName !== 'HTML' && element.nodeName !== 'HEAD') {\n    for (var _i = 0, strategies_1 = strategies; _i < strategies_1.length; _i++) {\n      var strategy = strategies_1[_i];\n      var name_1 = strategy(element, userProgrammaticAttribute);\n      if (typeof name_1 === 'string') {\n        var trimmedName = name_1.trim();\n        if (trimmedName) {\n          return truncate(normalizeWhitespace(trimmedName));\n        }\n      }\n    }\n    // Consider a FORM as a contextual limit to get the action name.  This is experimental and may\n    // be reconsidered in the future.\n    if (element.nodeName === 'FORM') {\n      break;\n    }\n    element = getParentElement(element);\n    recursionCounter += 1;\n  }\n}\nfunction normalizeWhitespace(s) {\n  return s.replace(/\\s+/g, ' ');\n}\nfunction truncate(s) {\n  return s.length > 100 ? \"\".concat(safeTruncate(s, 100), \" [...]\") : s;\n}\nfunction getElementById(refElement, id) {\n  // Use the element ownerDocument here, because tests are executed in an iframe, so\n  // document.getElementById won't work.\n  return refElement.ownerDocument ? refElement.ownerDocument.getElementById(id) : null;\n}\nfunction getTextualContent(element, userProgrammaticAttribute) {\n  if (element.isContentEditable) {\n    return;\n  }\n  if ('innerText' in element) {\n    var text_1 = element.innerText;\n    var removeTextFromElements = function (query) {\n      var list = element.querySelectorAll(query);\n      for (var index = 0; index < list.length; index += 1) {\n        var element_1 = list[index];\n        if ('innerText' in element_1) {\n          var textToReplace = element_1.innerText;\n          if (textToReplace && textToReplace.trim().length > 0) {\n            text_1 = text_1.replace(textToReplace, '');\n          }\n        }\n      }\n    };\n    if (!supportsInnerTextScriptAndStyleRemoval()) {\n      // remove the inner text of SCRIPT and STYLES from the result. This is a bit dirty, but should\n      // be relatively fast and work in most cases.\n      removeTextFromElements('script, style');\n    }\n    // remove the text of elements with programmatic attribute value\n    removeTextFromElements(\"[\".concat(DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE, \"]\"));\n    if (userProgrammaticAttribute) {\n      removeTextFromElements(\"[\".concat(userProgrammaticAttribute, \"]\"));\n    }\n    return text_1;\n  }\n  return element.textContent;\n}\n/**\n * Returns true if element.innerText excludes the text from inline SCRIPT and STYLE element. This\n * should be the case everywhere except on Internet Explorer 10 and 11 (see [1])\n *\n * The innerText property relies on what is actually rendered to compute its output, so to check if\n * it actually excludes SCRIPT and STYLE content, a solution would be to create a style element, set\n * its content to '*', inject it in the document body, and check if the style element innerText\n * property returns '*'. Using a new `document` instance won't work as it is not rendered.\n *\n * This solution requires specific CSP rules (see [2]) to be set by the customer. We want to avoid\n * this, so instead we rely on browser detection. In case of false negative, the impact should be\n * low, since we rely on this result to remove the SCRIPT and STYLE innerText (which will be empty)\n * from a parent element innerText.\n *\n * [1]: https://web.archive.org/web/20210602165716/http://perfectionkills.com/the-poor-misunderstood-innerText/#diff-with-textContent\n * [2]: https://github.com/DataDog/browser-sdk/issues/1084\n */\nfunction supportsInnerTextScriptAndStyleRemoval() {\n  return !isIE();\n}\n/**\n * Returns true if the browser supports the element.labels property.  This should be the case\n * everywhere except on Internet Explorer.\n * Note: The result is computed lazily, because we don't want any DOM access when the SDK is\n * evaluated.\n */\nvar supportsLabelPropertyResult;\nfunction supportsLabelProperty() {\n  if (supportsLabelPropertyResult === undefined) {\n    supportsLabelPropertyResult = 'labels' in HTMLInputElement.prototype;\n  }\n  return supportsLabelPropertyResult;\n}\n/**\n * Returns true if the browser supports the element.closest method.  This should be the case\n * everywhere except on Internet Explorer.\n * Note: The result is computed lazily, because we don't want any DOM access when the SDK is\n * evaluated.\n */\nvar supportsElementClosestResult;\nfunction supportsElementClosest() {\n  if (supportsElementClosestResult === undefined) {\n    supportsElementClosestResult = 'closest' in HTMLElement.prototype;\n  }\n  return supportsElementClosestResult;\n}","map":{"version":3,"names":["safeTruncate","isIE","find","getParentElement","DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE","getActionNameFromElement","element","userProgrammaticAttribute","getActionNameFromElementProgrammatically","getActionNameFromElementForStrategies","priorityStrategies","fallbackStrategies","targetElement","programmaticAttribute","elementWithAttribute","supportsElementClosest","closest","concat","hasAttribute","name","getAttribute","truncate","normalizeWhitespace","trim","supportsLabelProperty","labels","length","getTextualContent","id","label","ownerDocument","querySelectorAll","htmlFor","nodeName","input","type","value","labelledByAttribute","split","map","getElementById","filter","Boolean","join","options","MAX_PARENTS_TO_CONSIDER","strategies","recursionCounter","_i","strategies_1","strategy","name_1","trimmedName","s","replace","refElement","isContentEditable","text_1","innerText","removeTextFromElements","query","list","index","element_1","textToReplace","supportsInnerTextScriptAndStyleRemoval","textContent","supportsLabelPropertyResult","undefined","HTMLInputElement","prototype","supportsElementClosestResult","HTMLElement"],"sources":["D:\\edu'\\Spritle\\Spritle\\node_modules\\@datadog\\browser-rum-core\\src\\domain\\action\\getActionNameFromElement.ts"],"sourcesContent":["import { safeTruncate, isIE, find } from '@datadog/browser-core'\nimport { getParentElement } from '../../browser/polyfills'\n\n/**\n * Get the action name from the attribute 'data-dd-action-name' on the element or any of its parent.\n * It can also be retrieved from a user defined attribute.\n */\nexport const DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE = 'data-dd-action-name'\n\nexport function getActionNameFromElement(element: Element, userProgrammaticAttribute?: string): string {\n  // Proceed to get the action name in two steps:\n  // * first, get the name programmatically, explicitly defined by the user.\n  // * then, use strategies that are known to return good results. Those strategies will be used on\n  //   the element and a few parents, but it's likely that they won't succeed at all.\n  // * if no name is found this way, use strategies returning less accurate names as a fallback.\n  //   Those are much likely to succeed.\n  return (\n    getActionNameFromElementProgrammatically(element, DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE) ||\n    (userProgrammaticAttribute && getActionNameFromElementProgrammatically(element, userProgrammaticAttribute)) ||\n    getActionNameFromElementForStrategies(element, userProgrammaticAttribute, priorityStrategies) ||\n    getActionNameFromElementForStrategies(element, userProgrammaticAttribute, fallbackStrategies) ||\n    ''\n  )\n}\n\nfunction getActionNameFromElementProgrammatically(targetElement: Element, programmaticAttribute: string) {\n  let elementWithAttribute\n  // We don't use getActionNameFromElementForStrategies here, because we want to consider all parents,\n  // without limit. It is up to the user to declare a relevant naming strategy.\n  // If available, use element.closest() to match get the attribute from the element or any of its\n  // parent.  Else fallback to a more traditional implementation.\n  if (supportsElementClosest()) {\n    elementWithAttribute = targetElement.closest(`[${programmaticAttribute}]`)\n  } else {\n    let element: Element | null = targetElement\n    while (element) {\n      if (element.hasAttribute(programmaticAttribute)) {\n        elementWithAttribute = element\n        break\n      }\n      element = getParentElement(element)\n    }\n  }\n\n  if (!elementWithAttribute) {\n    return\n  }\n  const name = elementWithAttribute.getAttribute(programmaticAttribute)!\n  return truncate(normalizeWhitespace(name.trim()))\n}\n\ntype NameStrategy = (\n  element: Element | HTMLElement | HTMLInputElement | HTMLSelectElement,\n  userProgrammaticAttribute: string | undefined\n) => string | undefined | null\n\nconst priorityStrategies: NameStrategy[] = [\n  // associated LABEL text\n  (element, userProgrammaticAttribute) => {\n    // IE does not support element.labels, so we fallback to a CSS selector based on the element id\n    // instead\n    if (supportsLabelProperty()) {\n      if ('labels' in element && element.labels && element.labels.length > 0) {\n        return getTextualContent(element.labels[0], userProgrammaticAttribute)\n      }\n    } else if (element.id) {\n      const label =\n        element.ownerDocument &&\n        find(element.ownerDocument.querySelectorAll('label'), (label) => label.htmlFor === element.id)\n      return label && getTextualContent(label, userProgrammaticAttribute)\n    }\n  },\n  // INPUT button (and associated) value\n  (element) => {\n    if (element.nodeName === 'INPUT') {\n      const input = element as HTMLInputElement\n      const type = input.getAttribute('type')\n      if (type === 'button' || type === 'submit' || type === 'reset') {\n        return input.value\n      }\n    }\n  },\n  // BUTTON, LABEL or button-like element text\n  (element, userProgrammaticAttribute) => {\n    if (element.nodeName === 'BUTTON' || element.nodeName === 'LABEL' || element.getAttribute('role') === 'button') {\n      return getTextualContent(element, userProgrammaticAttribute)\n    }\n  },\n  (element) => element.getAttribute('aria-label'),\n  // associated element text designated by the aria-labelledby attribute\n  (element, userProgrammaticAttribute) => {\n    const labelledByAttribute = element.getAttribute('aria-labelledby')\n    if (labelledByAttribute) {\n      return labelledByAttribute\n        .split(/\\s+/)\n        .map((id) => getElementById(element, id))\n        .filter((label): label is HTMLElement => Boolean(label))\n        .map((element) => getTextualContent(element, userProgrammaticAttribute))\n        .join(' ')\n    }\n  },\n  (element) => element.getAttribute('alt'),\n  (element) => element.getAttribute('name'),\n  (element) => element.getAttribute('title'),\n  (element) => element.getAttribute('placeholder'),\n  // SELECT first OPTION text\n  (element, userProgrammaticAttribute) => {\n    if ('options' in element && element.options.length > 0) {\n      return getTextualContent(element.options[0], userProgrammaticAttribute)\n    }\n  },\n]\n\nconst fallbackStrategies: NameStrategy[] = [\n  (element, userProgrammaticAttribute) => getTextualContent(element, userProgrammaticAttribute),\n]\n\n/**\n * Iterates over the target element and its parent, using the strategies list to get an action name.\n * Each strategies are applied on each element, stopping as soon as a non-empty value is returned.\n */\nconst MAX_PARENTS_TO_CONSIDER = 10\nfunction getActionNameFromElementForStrategies(\n  targetElement: Element,\n  userProgrammaticAttribute: string | undefined,\n  strategies: NameStrategy[]\n) {\n  let element: Element | null = targetElement\n  let recursionCounter = 0\n  while (\n    recursionCounter <= MAX_PARENTS_TO_CONSIDER &&\n    element &&\n    element.nodeName !== 'BODY' &&\n    element.nodeName !== 'HTML' &&\n    element.nodeName !== 'HEAD'\n  ) {\n    for (const strategy of strategies) {\n      const name = strategy(element, userProgrammaticAttribute)\n      if (typeof name === 'string') {\n        const trimmedName = name.trim()\n        if (trimmedName) {\n          return truncate(normalizeWhitespace(trimmedName))\n        }\n      }\n    }\n    // Consider a FORM as a contextual limit to get the action name.  This is experimental and may\n    // be reconsidered in the future.\n    if (element.nodeName === 'FORM') {\n      break\n    }\n    element = getParentElement(element)\n    recursionCounter += 1\n  }\n}\n\nfunction normalizeWhitespace(s: string) {\n  return s.replace(/\\s+/g, ' ')\n}\n\nfunction truncate(s: string) {\n  return s.length > 100 ? `${safeTruncate(s, 100)} [...]` : s\n}\n\nfunction getElementById(refElement: Element, id: string) {\n  // Use the element ownerDocument here, because tests are executed in an iframe, so\n  // document.getElementById won't work.\n  return refElement.ownerDocument ? refElement.ownerDocument.getElementById(id) : null\n}\n\nfunction getTextualContent(element: Element | HTMLElement, userProgrammaticAttribute: string | undefined) {\n  if ((element as HTMLElement).isContentEditable) {\n    return\n  }\n\n  if ('innerText' in element) {\n    let text = element.innerText\n\n    const removeTextFromElements = (query: string) => {\n      const list = element.querySelectorAll<Element | HTMLElement>(query)\n      for (let index = 0; index < list.length; index += 1) {\n        const element = list[index]\n        if ('innerText' in element) {\n          const textToReplace = element.innerText\n          if (textToReplace && textToReplace.trim().length > 0) {\n            text = text.replace(textToReplace, '')\n          }\n        }\n      }\n    }\n\n    if (!supportsInnerTextScriptAndStyleRemoval()) {\n      // remove the inner text of SCRIPT and STYLES from the result. This is a bit dirty, but should\n      // be relatively fast and work in most cases.\n      removeTextFromElements('script, style')\n    }\n\n    // remove the text of elements with programmatic attribute value\n    removeTextFromElements(`[${DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE}]`)\n\n    if (userProgrammaticAttribute) {\n      removeTextFromElements(`[${userProgrammaticAttribute}]`)\n    }\n\n    return text\n  }\n\n  return element.textContent\n}\n\n/**\n * Returns true if element.innerText excludes the text from inline SCRIPT and STYLE element. This\n * should be the case everywhere except on Internet Explorer 10 and 11 (see [1])\n *\n * The innerText property relies on what is actually rendered to compute its output, so to check if\n * it actually excludes SCRIPT and STYLE content, a solution would be to create a style element, set\n * its content to '*', inject it in the document body, and check if the style element innerText\n * property returns '*'. Using a new `document` instance won't work as it is not rendered.\n *\n * This solution requires specific CSP rules (see [2]) to be set by the customer. We want to avoid\n * this, so instead we rely on browser detection. In case of false negative, the impact should be\n * low, since we rely on this result to remove the SCRIPT and STYLE innerText (which will be empty)\n * from a parent element innerText.\n *\n * [1]: https://web.archive.org/web/20210602165716/http://perfectionkills.com/the-poor-misunderstood-innerText/#diff-with-textContent\n * [2]: https://github.com/DataDog/browser-sdk/issues/1084\n */\nfunction supportsInnerTextScriptAndStyleRemoval() {\n  return !isIE()\n}\n\n/**\n * Returns true if the browser supports the element.labels property.  This should be the case\n * everywhere except on Internet Explorer.\n * Note: The result is computed lazily, because we don't want any DOM access when the SDK is\n * evaluated.\n */\nlet supportsLabelPropertyResult: boolean | undefined\nfunction supportsLabelProperty() {\n  if (supportsLabelPropertyResult === undefined) {\n    supportsLabelPropertyResult = 'labels' in HTMLInputElement.prototype\n  }\n  return supportsLabelPropertyResult\n}\n\n/**\n * Returns true if the browser supports the element.closest method.  This should be the case\n * everywhere except on Internet Explorer.\n * Note: The result is computed lazily, because we don't want any DOM access when the SDK is\n * evaluated.\n */\nlet supportsElementClosestResult: boolean | undefined\nfunction supportsElementClosest() {\n  if (supportsElementClosestResult === undefined) {\n    supportsElementClosestResult = 'closest' in HTMLElement.prototype\n  }\n  return supportsElementClosestResult\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}