{"ast":null,"code":"import { round, find, ONE_SECOND, noop } from '@datadog/browser-core';\nimport { isElementNode } from '../../../browser/htmlDomUtils';\nimport { supportPerformanceTimingEvent, RumPerformanceEntryType } from '../../../browser/performanceCollection';\nimport { getSelectorFromElement } from '../../getSelectorFromElement';\n/**\n * Track the cumulative layout shifts (CLS).\n * Layout shifts are grouped into session windows.\n * The minimum gap between session windows is 1 second.\n * The maximum duration of a session window is 5 second.\n * The session window layout shift value is the sum of layout shifts inside it.\n * The CLS value is the max of session windows values.\n *\n * This yields a new value whenever the CLS value is updated (a higher session window value is computed).\n *\n * See isLayoutShiftSupported to check for browser support.\n *\n * Documentation:\n * https://web.dev/cls/\n * https://web.dev/evolving-cls/\n * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/getCLS.ts\n */\nexport function trackCumulativeLayoutShift(configuration, lifeCycle, callback) {\n  if (!isLayoutShiftSupported()) {\n    return {\n      stop: noop\n    };\n  }\n  var maxClsValue = 0;\n  // if no layout shift happen the value should be reported as 0\n  callback({\n    value: 0\n  });\n  var window = slidingSessionWindow();\n  var stop = lifeCycle.subscribe(0 /* LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED */, function (entries) {\n    for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {\n      var entry = entries_1[_i];\n      if (entry.entryType === RumPerformanceEntryType.LAYOUT_SHIFT && !entry.hadRecentInput) {\n        window.update(entry);\n        if (window.value() > maxClsValue) {\n          maxClsValue = window.value();\n          var cls = round(maxClsValue, 4);\n          var clsTarget = window.largestLayoutShiftTarget();\n          var cslTargetSelector = void 0;\n          if (clsTarget &&\n          // Check if the CLS target have been removed from the DOM between the time we collect the target reference and when we compute the selector\n          clsTarget.isConnected) {\n            cslTargetSelector = getSelectorFromElement(clsTarget, configuration.actionNameAttribute);\n          }\n          callback({\n            value: cls,\n            targetSelector: cslTargetSelector\n          });\n        }\n      }\n    }\n  }).unsubscribe;\n  return {\n    stop: stop\n  };\n}\nfunction slidingSessionWindow() {\n  var value = 0;\n  var startTime;\n  var endTime;\n  var largestLayoutShift = 0;\n  var largestLayoutShiftTarget;\n  var largestLayoutShiftTime;\n  return {\n    update: function (entry) {\n      var _a, _b;\n      var shouldCreateNewWindow = startTime === undefined || entry.startTime - endTime >= ONE_SECOND || entry.startTime - startTime >= 5 * ONE_SECOND;\n      if (shouldCreateNewWindow) {\n        startTime = endTime = entry.startTime;\n        value = entry.value;\n        largestLayoutShift = 0;\n        largestLayoutShiftTarget = undefined;\n      } else {\n        value += entry.value;\n        endTime = entry.startTime;\n      }\n      if (entry.value > largestLayoutShift) {\n        largestLayoutShift = entry.value;\n        largestLayoutShiftTime = entry.startTime;\n        if ((_a = entry.sources) === null || _a === void 0 ? void 0 : _a.length) {\n          largestLayoutShiftTarget = (_b = find(entry.sources, function (s) {\n            return !!s.node && isElementNode(s.node);\n          })) === null || _b === void 0 ? void 0 : _b.node;\n        } else {\n          largestLayoutShiftTarget = undefined;\n        }\n      }\n    },\n    value: function () {\n      return value;\n    },\n    largestLayoutShiftTarget: function () {\n      return largestLayoutShiftTarget;\n    },\n    largestLayoutShiftTime: function () {\n      return largestLayoutShiftTime;\n    }\n  };\n}\n/**\n * Check whether `layout-shift` is supported by the browser.\n */\nexport function isLayoutShiftSupported() {\n  return supportPerformanceTimingEvent(RumPerformanceEntryType.LAYOUT_SHIFT);\n}","map":{"version":3,"names":["round","find","ONE_SECOND","noop","isElementNode","supportPerformanceTimingEvent","RumPerformanceEntryType","getSelectorFromElement","trackCumulativeLayoutShift","configuration","lifeCycle","callback","isLayoutShiftSupported","stop","maxClsValue","value","window","slidingSessionWindow","subscribe","entries","_i","entries_1","length","entry","entryType","LAYOUT_SHIFT","hadRecentInput","update","cls","clsTarget","largestLayoutShiftTarget","cslTargetSelector","isConnected","actionNameAttribute","targetSelector","unsubscribe","startTime","endTime","largestLayoutShift","largestLayoutShiftTime","shouldCreateNewWindow","undefined","_a","sources","_b","s","node"],"sources":["D:\\edu'\\Spritle\\Spritle\\node_modules\\@datadog\\browser-rum-core\\src\\domain\\view\\viewMetrics\\trackCumulativeLayoutShift.ts"],"sourcesContent":["import { round, find, ONE_SECOND, noop } from '@datadog/browser-core'\nimport type { RelativeTime } from '@datadog/browser-core'\nimport { isElementNode } from '../../../browser/htmlDomUtils'\nimport type { LifeCycle } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport type { RumLayoutShiftTiming } from '../../../browser/performanceCollection'\nimport { supportPerformanceTimingEvent, RumPerformanceEntryType } from '../../../browser/performanceCollection'\nimport { getSelectorFromElement } from '../../getSelectorFromElement'\nimport type { RumConfiguration } from '../../configuration'\n\nexport interface CumulativeLayoutShift {\n  value: number\n  targetSelector?: string\n}\n\n/**\n * Track the cumulative layout shifts (CLS).\n * Layout shifts are grouped into session windows.\n * The minimum gap between session windows is 1 second.\n * The maximum duration of a session window is 5 second.\n * The session window layout shift value is the sum of layout shifts inside it.\n * The CLS value is the max of session windows values.\n *\n * This yields a new value whenever the CLS value is updated (a higher session window value is computed).\n *\n * See isLayoutShiftSupported to check for browser support.\n *\n * Documentation:\n * https://web.dev/cls/\n * https://web.dev/evolving-cls/\n * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/getCLS.ts\n */\nexport function trackCumulativeLayoutShift(\n  configuration: RumConfiguration,\n  lifeCycle: LifeCycle,\n  callback: (cumulativeLayoutShift: CumulativeLayoutShift) => void\n) {\n  if (!isLayoutShiftSupported()) {\n    return {\n      stop: noop,\n    }\n  }\n\n  let maxClsValue = 0\n\n  // if no layout shift happen the value should be reported as 0\n  callback({\n    value: 0,\n  })\n\n  const window = slidingSessionWindow()\n  const { unsubscribe: stop } = lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED, (entries) => {\n    for (const entry of entries) {\n      if (entry.entryType === RumPerformanceEntryType.LAYOUT_SHIFT && !entry.hadRecentInput) {\n        window.update(entry)\n\n        if (window.value() > maxClsValue) {\n          maxClsValue = window.value()\n          const cls = round(maxClsValue, 4)\n          const clsTarget = window.largestLayoutShiftTarget()\n          let cslTargetSelector\n\n          if (\n            clsTarget &&\n            // Check if the CLS target have been removed from the DOM between the time we collect the target reference and when we compute the selector\n            clsTarget.isConnected\n          ) {\n            cslTargetSelector = getSelectorFromElement(clsTarget, configuration.actionNameAttribute)\n          }\n\n          callback({\n            value: cls,\n            targetSelector: cslTargetSelector,\n          })\n        }\n      }\n    }\n  })\n\n  return {\n    stop,\n  }\n}\n\nfunction slidingSessionWindow() {\n  let value = 0\n  let startTime: RelativeTime\n  let endTime: RelativeTime\n\n  let largestLayoutShift = 0\n  let largestLayoutShiftTarget: HTMLElement | undefined\n  let largestLayoutShiftTime: RelativeTime\n  return {\n    update: (entry: RumLayoutShiftTiming) => {\n      const shouldCreateNewWindow =\n        startTime === undefined ||\n        entry.startTime - endTime >= ONE_SECOND ||\n        entry.startTime - startTime >= 5 * ONE_SECOND\n\n      if (shouldCreateNewWindow) {\n        startTime = endTime = entry.startTime\n        value = entry.value\n        largestLayoutShift = 0\n        largestLayoutShiftTarget = undefined\n      } else {\n        value += entry.value\n        endTime = entry.startTime\n      }\n\n      if (entry.value > largestLayoutShift) {\n        largestLayoutShift = entry.value\n        largestLayoutShiftTime = entry.startTime\n        if (entry.sources?.length) {\n          largestLayoutShiftTarget = find(\n            entry.sources,\n            (s): s is { node: HTMLElement } => !!s.node && isElementNode(s.node)\n          )?.node\n        } else {\n          largestLayoutShiftTarget = undefined\n        }\n      }\n    },\n    value: () => value,\n    largestLayoutShiftTarget: () => largestLayoutShiftTarget,\n    largestLayoutShiftTime: () => largestLayoutShiftTime,\n  }\n}\n\n/**\n * Check whether `layout-shift` is supported by the browser.\n */\nexport function isLayoutShiftSupported() {\n  return supportPerformanceTimingEvent(RumPerformanceEntryType.LAYOUT_SHIFT)\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}