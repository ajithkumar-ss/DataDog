{"ast":null,"code":"import { display } from '../tools/display';\nimport { ONE_MINUTE, ONE_SECOND } from '../tools/utils/timeUtils';\nimport { findCommaSeparatedValue, findCommaSeparatedValues, generateUUID } from '../tools/utils/stringUtils';\nexport function setCookie(name, value, expireDelay, options) {\n  var date = new Date();\n  date.setTime(date.getTime() + expireDelay);\n  var expires = \"expires=\".concat(date.toUTCString());\n  var sameSite = options && options.crossSite ? 'none' : 'strict';\n  var domain = options && options.domain ? \";domain=\".concat(options.domain) : '';\n  var secure = options && options.secure ? ';secure' : '';\n  var partitioned = options && options.partitioned ? ';partitioned' : '';\n  document.cookie = \"\".concat(name, \"=\").concat(value, \";\").concat(expires, \";path=/;samesite=\").concat(sameSite).concat(domain).concat(secure).concat(partitioned);\n}\nexport function getCookie(name) {\n  return findCommaSeparatedValue(document.cookie, name);\n}\nvar initCookieParsed;\n/**\n * Returns a cached value of the cookie. Use this during SDK initialization (and whenever possible)\n * to avoid accessing document.cookie multiple times.\n */\nexport function getInitCookie(name) {\n  if (!initCookieParsed) {\n    initCookieParsed = findCommaSeparatedValues(document.cookie);\n  }\n  return initCookieParsed.get(name);\n}\nexport function resetInitCookies() {\n  initCookieParsed = undefined;\n}\nexport function deleteCookie(name, options) {\n  setCookie(name, '', 0, options);\n}\nexport function areCookiesAuthorized(options) {\n  if (document.cookie === undefined || document.cookie === null) {\n    return false;\n  }\n  try {\n    // Use a unique cookie name to avoid issues when the SDK is initialized multiple times during\n    // the test cookie lifetime\n    var testCookieName = \"dd_cookie_test_\".concat(generateUUID());\n    var testCookieValue = 'test';\n    setCookie(testCookieName, testCookieValue, ONE_MINUTE, options);\n    var isCookieCorrectlySet = getCookie(testCookieName) === testCookieValue;\n    deleteCookie(testCookieName, options);\n    return isCookieCorrectlySet;\n  } catch (error) {\n    display.error(error);\n    return false;\n  }\n}\n/**\n * No API to retrieve it, number of levels for subdomain and suffix are unknown\n * strategy: find the minimal domain on which cookies are allowed to be set\n * https://web.dev/same-site-same-origin/#site\n */\nvar getCurrentSiteCache;\nexport function getCurrentSite() {\n  if (getCurrentSiteCache === undefined) {\n    // Use a unique cookie name to avoid issues when the SDK is initialized multiple times during\n    // the test cookie lifetime\n    var testCookieName = \"dd_site_test_\".concat(generateUUID());\n    var testCookieValue = 'test';\n    var domainLevels = window.location.hostname.split('.');\n    var candidateDomain = domainLevels.pop();\n    while (domainLevels.length && !getCookie(testCookieName)) {\n      candidateDomain = \"\".concat(domainLevels.pop(), \".\").concat(candidateDomain);\n      setCookie(testCookieName, testCookieValue, ONE_SECOND, {\n        domain: candidateDomain\n      });\n    }\n    deleteCookie(testCookieName, {\n      domain: candidateDomain\n    });\n    getCurrentSiteCache = candidateDomain;\n  }\n  return getCurrentSiteCache;\n}","map":{"version":3,"names":["display","ONE_MINUTE","ONE_SECOND","findCommaSeparatedValue","findCommaSeparatedValues","generateUUID","setCookie","name","value","expireDelay","options","date","Date","setTime","getTime","expires","concat","toUTCString","sameSite","crossSite","domain","secure","partitioned","document","cookie","getCookie","initCookieParsed","getInitCookie","get","resetInitCookies","undefined","deleteCookie","areCookiesAuthorized","testCookieName","testCookieValue","isCookieCorrectlySet","error","getCurrentSiteCache","getCurrentSite","domainLevels","window","location","hostname","split","candidateDomain","pop","length"],"sources":["D:\\edu'\\Spritle\\spritle\\node_modules\\@datadog\\browser-core\\src\\browser\\cookie.ts"],"sourcesContent":["import { display } from '../tools/display'\nimport { ONE_MINUTE, ONE_SECOND } from '../tools/utils/timeUtils'\nimport { findCommaSeparatedValue, findCommaSeparatedValues, generateUUID } from '../tools/utils/stringUtils'\n\nexport interface CookieOptions {\n  secure?: boolean\n  crossSite?: boolean\n  partitioned?: boolean\n  domain?: string\n}\n\nexport function setCookie(name: string, value: string, expireDelay: number, options?: CookieOptions) {\n  const date = new Date()\n  date.setTime(date.getTime() + expireDelay)\n  const expires = `expires=${date.toUTCString()}`\n  const sameSite = options && options.crossSite ? 'none' : 'strict'\n  const domain = options && options.domain ? `;domain=${options.domain}` : ''\n  const secure = options && options.secure ? ';secure' : ''\n  const partitioned = options && options.partitioned ? ';partitioned' : ''\n  document.cookie = `${name}=${value};${expires};path=/;samesite=${sameSite}${domain}${secure}${partitioned}`\n}\n\nexport function getCookie(name: string) {\n  return findCommaSeparatedValue(document.cookie, name)\n}\n\nlet initCookieParsed: Map<string, string> | undefined\n\n/**\n * Returns a cached value of the cookie. Use this during SDK initialization (and whenever possible)\n * to avoid accessing document.cookie multiple times.\n */\nexport function getInitCookie(name: string) {\n  if (!initCookieParsed) {\n    initCookieParsed = findCommaSeparatedValues(document.cookie)\n  }\n  return initCookieParsed.get(name)\n}\n\nexport function resetInitCookies() {\n  initCookieParsed = undefined\n}\n\nexport function deleteCookie(name: string, options?: CookieOptions) {\n  setCookie(name, '', 0, options)\n}\n\nexport function areCookiesAuthorized(options: CookieOptions): boolean {\n  if (document.cookie === undefined || document.cookie === null) {\n    return false\n  }\n  try {\n    // Use a unique cookie name to avoid issues when the SDK is initialized multiple times during\n    // the test cookie lifetime\n    const testCookieName = `dd_cookie_test_${generateUUID()}`\n    const testCookieValue = 'test'\n    setCookie(testCookieName, testCookieValue, ONE_MINUTE, options)\n    const isCookieCorrectlySet = getCookie(testCookieName) === testCookieValue\n    deleteCookie(testCookieName, options)\n    return isCookieCorrectlySet\n  } catch (error) {\n    display.error(error)\n    return false\n  }\n}\n\n/**\n * No API to retrieve it, number of levels for subdomain and suffix are unknown\n * strategy: find the minimal domain on which cookies are allowed to be set\n * https://web.dev/same-site-same-origin/#site\n */\nlet getCurrentSiteCache: string | undefined\nexport function getCurrentSite() {\n  if (getCurrentSiteCache === undefined) {\n    // Use a unique cookie name to avoid issues when the SDK is initialized multiple times during\n    // the test cookie lifetime\n    const testCookieName = `dd_site_test_${generateUUID()}`\n    const testCookieValue = 'test'\n\n    const domainLevels = window.location.hostname.split('.')\n    let candidateDomain = domainLevels.pop()!\n    while (domainLevels.length && !getCookie(testCookieName)) {\n      candidateDomain = `${domainLevels.pop()!}.${candidateDomain}`\n      setCookie(testCookieName, testCookieValue, ONE_SECOND, { domain: candidateDomain })\n    }\n    deleteCookie(testCookieName, { domain: candidateDomain })\n    getCurrentSiteCache = candidateDomain\n  }\n  return getCurrentSiteCache\n}\n"],"mappings":"AAAA,SAASA,OAAO,QAAQ,kBAAkB;AAC1C,SAASC,UAAU,EAAEC,UAAU,QAAQ,0BAA0B;AACjE,SAASC,uBAAuB,EAAEC,wBAAwB,EAAEC,YAAY,QAAQ,4BAA4B;AAS5G,OAAM,SAAUC,SAASA,CAACC,IAAY,EAAEC,KAAa,EAAEC,WAAmB,EAAEC,OAAuB;EACjG,IAAMC,IAAI,GAAG,IAAIC,IAAI,EAAE;EACvBD,IAAI,CAACE,OAAO,CAACF,IAAI,CAACG,OAAO,EAAE,GAAGL,WAAW,CAAC;EAC1C,IAAMM,OAAO,GAAG,WAAAC,MAAA,CAAWL,IAAI,CAACM,WAAW,EAAE,CAAE;EAC/C,IAAMC,QAAQ,GAAGR,OAAO,IAAIA,OAAO,CAACS,SAAS,GAAG,MAAM,GAAG,QAAQ;EACjE,IAAMC,MAAM,GAAGV,OAAO,IAAIA,OAAO,CAACU,MAAM,GAAG,WAAAJ,MAAA,CAAWN,OAAO,CAACU,MAAM,CAAE,GAAG,EAAE;EAC3E,IAAMC,MAAM,GAAGX,OAAO,IAAIA,OAAO,CAACW,MAAM,GAAG,SAAS,GAAG,EAAE;EACzD,IAAMC,WAAW,GAAGZ,OAAO,IAAIA,OAAO,CAACY,WAAW,GAAG,cAAc,GAAG,EAAE;EACxEC,QAAQ,CAACC,MAAM,GAAG,GAAAR,MAAA,CAAGT,IAAI,OAAAS,MAAA,CAAIR,KAAK,OAAAQ,MAAA,CAAID,OAAO,uBAAAC,MAAA,CAAoBE,QAAQ,EAAAF,MAAA,CAAGI,MAAM,EAAAJ,MAAA,CAAGK,MAAM,EAAAL,MAAA,CAAGM,WAAW,CAAE;AAC7G;AAEA,OAAM,SAAUG,SAASA,CAAClB,IAAY;EACpC,OAAOJ,uBAAuB,CAACoB,QAAQ,CAACC,MAAM,EAAEjB,IAAI,CAAC;AACvD;AAEA,IAAImB,gBAAiD;AAErD;;;;AAIA,OAAM,SAAUC,aAAaA,CAACpB,IAAY;EACxC,IAAI,CAACmB,gBAAgB,EAAE;IACrBA,gBAAgB,GAAGtB,wBAAwB,CAACmB,QAAQ,CAACC,MAAM,CAAC;EAC9D;EACA,OAAOE,gBAAgB,CAACE,GAAG,CAACrB,IAAI,CAAC;AACnC;AAEA,OAAM,SAAUsB,gBAAgBA,CAAA;EAC9BH,gBAAgB,GAAGI,SAAS;AAC9B;AAEA,OAAM,SAAUC,YAAYA,CAACxB,IAAY,EAAEG,OAAuB;EAChEJ,SAAS,CAACC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAEG,OAAO,CAAC;AACjC;AAEA,OAAM,SAAUsB,oBAAoBA,CAACtB,OAAsB;EACzD,IAAIa,QAAQ,CAACC,MAAM,KAAKM,SAAS,IAAIP,QAAQ,CAACC,MAAM,KAAK,IAAI,EAAE;IAC7D,OAAO,KAAK;EACd;EACA,IAAI;IACF;IACA;IACA,IAAMS,cAAc,GAAG,kBAAAjB,MAAA,CAAkBX,YAAY,EAAE,CAAE;IACzD,IAAM6B,eAAe,GAAG,MAAM;IAC9B5B,SAAS,CAAC2B,cAAc,EAAEC,eAAe,EAAEjC,UAAU,EAAES,OAAO,CAAC;IAC/D,IAAMyB,oBAAoB,GAAGV,SAAS,CAACQ,cAAc,CAAC,KAAKC,eAAe;IAC1EH,YAAY,CAACE,cAAc,EAAEvB,OAAO,CAAC;IACrC,OAAOyB,oBAAoB;EAC7B,CAAC,CAAC,OAAOC,KAAK,EAAE;IACdpC,OAAO,CAACoC,KAAK,CAACA,KAAK,CAAC;IACpB,OAAO,KAAK;EACd;AACF;AAEA;;;;;AAKA,IAAIC,mBAAuC;AAC3C,OAAM,SAAUC,cAAcA,CAAA;EAC5B,IAAID,mBAAmB,KAAKP,SAAS,EAAE;IACrC;IACA;IACA,IAAMG,cAAc,GAAG,gBAAAjB,MAAA,CAAgBX,YAAY,EAAE,CAAE;IACvD,IAAM6B,eAAe,GAAG,MAAM;IAE9B,IAAMK,YAAY,GAAGC,MAAM,CAACC,QAAQ,CAACC,QAAQ,CAACC,KAAK,CAAC,GAAG,CAAC;IACxD,IAAIC,eAAe,GAAGL,YAAY,CAACM,GAAG,EAAG;IACzC,OAAON,YAAY,CAACO,MAAM,IAAI,CAACrB,SAAS,CAACQ,cAAc,CAAC,EAAE;MACxDW,eAAe,GAAG,GAAA5B,MAAA,CAAGuB,YAAY,CAACM,GAAG,EAAG,OAAA7B,MAAA,CAAI4B,eAAe,CAAE;MAC7DtC,SAAS,CAAC2B,cAAc,EAAEC,eAAe,EAAEhC,UAAU,EAAE;QAAEkB,MAAM,EAAEwB;MAAe,CAAE,CAAC;IACrF;IACAb,YAAY,CAACE,cAAc,EAAE;MAAEb,MAAM,EAAEwB;IAAe,CAAE,CAAC;IACzDP,mBAAmB,GAAGO,eAAe;EACvC;EACA,OAAOP,mBAAmB;AAC5B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}