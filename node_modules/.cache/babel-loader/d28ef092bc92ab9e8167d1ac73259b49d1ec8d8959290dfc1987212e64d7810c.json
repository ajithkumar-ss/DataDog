{"ast":null,"code":"import { addTelemetryError } from '../domain/telemetry';\nimport { monitor } from '../tools/monitor';\nimport { addEventListener } from '../browser/addEventListener';\nimport { newRetryState, sendWithRetryStrategy } from './sendWithRetryStrategy';\nexport function createHttpRequest(configuration, endpointBuilder, bytesLimit, reportError) {\n  var retryState = newRetryState();\n  var sendStrategyForRetry = function (payload, onResponse) {\n    return fetchKeepAliveStrategy(configuration, endpointBuilder, bytesLimit, payload, onResponse);\n  };\n  return {\n    send: function (payload) {\n      sendWithRetryStrategy(payload, retryState, sendStrategyForRetry, endpointBuilder.trackType, reportError);\n    },\n    /**\n     * Since fetch keepalive behaves like regular fetch on Firefox,\n     * keep using sendBeaconStrategy on exit\n     */\n    sendOnExit: function (payload) {\n      sendBeaconStrategy(configuration, endpointBuilder, bytesLimit, payload);\n    }\n  };\n}\nfunction sendBeaconStrategy(configuration, endpointBuilder, bytesLimit, payload) {\n  var canUseBeacon = !!navigator.sendBeacon && payload.bytesCount < bytesLimit;\n  if (canUseBeacon) {\n    try {\n      var beaconUrl = endpointBuilder.build('beacon', payload);\n      var isQueued = navigator.sendBeacon(beaconUrl, payload.data);\n      if (isQueued) {\n        return;\n      }\n    } catch (e) {\n      reportBeaconError(e);\n    }\n  }\n  var xhrUrl = endpointBuilder.build('xhr', payload);\n  sendXHR(configuration, xhrUrl, payload.data);\n}\nvar hasReportedBeaconError = false;\nfunction reportBeaconError(e) {\n  if (!hasReportedBeaconError) {\n    hasReportedBeaconError = true;\n    addTelemetryError(e);\n  }\n}\nexport function fetchKeepAliveStrategy(configuration, endpointBuilder, bytesLimit, payload, onResponse) {\n  var canUseKeepAlive = isKeepAliveSupported() && payload.bytesCount < bytesLimit;\n  if (canUseKeepAlive) {\n    var fetchUrl = endpointBuilder.build('fetch', payload);\n    fetch(fetchUrl, {\n      method: 'POST',\n      body: payload.data,\n      keepalive: true,\n      mode: 'cors'\n    }).then(monitor(function (response) {\n      return onResponse === null || onResponse === void 0 ? void 0 : onResponse({\n        status: response.status,\n        type: response.type\n      });\n    }), monitor(function () {\n      var xhrUrl = endpointBuilder.build('xhr', payload);\n      // failed to queue the request\n      sendXHR(configuration, xhrUrl, payload.data, onResponse);\n    }));\n  } else {\n    var xhrUrl = endpointBuilder.build('xhr', payload);\n    sendXHR(configuration, xhrUrl, payload.data, onResponse);\n  }\n}\nfunction isKeepAliveSupported() {\n  // Request can throw, cf https://developer.mozilla.org/en-US/docs/Web/API/Request/Request#errors\n  try {\n    return window.Request && 'keepalive' in new Request('http://a');\n  } catch (_a) {\n    return false;\n  }\n}\nexport function sendXHR(configuration, url, data, onResponse) {\n  var request = new XMLHttpRequest();\n  request.open('POST', url, true);\n  if (data instanceof Blob) {\n    // When using a Blob instance, IE does not use its 'type' to define the 'Content-Type' header\n    // automatically, so the intake request ends up being rejected with an HTTP status 415\n    // Defining the header manually fixes this issue.\n    request.setRequestHeader('Content-Type', data.type);\n  }\n  addEventListener(configuration, request, 'loadend', function () {\n    onResponse === null || onResponse === void 0 ? void 0 : onResponse({\n      status: request.status\n    });\n  }, {\n    // prevent multiple onResponse callbacks\n    // if the xhr instance is reused by a third party\n    once: true\n  });\n  request.send(data);\n}","map":{"version":3,"names":["addTelemetryError","monitor","addEventListener","newRetryState","sendWithRetryStrategy","createHttpRequest","configuration","endpointBuilder","bytesLimit","reportError","retryState","sendStrategyForRetry","payload","onResponse","fetchKeepAliveStrategy","send","trackType","sendOnExit","sendBeaconStrategy","canUseBeacon","navigator","sendBeacon","bytesCount","beaconUrl","build","isQueued","data","e","reportBeaconError","xhrUrl","sendXHR","hasReportedBeaconError","canUseKeepAlive","isKeepAliveSupported","fetchUrl","fetch","method","body","keepalive","mode","then","response","status","type","window","Request","_a","url","request","XMLHttpRequest","open","Blob","setRequestHeader","once"],"sources":["D:\\edu'\\Spritle\\spritle\\node_modules\\@datadog\\browser-core\\src\\transport\\httpRequest.ts"],"sourcesContent":["import type { EndpointBuilder, Configuration } from '../domain/configuration'\nimport { addTelemetryError } from '../domain/telemetry'\nimport type { Context } from '../tools/serialisation/context'\nimport { monitor } from '../tools/monitor'\nimport { addEventListener } from '../browser/addEventListener'\nimport type { RawError } from '../domain/error/error.types'\nimport { newRetryState, sendWithRetryStrategy } from './sendWithRetryStrategy'\nimport type { FlushReason } from './flushController'\n\n/**\n * Use POST request without content type to:\n * - avoid CORS preflight requests\n * - allow usage of sendBeacon\n *\n * multiple elements are sent separated by \\n in order\n * to be parsed correctly without content type header\n */\n\nexport type HttpRequest = ReturnType<typeof createHttpRequest>\n\nexport interface HttpResponse extends Context {\n  status: number\n  type?: ResponseType\n}\n\nexport interface Payload {\n  data: string | FormData | Blob\n  bytesCount: number\n  retry?: RetryInfo\n  flushReason?: FlushReason\n  encoding?: 'deflate'\n}\n\nexport interface RetryInfo {\n  count: number\n  lastFailureStatus: number\n}\n\nexport function createHttpRequest(\n  configuration: Configuration,\n  endpointBuilder: EndpointBuilder,\n  bytesLimit: number,\n  reportError: (error: RawError) => void\n) {\n  const retryState = newRetryState()\n  const sendStrategyForRetry = (payload: Payload, onResponse: (r: HttpResponse) => void) =>\n    fetchKeepAliveStrategy(configuration, endpointBuilder, bytesLimit, payload, onResponse)\n\n  return {\n    send: (payload: Payload) => {\n      sendWithRetryStrategy(payload, retryState, sendStrategyForRetry, endpointBuilder.trackType, reportError)\n    },\n    /**\n     * Since fetch keepalive behaves like regular fetch on Firefox,\n     * keep using sendBeaconStrategy on exit\n     */\n    sendOnExit: (payload: Payload) => {\n      sendBeaconStrategy(configuration, endpointBuilder, bytesLimit, payload)\n    },\n  }\n}\n\nfunction sendBeaconStrategy(\n  configuration: Configuration,\n  endpointBuilder: EndpointBuilder,\n  bytesLimit: number,\n  payload: Payload\n) {\n  const canUseBeacon = !!navigator.sendBeacon && payload.bytesCount < bytesLimit\n  if (canUseBeacon) {\n    try {\n      const beaconUrl = endpointBuilder.build('beacon', payload)\n      const isQueued = navigator.sendBeacon(beaconUrl, payload.data)\n\n      if (isQueued) {\n        return\n      }\n    } catch (e) {\n      reportBeaconError(e)\n    }\n  }\n\n  const xhrUrl = endpointBuilder.build('xhr', payload)\n  sendXHR(configuration, xhrUrl, payload.data)\n}\n\nlet hasReportedBeaconError = false\n\nfunction reportBeaconError(e: unknown) {\n  if (!hasReportedBeaconError) {\n    hasReportedBeaconError = true\n    addTelemetryError(e)\n  }\n}\n\nexport function fetchKeepAliveStrategy(\n  configuration: Configuration,\n  endpointBuilder: EndpointBuilder,\n  bytesLimit: number,\n  payload: Payload,\n  onResponse?: (r: HttpResponse) => void\n) {\n  const canUseKeepAlive = isKeepAliveSupported() && payload.bytesCount < bytesLimit\n  if (canUseKeepAlive) {\n    const fetchUrl = endpointBuilder.build('fetch', payload)\n    fetch(fetchUrl, { method: 'POST', body: payload.data, keepalive: true, mode: 'cors' }).then(\n      monitor((response: Response) => onResponse?.({ status: response.status, type: response.type })),\n      monitor(() => {\n        const xhrUrl = endpointBuilder.build('xhr', payload)\n        // failed to queue the request\n        sendXHR(configuration, xhrUrl, payload.data, onResponse)\n      })\n    )\n  } else {\n    const xhrUrl = endpointBuilder.build('xhr', payload)\n    sendXHR(configuration, xhrUrl, payload.data, onResponse)\n  }\n}\n\nfunction isKeepAliveSupported() {\n  // Request can throw, cf https://developer.mozilla.org/en-US/docs/Web/API/Request/Request#errors\n  try {\n    return window.Request && 'keepalive' in new Request('http://a')\n  } catch {\n    return false\n  }\n}\n\nexport function sendXHR(\n  configuration: Configuration,\n  url: string,\n  data: Payload['data'],\n  onResponse?: (r: HttpResponse) => void\n) {\n  const request = new XMLHttpRequest()\n  request.open('POST', url, true)\n  if (data instanceof Blob) {\n    // When using a Blob instance, IE does not use its 'type' to define the 'Content-Type' header\n    // automatically, so the intake request ends up being rejected with an HTTP status 415\n    // Defining the header manually fixes this issue.\n    request.setRequestHeader('Content-Type', data.type)\n  }\n  addEventListener(\n    configuration,\n    request,\n    'loadend',\n    () => {\n      onResponse?.({ status: request.status })\n    },\n    {\n      // prevent multiple onResponse callbacks\n      // if the xhr instance is reused by a third party\n      once: true,\n    }\n  )\n  request.send(data)\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}