{"ast":null,"code":"import { Observable } from '../../tools/observable';\nimport { ValueHistory } from '../../tools/valueHistory';\nimport { relativeNow, clocksOrigin, ONE_MINUTE } from '../../tools/utils/timeUtils';\nimport { DOM_EVENT, addEventListener, addEventListeners } from '../../browser/addEventListener';\nimport { clearInterval, setInterval } from '../../tools/timer';\nimport { SESSION_TIME_OUT_DELAY } from './sessionConstants';\nimport { startSessionStore } from './sessionStore';\nexport var VISIBILITY_CHECK_DELAY = ONE_MINUTE;\nvar SESSION_CONTEXT_TIMEOUT_DELAY = SESSION_TIME_OUT_DELAY;\nvar stopCallbacks = [];\nexport function startSessionManager(configuration, productKey, computeSessionState, trackingConsentState) {\n  var renewObservable = new Observable();\n  var expireObservable = new Observable();\n  // TODO - Improve configuration type and remove assertion\n  var sessionStore = startSessionStore(configuration.sessionStoreStrategyType, productKey, computeSessionState);\n  stopCallbacks.push(function () {\n    return sessionStore.stop();\n  });\n  var sessionContextHistory = new ValueHistory(SESSION_CONTEXT_TIMEOUT_DELAY);\n  stopCallbacks.push(function () {\n    return sessionContextHistory.stop();\n  });\n  sessionStore.renewObservable.subscribe(function () {\n    sessionContextHistory.add(buildSessionContext(), relativeNow());\n    renewObservable.notify();\n  });\n  sessionStore.expireObservable.subscribe(function () {\n    expireObservable.notify();\n    sessionContextHistory.closeActive(relativeNow());\n  });\n  // We expand/renew session unconditionally as tracking consent is always granted when the session\n  // manager is started.\n  sessionStore.expandOrRenewSession();\n  sessionContextHistory.add(buildSessionContext(), clocksOrigin().relative);\n  trackingConsentState.observable.subscribe(function () {\n    if (trackingConsentState.isGranted()) {\n      sessionStore.expandOrRenewSession();\n    } else {\n      sessionStore.expire();\n    }\n  });\n  trackActivity(configuration, function () {\n    if (trackingConsentState.isGranted()) {\n      sessionStore.expandOrRenewSession();\n    }\n  });\n  trackVisibility(configuration, function () {\n    return sessionStore.expandSession();\n  });\n  trackResume(configuration, function () {\n    return sessionStore.restartSession();\n  });\n  function buildSessionContext() {\n    return {\n      id: sessionStore.getSession().id,\n      trackingType: sessionStore.getSession()[productKey]\n    };\n  }\n  return {\n    findActiveSession: function (startTime) {\n      return sessionContextHistory.find(startTime);\n    },\n    renewObservable: renewObservable,\n    expireObservable: expireObservable,\n    expire: sessionStore.expire\n  };\n}\nexport function stopSessionManager() {\n  stopCallbacks.forEach(function (e) {\n    return e();\n  });\n  stopCallbacks = [];\n}\nfunction trackActivity(configuration, expandOrRenewSession) {\n  var stop = addEventListeners(configuration, window, [DOM_EVENT.CLICK, DOM_EVENT.TOUCH_START, DOM_EVENT.KEY_DOWN, DOM_EVENT.SCROLL], expandOrRenewSession, {\n    capture: true,\n    passive: true\n  }).stop;\n  stopCallbacks.push(stop);\n}\nfunction trackVisibility(configuration, expandSession) {\n  var expandSessionWhenVisible = function () {\n    if (document.visibilityState === 'visible') {\n      expandSession();\n    }\n  };\n  var stop = addEventListener(configuration, document, DOM_EVENT.VISIBILITY_CHANGE, expandSessionWhenVisible).stop;\n  stopCallbacks.push(stop);\n  var visibilityCheckInterval = setInterval(expandSessionWhenVisible, VISIBILITY_CHECK_DELAY);\n  stopCallbacks.push(function () {\n    clearInterval(visibilityCheckInterval);\n  });\n}\nfunction trackResume(configuration, cb) {\n  var stop = addEventListener(configuration, window, DOM_EVENT.RESUME, cb, {\n    capture: true\n  }).stop;\n  stopCallbacks.push(stop);\n}","map":{"version":3,"names":["Observable","ValueHistory","relativeNow","clocksOrigin","ONE_MINUTE","DOM_EVENT","addEventListener","addEventListeners","clearInterval","setInterval","SESSION_TIME_OUT_DELAY","startSessionStore","VISIBILITY_CHECK_DELAY","SESSION_CONTEXT_TIMEOUT_DELAY","stopCallbacks","startSessionManager","configuration","productKey","computeSessionState","trackingConsentState","renewObservable","expireObservable","sessionStore","sessionStoreStrategyType","push","stop","sessionContextHistory","subscribe","add","buildSessionContext","notify","closeActive","expandOrRenewSession","relative","observable","isGranted","expire","trackActivity","trackVisibility","expandSession","trackResume","restartSession","id","getSession","trackingType","findActiveSession","startTime","find","stopSessionManager","forEach","e","window","CLICK","TOUCH_START","KEY_DOWN","SCROLL","capture","passive","expandSessionWhenVisible","document","visibilityState","VISIBILITY_CHANGE","visibilityCheckInterval","cb","RESUME"],"sources":["D:\\edu'\\Spritle\\spritle\\node_modules\\@datadog\\browser-core\\src\\domain\\session\\sessionManager.ts"],"sourcesContent":["import { Observable } from '../../tools/observable'\nimport type { Context } from '../../tools/serialisation/context'\nimport { ValueHistory } from '../../tools/valueHistory'\nimport type { RelativeTime } from '../../tools/utils/timeUtils'\nimport { relativeNow, clocksOrigin, ONE_MINUTE } from '../../tools/utils/timeUtils'\nimport { DOM_EVENT, addEventListener, addEventListeners } from '../../browser/addEventListener'\nimport { clearInterval, setInterval } from '../../tools/timer'\nimport type { Configuration } from '../configuration'\nimport type { TrackingConsentState } from '../trackingConsent'\nimport { SESSION_TIME_OUT_DELAY } from './sessionConstants'\nimport { startSessionStore } from './sessionStore'\n\nexport interface SessionManager<TrackingType extends string> {\n  findActiveSession: (startTime?: RelativeTime) => SessionContext<TrackingType> | undefined\n  renewObservable: Observable<void>\n  expireObservable: Observable<void>\n  expire: () => void\n}\n\nexport interface SessionContext<TrackingType extends string> extends Context {\n  id: string\n  trackingType: TrackingType\n}\n\nexport const VISIBILITY_CHECK_DELAY = ONE_MINUTE\nconst SESSION_CONTEXT_TIMEOUT_DELAY = SESSION_TIME_OUT_DELAY\nlet stopCallbacks: Array<() => void> = []\n\nexport function startSessionManager<TrackingType extends string>(\n  configuration: Configuration,\n  productKey: string,\n  computeSessionState: (rawTrackingType?: string) => { trackingType: TrackingType; isTracked: boolean },\n  trackingConsentState: TrackingConsentState\n): SessionManager<TrackingType> {\n  const renewObservable = new Observable<void>()\n  const expireObservable = new Observable<void>()\n\n  // TODO - Improve configuration type and remove assertion\n  const sessionStore = startSessionStore(configuration.sessionStoreStrategyType!, productKey, computeSessionState)\n  stopCallbacks.push(() => sessionStore.stop())\n\n  const sessionContextHistory = new ValueHistory<SessionContext<TrackingType>>(SESSION_CONTEXT_TIMEOUT_DELAY)\n  stopCallbacks.push(() => sessionContextHistory.stop())\n\n  sessionStore.renewObservable.subscribe(() => {\n    sessionContextHistory.add(buildSessionContext(), relativeNow())\n    renewObservable.notify()\n  })\n  sessionStore.expireObservable.subscribe(() => {\n    expireObservable.notify()\n    sessionContextHistory.closeActive(relativeNow())\n  })\n\n  // We expand/renew session unconditionally as tracking consent is always granted when the session\n  // manager is started.\n  sessionStore.expandOrRenewSession()\n  sessionContextHistory.add(buildSessionContext(), clocksOrigin().relative)\n\n  trackingConsentState.observable.subscribe(() => {\n    if (trackingConsentState.isGranted()) {\n      sessionStore.expandOrRenewSession()\n    } else {\n      sessionStore.expire()\n    }\n  })\n\n  trackActivity(configuration, () => {\n    if (trackingConsentState.isGranted()) {\n      sessionStore.expandOrRenewSession()\n    }\n  })\n  trackVisibility(configuration, () => sessionStore.expandSession())\n  trackResume(configuration, () => sessionStore.restartSession())\n\n  function buildSessionContext() {\n    return {\n      id: sessionStore.getSession().id!,\n      trackingType: sessionStore.getSession()[productKey] as TrackingType,\n    }\n  }\n\n  return {\n    findActiveSession: (startTime) => sessionContextHistory.find(startTime),\n    renewObservable,\n    expireObservable,\n    expire: sessionStore.expire,\n  }\n}\n\nexport function stopSessionManager() {\n  stopCallbacks.forEach((e) => e())\n  stopCallbacks = []\n}\n\nfunction trackActivity(configuration: Configuration, expandOrRenewSession: () => void) {\n  const { stop } = addEventListeners(\n    configuration,\n    window,\n    [DOM_EVENT.CLICK, DOM_EVENT.TOUCH_START, DOM_EVENT.KEY_DOWN, DOM_EVENT.SCROLL],\n    expandOrRenewSession,\n    { capture: true, passive: true }\n  )\n  stopCallbacks.push(stop)\n}\n\nfunction trackVisibility(configuration: Configuration, expandSession: () => void) {\n  const expandSessionWhenVisible = () => {\n    if (document.visibilityState === 'visible') {\n      expandSession()\n    }\n  }\n\n  const { stop } = addEventListener(configuration, document, DOM_EVENT.VISIBILITY_CHANGE, expandSessionWhenVisible)\n  stopCallbacks.push(stop)\n\n  const visibilityCheckInterval = setInterval(expandSessionWhenVisible, VISIBILITY_CHECK_DELAY)\n  stopCallbacks.push(() => {\n    clearInterval(visibilityCheckInterval)\n  })\n}\n\nfunction trackResume(configuration: Configuration, cb: () => void) {\n  const { stop } = addEventListener(configuration, window, DOM_EVENT.RESUME, cb, { capture: true })\n  stopCallbacks.push(stop)\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}