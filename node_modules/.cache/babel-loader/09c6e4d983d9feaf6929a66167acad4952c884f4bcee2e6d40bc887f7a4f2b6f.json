{"ast":null,"code":"import { noop, ONE_MINUTE } from '@datadog/browser-core';\nimport { RumPerformanceEntryType, supportPerformanceTimingEvent } from '../../../browser/performanceCollection';\nimport { getSelectorFromElement } from '../../getSelectorFromElement';\nimport { isElementNode } from '../../../browser/htmlDomUtils';\nimport { getInteractionCount, initInteractionCountPolyfill } from './interactionCountPolyfill';\n// Arbitrary value to prevent unnecessary memory usage on views with lots of interactions.\nvar MAX_INTERACTION_ENTRIES = 10;\n// Arbitrary value to cap INP outliers\nexport var MAX_INP_VALUE = 1 * ONE_MINUTE;\n/**\n * Track the interaction to next paint (INP).\n * To avoid outliers, return the p98 worst interaction of the view.\n * Documentation: https://web.dev/inp/\n * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/main/src/onINP.ts\n */\nexport function trackInteractionToNextPaint(configuration, viewStart, viewLoadingType, lifeCycle) {\n  if (!isInteractionToNextPaintSupported()) {\n    return {\n      getInteractionToNextPaint: function () {\n        return undefined;\n      },\n      setViewEnd: noop,\n      stop: noop\n    };\n  }\n  var _a = trackViewInteractionCount(viewLoadingType),\n    getViewInteractionCount = _a.getViewInteractionCount,\n    stopViewInteractionCount = _a.stopViewInteractionCount;\n  var viewEnd = Infinity;\n  var longestInteractions = trackLongestInteractions(getViewInteractionCount);\n  var interactionToNextPaint = -1;\n  var interactionToNextPaintTargetSelector;\n  var stop = lifeCycle.subscribe(0 /* LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED */, function (entries) {\n    for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {\n      var entry = entries_1[_i];\n      if ((entry.entryType === RumPerformanceEntryType.EVENT || entry.entryType === RumPerformanceEntryType.FIRST_INPUT) && entry.interactionId &&\n      // Check the entry start time is inside the view bounds because some view interactions can be reported after the view end (if long duration).\n      entry.startTime >= viewStart && entry.startTime <= viewEnd) {\n        longestInteractions.process(entry);\n      }\n    }\n    var newInteraction = longestInteractions.estimateP98Interaction();\n    if (newInteraction && newInteraction.duration !== interactionToNextPaint) {\n      interactionToNextPaint = newInteraction.duration;\n      if (newInteraction.target && isElementNode(newInteraction.target)) {\n        interactionToNextPaintTargetSelector = getSelectorFromElement(newInteraction.target, configuration.actionNameAttribute);\n      } else {\n        interactionToNextPaintTargetSelector = undefined;\n      }\n    }\n  }).unsubscribe;\n  return {\n    getInteractionToNextPaint: function () {\n      // If no INP duration where captured because of the performanceObserver 40ms threshold\n      // but the view interaction count > 0 then report 0\n      if (interactionToNextPaint >= 0) {\n        return {\n          value: Math.min(interactionToNextPaint, MAX_INP_VALUE),\n          targetSelector: interactionToNextPaintTargetSelector\n        };\n      } else if (getViewInteractionCount()) {\n        return {\n          value: 0\n        };\n      }\n    },\n    setViewEnd: function (viewEndTime) {\n      viewEnd = viewEndTime;\n      stopViewInteractionCount();\n    },\n    stop: stop\n  };\n}\nfunction trackLongestInteractions(getViewInteractionCount) {\n  var longestInteractions = [];\n  function sortAndTrimLongestInteractions() {\n    longestInteractions.sort(function (a, b) {\n      return b.duration - a.duration;\n    }).splice(MAX_INTERACTION_ENTRIES);\n  }\n  return {\n    /**\n     * Process the performance entry:\n     * - if its duration is long enough, add the performance entry to the list of worst interactions\n     * - if an entry with the same interaction id exists and its duration is lower than the new one, then replace it in the list of worst interactions\n     */\n    process: function (entry) {\n      var interactionIndex = longestInteractions.findIndex(function (interaction) {\n        return entry.interactionId === interaction.interactionId;\n      });\n      var minLongestInteraction = longestInteractions[longestInteractions.length - 1];\n      if (interactionIndex !== -1) {\n        if (entry.duration > longestInteractions[interactionIndex].duration) {\n          longestInteractions[interactionIndex] = entry;\n          sortAndTrimLongestInteractions();\n        }\n      } else if (longestInteractions.length < MAX_INTERACTION_ENTRIES || entry.duration > minLongestInteraction.duration) {\n        longestInteractions.push(entry);\n        sortAndTrimLongestInteractions();\n      }\n    },\n    /**\n     * Compute the p98 longest interaction.\n     * For better performance the computation is based on 10 longest interactions and the interaction count of the current view.\n     */\n    estimateP98Interaction: function () {\n      var interactionIndex = Math.min(longestInteractions.length - 1, Math.floor(getViewInteractionCount() / 50));\n      return longestInteractions[interactionIndex];\n    }\n  };\n}\nexport function trackViewInteractionCount(viewLoadingType) {\n  initInteractionCountPolyfill();\n  var previousInteractionCount = viewLoadingType === \"initial_load\" /* ViewLoadingType.INITIAL_LOAD */ ? 0 : getInteractionCount();\n  var state = {\n    stopped: false\n  };\n  function computeViewInteractionCount() {\n    return getInteractionCount() - previousInteractionCount;\n  }\n  return {\n    getViewInteractionCount: function () {\n      if (state.stopped) {\n        return state.interactionCount;\n      }\n      return computeViewInteractionCount();\n    },\n    stopViewInteractionCount: function () {\n      state = {\n        stopped: true,\n        interactionCount: computeViewInteractionCount()\n      };\n    }\n  };\n}\nexport function isInteractionToNextPaintSupported() {\n  return supportPerformanceTimingEvent(RumPerformanceEntryType.EVENT) && window.PerformanceEventTiming && 'interactionId' in PerformanceEventTiming.prototype;\n}","map":{"version":3,"names":["noop","ONE_MINUTE","RumPerformanceEntryType","supportPerformanceTimingEvent","getSelectorFromElement","isElementNode","getInteractionCount","initInteractionCountPolyfill","MAX_INTERACTION_ENTRIES","MAX_INP_VALUE","trackInteractionToNextPaint","configuration","viewStart","viewLoadingType","lifeCycle","isInteractionToNextPaintSupported","getInteractionToNextPaint","undefined","setViewEnd","stop","_a","trackViewInteractionCount","getViewInteractionCount","stopViewInteractionCount","viewEnd","Infinity","longestInteractions","trackLongestInteractions","interactionToNextPaint","interactionToNextPaintTargetSelector","subscribe","entries","_i","entries_1","length","entry","entryType","EVENT","FIRST_INPUT","interactionId","startTime","process","newInteraction","estimateP98Interaction","duration","target","actionNameAttribute","unsubscribe","value","Math","min","targetSelector","viewEndTime","sortAndTrimLongestInteractions","sort","a","b","splice","interactionIndex","findIndex","interaction","minLongestInteraction","push","floor","previousInteractionCount","state","stopped","computeViewInteractionCount","interactionCount","window","PerformanceEventTiming","prototype"],"sources":["D:\\edu'\\Spritle\\spritle\\node_modules\\@datadog\\browser-rum-core\\src\\domain\\view\\viewMetrics\\trackInteractionToNextPaint.ts"],"sourcesContent":["import { noop, ONE_MINUTE } from '@datadog/browser-core'\nimport type { Duration, RelativeTime } from '@datadog/browser-core'\nimport { RumPerformanceEntryType, supportPerformanceTimingEvent } from '../../../browser/performanceCollection'\nimport type { RumFirstInputTiming, RumPerformanceEventTiming } from '../../../browser/performanceCollection'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport type { LifeCycle } from '../../lifeCycle'\nimport { ViewLoadingType } from '../../../rawRumEvent.types'\nimport { getSelectorFromElement } from '../../getSelectorFromElement'\nimport { isElementNode } from '../../../browser/htmlDomUtils'\nimport type { RumConfiguration } from '../../configuration'\nimport { getInteractionCount, initInteractionCountPolyfill } from './interactionCountPolyfill'\n\n// Arbitrary value to prevent unnecessary memory usage on views with lots of interactions.\nconst MAX_INTERACTION_ENTRIES = 10\n// Arbitrary value to cap INP outliers\nexport const MAX_INP_VALUE = (1 * ONE_MINUTE) as Duration\n\nexport interface InteractionToNextPaint {\n  value: Duration\n  targetSelector?: string\n}\n/**\n * Track the interaction to next paint (INP).\n * To avoid outliers, return the p98 worst interaction of the view.\n * Documentation: https://web.dev/inp/\n * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/main/src/onINP.ts\n */\nexport function trackInteractionToNextPaint(\n  configuration: RumConfiguration,\n  viewStart: RelativeTime,\n  viewLoadingType: ViewLoadingType,\n  lifeCycle: LifeCycle\n) {\n  if (!isInteractionToNextPaintSupported()) {\n    return {\n      getInteractionToNextPaint: () => undefined,\n      setViewEnd: noop,\n      stop: noop,\n    }\n  }\n\n  const { getViewInteractionCount, stopViewInteractionCount } = trackViewInteractionCount(viewLoadingType)\n\n  let viewEnd = Infinity as RelativeTime\n\n  const longestInteractions = trackLongestInteractions(getViewInteractionCount)\n  let interactionToNextPaint = -1 as Duration\n  let interactionToNextPaintTargetSelector: string | undefined\n\n  const { unsubscribe: stop } = lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED, (entries) => {\n    for (const entry of entries) {\n      if (\n        (entry.entryType === RumPerformanceEntryType.EVENT ||\n          entry.entryType === RumPerformanceEntryType.FIRST_INPUT) &&\n        entry.interactionId &&\n        // Check the entry start time is inside the view bounds because some view interactions can be reported after the view end (if long duration).\n        entry.startTime >= viewStart &&\n        entry.startTime <= viewEnd\n      ) {\n        longestInteractions.process(entry)\n      }\n    }\n\n    const newInteraction = longestInteractions.estimateP98Interaction()\n    if (newInteraction && newInteraction.duration !== interactionToNextPaint) {\n      interactionToNextPaint = newInteraction.duration\n\n      if (newInteraction.target && isElementNode(newInteraction.target)) {\n        interactionToNextPaintTargetSelector = getSelectorFromElement(\n          newInteraction.target,\n          configuration.actionNameAttribute\n        )\n      } else {\n        interactionToNextPaintTargetSelector = undefined\n      }\n    }\n  })\n\n  return {\n    getInteractionToNextPaint: (): InteractionToNextPaint | undefined => {\n      // If no INP duration where captured because of the performanceObserver 40ms threshold\n      // but the view interaction count > 0 then report 0\n      if (interactionToNextPaint >= 0) {\n        return {\n          value: Math.min(interactionToNextPaint, MAX_INP_VALUE) as Duration,\n          targetSelector: interactionToNextPaintTargetSelector,\n        }\n      } else if (getViewInteractionCount()) {\n        return {\n          value: 0 as Duration,\n        }\n      }\n    },\n    setViewEnd: (viewEndTime: RelativeTime) => {\n      viewEnd = viewEndTime\n      stopViewInteractionCount()\n    },\n    stop,\n  }\n}\n\nfunction trackLongestInteractions(getViewInteractionCount: () => number) {\n  const longestInteractions: Array<RumPerformanceEventTiming | RumFirstInputTiming> = []\n\n  function sortAndTrimLongestInteractions() {\n    longestInteractions.sort((a, b) => b.duration - a.duration).splice(MAX_INTERACTION_ENTRIES)\n  }\n\n  return {\n    /**\n     * Process the performance entry:\n     * - if its duration is long enough, add the performance entry to the list of worst interactions\n     * - if an entry with the same interaction id exists and its duration is lower than the new one, then replace it in the list of worst interactions\n     */\n    process(entry: RumPerformanceEventTiming | RumFirstInputTiming) {\n      const interactionIndex = longestInteractions.findIndex(\n        (interaction) => entry.interactionId === interaction.interactionId\n      )\n\n      const minLongestInteraction = longestInteractions[longestInteractions.length - 1]\n\n      if (interactionIndex !== -1) {\n        if (entry.duration > longestInteractions[interactionIndex].duration) {\n          longestInteractions[interactionIndex] = entry\n          sortAndTrimLongestInteractions()\n        }\n      } else if (\n        longestInteractions.length < MAX_INTERACTION_ENTRIES ||\n        entry.duration > minLongestInteraction.duration\n      ) {\n        longestInteractions.push(entry)\n        sortAndTrimLongestInteractions()\n      }\n    },\n    /**\n     * Compute the p98 longest interaction.\n     * For better performance the computation is based on 10 longest interactions and the interaction count of the current view.\n     */\n    estimateP98Interaction(): RumPerformanceEventTiming | RumFirstInputTiming | undefined {\n      const interactionIndex = Math.min(longestInteractions.length - 1, Math.floor(getViewInteractionCount() / 50))\n      return longestInteractions[interactionIndex]\n    },\n  }\n}\n\nexport function trackViewInteractionCount(viewLoadingType: ViewLoadingType) {\n  initInteractionCountPolyfill()\n  const previousInteractionCount = viewLoadingType === ViewLoadingType.INITIAL_LOAD ? 0 : getInteractionCount()\n  let state: { stopped: false } | { stopped: true; interactionCount: number } = { stopped: false }\n\n  function computeViewInteractionCount() {\n    return getInteractionCount() - previousInteractionCount\n  }\n\n  return {\n    getViewInteractionCount: () => {\n      if (state.stopped) {\n        return state.interactionCount\n      }\n\n      return computeViewInteractionCount()\n    },\n    stopViewInteractionCount: () => {\n      state = { stopped: true, interactionCount: computeViewInteractionCount() }\n    },\n  }\n}\n\nexport function isInteractionToNextPaintSupported() {\n  return (\n    supportPerformanceTimingEvent(RumPerformanceEntryType.EVENT) &&\n    window.PerformanceEventTiming &&\n    'interactionId' in PerformanceEventTiming.prototype\n  )\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}