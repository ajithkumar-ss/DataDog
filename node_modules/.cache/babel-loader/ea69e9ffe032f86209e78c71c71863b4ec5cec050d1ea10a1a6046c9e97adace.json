{"ast":null,"code":"import { computeBytesCount } from './utils/byteUtils';\nexport function createIdentityEncoder() {\n  var output = '';\n  var outputBytesCount = 0;\n  return {\n    isAsync: false,\n    get isEmpty() {\n      return !output;\n    },\n    write: function (data, callback) {\n      var additionalEncodedBytesCount = computeBytesCount(data);\n      outputBytesCount += additionalEncodedBytesCount;\n      output += data;\n      if (callback) {\n        callback(additionalEncodedBytesCount);\n      }\n    },\n    finish: function (callback) {\n      callback(this.finishSync());\n    },\n    finishSync: function () {\n      var result = {\n        output: output,\n        outputBytesCount: outputBytesCount,\n        rawBytesCount: outputBytesCount,\n        pendingData: ''\n      };\n      output = '';\n      outputBytesCount = 0;\n      return result;\n    },\n    estimateEncodedBytesCount: function (data) {\n      return data.length;\n    }\n  };\n}","map":{"version":3,"names":["computeBytesCount","createIdentityEncoder","output","outputBytesCount","isAsync","isEmpty","write","data","callback","additionalEncodedBytesCount","finish","finishSync","result","rawBytesCount","pendingData","estimateEncodedBytesCount","length"],"sources":["D:\\edu'\\Spritle\\Spritle\\node_modules\\@datadog\\browser-core\\src\\tools\\encoder.ts"],"sourcesContent":["import { computeBytesCount } from './utils/byteUtils'\n\nexport interface Encoder<Output extends string | Uint8Array = string | Uint8Array> {\n  /**\n   * Whether this encoder might call the provided callbacks asynchronously\n   */\n  isAsync: boolean\n\n  /**\n   * Whether some data has been written since the last finish() or finishSync() call\n   */\n  isEmpty: boolean\n\n  /**\n   * Write a string to be encoded.\n   *\n   * This operation can be synchronous or asynchronous depending on the encoder implementation.\n   *\n   * If specified, the callback will be invoked when the operation finishes, unless the operation is\n   * asynchronous and finish() or finishSync() is called in the meantime.\n   */\n  write(data: string, callback?: (additionalEncodedBytesCount: number) => void): void\n\n  /**\n   * Waits for pending data to be encoded and resets the encoder state.\n   *\n   * This operation can be synchronous or asynchronous depending on the encoder implementation.\n   *\n   * The callback will be invoked when the operation finishes, unless the operation is asynchronous\n   * and another call to finish() or finishSync() occurs in the meantime.\n   */\n  finish(callback: (result: EncoderResult<Output>) => void): void\n\n  /**\n   * Resets the encoder state then returns the encoded data and any potential pending data directly,\n   * discarding all pending write operations and finish() callbacks.\n   */\n  finishSync(): EncoderResult<Output> & { pendingData: string }\n\n  /**\n   * Returns a rough estimation of the bytes count if the data was encoded.\n   */\n  estimateEncodedBytesCount(data: string): number\n}\n\nexport interface EncoderResult<Output extends string | Uint8Array = string | Uint8Array> {\n  output: Output\n  outputBytesCount: number\n\n  /**\n   * An encoding type supported by HTTP Content-Encoding, if applicable.\n   * See https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding#directives\n   */\n  encoding?: 'deflate'\n\n  /**\n   * Total bytes count of the input strings encoded to UTF-8.\n   */\n  rawBytesCount: number\n}\n\nexport function createIdentityEncoder(): Encoder<string> {\n  let output = ''\n  let outputBytesCount = 0\n\n  return {\n    isAsync: false,\n\n    get isEmpty() {\n      return !output\n    },\n\n    write(data, callback) {\n      const additionalEncodedBytesCount = computeBytesCount(data)\n      outputBytesCount += additionalEncodedBytesCount\n      output += data\n      if (callback) {\n        callback(additionalEncodedBytesCount)\n      }\n    },\n\n    finish(callback) {\n      callback(this.finishSync())\n    },\n\n    finishSync() {\n      const result = {\n        output,\n        outputBytesCount,\n        rawBytesCount: outputBytesCount,\n        pendingData: '',\n      }\n      output = ''\n      outputBytesCount = 0\n      return result\n    },\n\n    estimateEncodedBytesCount(data) {\n      return data.length\n    },\n  }\n}\n"],"mappings":"AAAA,SAASA,iBAAiB,QAAQ,mBAAmB;AA6DrD,OAAM,SAAUC,qBAAqBA,CAAA;EACnC,IAAIC,MAAM,GAAG,EAAE;EACf,IAAIC,gBAAgB,GAAG,CAAC;EAExB,OAAO;IACLC,OAAO,EAAE,KAAK;IAEd,IAAIC,OAAOA,CAAA;MACT,OAAO,CAACH,MAAM;IAChB,CAAC;IAEDI,KAAK,WAAAA,CAACC,IAAI,EAAEC,QAAQ;MAClB,IAAMC,2BAA2B,GAAGT,iBAAiB,CAACO,IAAI,CAAC;MAC3DJ,gBAAgB,IAAIM,2BAA2B;MAC/CP,MAAM,IAAIK,IAAI;MACd,IAAIC,QAAQ,EAAE;QACZA,QAAQ,CAACC,2BAA2B,CAAC;MACvC;IACF,CAAC;IAEDC,MAAM,WAAAA,CAACF,QAAQ;MACbA,QAAQ,CAAC,IAAI,CAACG,UAAU,EAAE,CAAC;IAC7B,CAAC;IAEDA,UAAU,WAAAA,CAAA;MACR,IAAMC,MAAM,GAAG;QACbV,MAAM,EAAAA,MAAA;QACNC,gBAAgB,EAAAA,gBAAA;QAChBU,aAAa,EAAEV,gBAAgB;QAC/BW,WAAW,EAAE;OACd;MACDZ,MAAM,GAAG,EAAE;MACXC,gBAAgB,GAAG,CAAC;MACpB,OAAOS,MAAM;IACf,CAAC;IAEDG,yBAAyB,WAAAA,CAACR,IAAI;MAC5B,OAAOA,IAAI,CAACS,MAAM;IACpB;GACD;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}