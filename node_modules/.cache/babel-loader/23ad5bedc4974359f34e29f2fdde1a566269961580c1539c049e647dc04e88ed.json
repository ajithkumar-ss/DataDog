{"ast":null,"code":"import { noop, monitor } from '@datadog/browser-core';\n/**\n * Maximum duration to wait before processing mutations. If the browser is idle, mutations will be\n * processed more quickly. If the browser is busy executing small tasks (ex: rendering frames), the\n * mutations will wait MUTATION_PROCESS_MAX_DELAY milliseconds before being processed. If the\n * browser is busy executing a longer task, mutations will be processed after this task.\n */\nvar MUTATION_PROCESS_MAX_DELAY = 100;\nexport function createMutationBatch(processMutationBatch) {\n  var cancelScheduledFlush = noop;\n  var pendingMutations = [];\n  function flush() {\n    cancelScheduledFlush();\n    processMutationBatch(pendingMutations);\n    pendingMutations = [];\n  }\n  return {\n    addMutations: function (mutations) {\n      if (pendingMutations.length === 0) {\n        cancelScheduledFlush = requestIdleCallback(flush, {\n          timeout: MUTATION_PROCESS_MAX_DELAY\n        });\n      }\n      pendingMutations.push.apply(pendingMutations, mutations);\n    },\n    flush: flush,\n    stop: function () {\n      cancelScheduledFlush();\n    }\n  };\n}\n/**\n * Use 'requestIdleCallback' when available: it will throttle the mutation processing if the\n * browser is busy rendering frames (ex: when frames are below 60fps). When not available, the\n * fallback on 'requestAnimationFrame' will still ensure the mutations are processed after any\n * browser rendering process (Layout, Recalculate Style, etc.), so we can serialize DOM nodes efficiently.\n *\n * Note: check both 'requestIdleCallback' and 'cancelIdleCallback' existence because some polyfills only implement 'requestIdleCallback'.\n */\nfunction requestIdleCallback(callback, opts) {\n  if (window.requestIdleCallback && window.cancelIdleCallback) {\n    var id_1 = window.requestIdleCallback(monitor(callback), opts);\n    return function () {\n      return window.cancelIdleCallback(id_1);\n    };\n  }\n  var id = window.requestAnimationFrame(monitor(callback));\n  return function () {\n    return window.cancelAnimationFrame(id);\n  };\n}","map":{"version":3,"names":["noop","monitor","MUTATION_PROCESS_MAX_DELAY","createMutationBatch","processMutationBatch","cancelScheduledFlush","pendingMutations","flush","addMutations","mutations","length","requestIdleCallback","timeout","push","apply","stop","callback","opts","window","cancelIdleCallback","id_1","id","requestAnimationFrame","cancelAnimationFrame"],"sources":["D:\\edu'\\Spritle\\Spritle\\node_modules\\@datadog\\browser-rum\\src\\domain\\record\\mutationBatch.ts"],"sourcesContent":["import { noop, monitor } from '@datadog/browser-core'\nimport type { RumMutationRecord } from './trackers'\n\n/**\n * Maximum duration to wait before processing mutations. If the browser is idle, mutations will be\n * processed more quickly. If the browser is busy executing small tasks (ex: rendering frames), the\n * mutations will wait MUTATION_PROCESS_MAX_DELAY milliseconds before being processed. If the\n * browser is busy executing a longer task, mutations will be processed after this task.\n */\nconst MUTATION_PROCESS_MAX_DELAY = 100\n\nexport function createMutationBatch(processMutationBatch: (mutations: RumMutationRecord[]) => void) {\n  let cancelScheduledFlush = noop\n  let pendingMutations: RumMutationRecord[] = []\n\n  function flush() {\n    cancelScheduledFlush()\n    processMutationBatch(pendingMutations)\n    pendingMutations = []\n  }\n\n  return {\n    addMutations: (mutations: RumMutationRecord[]) => {\n      if (pendingMutations.length === 0) {\n        cancelScheduledFlush = requestIdleCallback(flush, { timeout: MUTATION_PROCESS_MAX_DELAY })\n      }\n      pendingMutations.push(...mutations)\n    },\n\n    flush,\n\n    stop: () => {\n      cancelScheduledFlush()\n    },\n  }\n}\n\n/**\n * Use 'requestIdleCallback' when available: it will throttle the mutation processing if the\n * browser is busy rendering frames (ex: when frames are below 60fps). When not available, the\n * fallback on 'requestAnimationFrame' will still ensure the mutations are processed after any\n * browser rendering process (Layout, Recalculate Style, etc.), so we can serialize DOM nodes efficiently.\n *\n * Note: check both 'requestIdleCallback' and 'cancelIdleCallback' existence because some polyfills only implement 'requestIdleCallback'.\n */\nfunction requestIdleCallback(callback: () => void, opts?: { timeout?: number }) {\n  if (window.requestIdleCallback && window.cancelIdleCallback) {\n    const id = window.requestIdleCallback(monitor(callback), opts)\n    return () => window.cancelIdleCallback(id)\n  }\n  const id = window.requestAnimationFrame(monitor(callback))\n  return () => window.cancelAnimationFrame(id)\n}\n"],"mappings":"AAAA,SAASA,IAAI,EAAEC,OAAO,QAAQ,uBAAuB;AAGrD;;;;;;AAMA,IAAMC,0BAA0B,GAAG,GAAG;AAEtC,OAAM,SAAUC,mBAAmBA,CAACC,oBAA8D;EAChG,IAAIC,oBAAoB,GAAGL,IAAI;EAC/B,IAAIM,gBAAgB,GAAwB,EAAE;EAE9C,SAASC,KAAKA,CAAA;IACZF,oBAAoB,EAAE;IACtBD,oBAAoB,CAACE,gBAAgB,CAAC;IACtCA,gBAAgB,GAAG,EAAE;EACvB;EAEA,OAAO;IACLE,YAAY,EAAE,SAAAA,CAACC,SAA8B;MAC3C,IAAIH,gBAAgB,CAACI,MAAM,KAAK,CAAC,EAAE;QACjCL,oBAAoB,GAAGM,mBAAmB,CAACJ,KAAK,EAAE;UAAEK,OAAO,EAAEV;QAA0B,CAAE,CAAC;MAC5F;MACAI,gBAAgB,CAACO,IAAI,CAAAC,KAAA,CAArBR,gBAAgB,EAASG,SAAS;IACpC,CAAC;IAEDF,KAAK,EAAAA,KAAA;IAELQ,IAAI,EAAE,SAAAA,CAAA;MACJV,oBAAoB,EAAE;IACxB;GACD;AACH;AAEA;;;;;;;;AAQA,SAASM,mBAAmBA,CAACK,QAAoB,EAAEC,IAA2B;EAC5E,IAAIC,MAAM,CAACP,mBAAmB,IAAIO,MAAM,CAACC,kBAAkB,EAAE;IAC3D,IAAMC,IAAE,GAAGF,MAAM,CAACP,mBAAmB,CAACV,OAAO,CAACe,QAAQ,CAAC,EAAEC,IAAI,CAAC;IAC9D,OAAO;MAAM,OAAAC,MAAM,CAACC,kBAAkB,CAACC,IAAE,CAAC;IAA7B,CAA6B;EAC5C;EACA,IAAMC,EAAE,GAAGH,MAAM,CAACI,qBAAqB,CAACrB,OAAO,CAACe,QAAQ,CAAC,CAAC;EAC1D,OAAO;IAAM,OAAAE,MAAM,CAACK,oBAAoB,CAACF,EAAE,CAAC;EAA/B,CAA+B;AAC9C","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}