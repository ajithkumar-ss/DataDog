{"ast":null,"code":"import { setInterval, clearInterval } from './timer';\nimport { removeItem } from './utils/arrayUtils';\nimport { addDuration, relativeNow, ONE_MINUTE } from './utils/timeUtils';\nvar END_OF_TIMES = Infinity;\nexport var CLEAR_OLD_VALUES_INTERVAL = ONE_MINUTE;\n/**\n * Store and keep track of values spans. This whole class assumes that values are added in\n * chronological order (i.e. all entries have an increasing start time).\n */\nvar ValueHistory = /** @class */function () {\n  function ValueHistory(expireDelay, maxEntries) {\n    var _this = this;\n    this.expireDelay = expireDelay;\n    this.maxEntries = maxEntries;\n    this.entries = [];\n    this.clearOldValuesInterval = setInterval(function () {\n      return _this.clearOldValues();\n    }, CLEAR_OLD_VALUES_INTERVAL);\n  }\n  /**\n   * Add a value to the history associated with a start time. Returns a reference to this newly\n   * added entry that can be removed or closed.\n   */\n  ValueHistory.prototype.add = function (value, startTime) {\n    var _this = this;\n    var entry = {\n      value: value,\n      startTime: startTime,\n      endTime: END_OF_TIMES,\n      remove: function () {\n        removeItem(_this.entries, entry);\n      },\n      close: function (endTime) {\n        entry.endTime = endTime;\n      }\n    };\n    if (this.maxEntries && this.entries.length >= this.maxEntries) {\n      this.entries.pop();\n    }\n    this.entries.unshift(entry);\n    return entry;\n  };\n  /**\n   * Return the latest value that was active during `startTime`, or the currently active value\n   * if no `startTime` is provided. This method assumes that entries are not overlapping.\n   */\n  ValueHistory.prototype.find = function (startTime) {\n    if (startTime === void 0) {\n      startTime = END_OF_TIMES;\n    }\n    for (var _i = 0, _a = this.entries; _i < _a.length; _i++) {\n      var entry = _a[_i];\n      if (entry.startTime <= startTime) {\n        if (startTime <= entry.endTime) {\n          return entry.value;\n        }\n        break;\n      }\n    }\n  };\n  /**\n   * Helper function to close the currently active value, if any. This method assumes that entries\n   * are not overlapping.\n   */\n  ValueHistory.prototype.closeActive = function (endTime) {\n    var latestEntry = this.entries[0];\n    if (latestEntry && latestEntry.endTime === END_OF_TIMES) {\n      latestEntry.close(endTime);\n    }\n  };\n  /**\n   * Return all values with an active period overlapping with the duration,\n   * or all values that were active during `startTime` if no duration is provided,\n   * or all currently active values if no `startTime` is provided.\n   */\n  ValueHistory.prototype.findAll = function (startTime, duration) {\n    if (startTime === void 0) {\n      startTime = END_OF_TIMES;\n    }\n    if (duration === void 0) {\n      duration = 0;\n    }\n    var endTime = addDuration(startTime, duration);\n    return this.entries.filter(function (entry) {\n      return entry.startTime <= endTime && startTime <= entry.endTime;\n    }).map(function (entry) {\n      return entry.value;\n    });\n  };\n  /**\n   * Remove all entries from this collection.\n   */\n  ValueHistory.prototype.reset = function () {\n    this.entries = [];\n  };\n  /**\n   * Stop internal garbage collection of past entries.\n   */\n  ValueHistory.prototype.stop = function () {\n    clearInterval(this.clearOldValuesInterval);\n  };\n  ValueHistory.prototype.clearOldValues = function () {\n    var oldTimeThreshold = relativeNow() - this.expireDelay;\n    while (this.entries.length > 0 && this.entries[this.entries.length - 1].endTime < oldTimeThreshold) {\n      this.entries.pop();\n    }\n  };\n  return ValueHistory;\n}();\nexport { ValueHistory };","map":{"version":3,"names":["setInterval","clearInterval","removeItem","addDuration","relativeNow","ONE_MINUTE","END_OF_TIMES","Infinity","CLEAR_OLD_VALUES_INTERVAL","ValueHistory","expireDelay","maxEntries","_this","entries","clearOldValuesInterval","clearOldValues","prototype","add","value","startTime","entry","endTime","remove","close","length","pop","unshift","find","_i","_a","closeActive","latestEntry","findAll","duration","filter","map","reset","stop","oldTimeThreshold"],"sources":["D:\\edu'\\Spritle\\Spritle\\node_modules\\@datadog\\browser-core\\src\\tools\\valueHistory.ts"],"sourcesContent":["import { setInterval, clearInterval } from './timer'\nimport type { TimeoutId } from './timer'\nimport { removeItem } from './utils/arrayUtils'\nimport type { Duration, RelativeTime } from './utils/timeUtils'\nimport { addDuration, relativeNow, ONE_MINUTE } from './utils/timeUtils'\n\nconst END_OF_TIMES = Infinity as RelativeTime\n\nexport interface ValueHistoryEntry<T> {\n  startTime: RelativeTime\n  endTime: RelativeTime\n  value: T\n  remove(): void\n  close(endTime: RelativeTime): void\n}\n\nexport const CLEAR_OLD_VALUES_INTERVAL = ONE_MINUTE\n\n/**\n * Store and keep track of values spans. This whole class assumes that values are added in\n * chronological order (i.e. all entries have an increasing start time).\n */\nexport class ValueHistory<Value> {\n  private entries: Array<ValueHistoryEntry<Value>> = []\n  private clearOldValuesInterval: TimeoutId\n\n  constructor(\n    private expireDelay: number,\n    private maxEntries?: number\n  ) {\n    this.clearOldValuesInterval = setInterval(() => this.clearOldValues(), CLEAR_OLD_VALUES_INTERVAL)\n  }\n\n  /**\n   * Add a value to the history associated with a start time. Returns a reference to this newly\n   * added entry that can be removed or closed.\n   */\n  add(value: Value, startTime: RelativeTime): ValueHistoryEntry<Value> {\n    const entry: ValueHistoryEntry<Value> = {\n      value,\n      startTime,\n      endTime: END_OF_TIMES,\n      remove: () => {\n        removeItem(this.entries, entry)\n      },\n      close: (endTime: RelativeTime) => {\n        entry.endTime = endTime\n      },\n    }\n\n    if (this.maxEntries && this.entries.length >= this.maxEntries) {\n      this.entries.pop()\n    }\n\n    this.entries.unshift(entry)\n\n    return entry\n  }\n\n  /**\n   * Return the latest value that was active during `startTime`, or the currently active value\n   * if no `startTime` is provided. This method assumes that entries are not overlapping.\n   */\n  find(startTime: RelativeTime = END_OF_TIMES): Value | undefined {\n    for (const entry of this.entries) {\n      if (entry.startTime <= startTime) {\n        if (startTime <= entry.endTime) {\n          return entry.value\n        }\n        break\n      }\n    }\n  }\n\n  /**\n   * Helper function to close the currently active value, if any. This method assumes that entries\n   * are not overlapping.\n   */\n  closeActive(endTime: RelativeTime) {\n    const latestEntry = this.entries[0]\n    if (latestEntry && latestEntry.endTime === END_OF_TIMES) {\n      latestEntry.close(endTime)\n    }\n  }\n\n  /**\n   * Return all values with an active period overlapping with the duration,\n   * or all values that were active during `startTime` if no duration is provided,\n   * or all currently active values if no `startTime` is provided.\n   */\n  findAll(startTime: RelativeTime = END_OF_TIMES, duration = 0 as Duration): Value[] {\n    const endTime = addDuration(startTime, duration)\n    return this.entries\n      .filter((entry) => entry.startTime <= endTime && startTime <= entry.endTime)\n      .map((entry) => entry.value)\n  }\n\n  /**\n   * Remove all entries from this collection.\n   */\n  reset() {\n    this.entries = []\n  }\n\n  /**\n   * Stop internal garbage collection of past entries.\n   */\n  stop() {\n    clearInterval(this.clearOldValuesInterval)\n  }\n\n  private clearOldValues() {\n    const oldTimeThreshold = relativeNow() - this.expireDelay\n    while (this.entries.length > 0 && this.entries[this.entries.length - 1].endTime < oldTimeThreshold) {\n      this.entries.pop()\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}