{"ast":null,"code":"import { instrumentMethod, matchList, monitor, Observable, timeStampNow, setTimeout, clearTimeout } from '@datadog/browser-core';\nimport { RumPerformanceEntryType } from '../browser/performanceCollection';\n// Delay to wait for a page activity to validate the tracking process\nexport var PAGE_ACTIVITY_VALIDATION_DELAY = 100;\n// Delay to wait after a page activity to end the tracking process\nexport var PAGE_ACTIVITY_END_DELAY = 100;\n/**\n * Wait for the page activity end\n *\n * Detection lifecycle:\n * ```\n *                        Wait page activity end\n *              .-------------------'--------------------.\n *              v                                        v\n *     [Wait for a page activity ]          [Wait for a maximum duration]\n *     [timeout: VALIDATION_DELAY]          [  timeout: maxDuration     ]\n *          /                  \\                           |\n *         v                    v                          |\n *  [No page activity]   [Page activity]                   |\n *         |                   |,----------------------.   |\n *         v                   v                       |   |\n *     (Discard)     [Wait for a page activity]        |   |\n *                   [   timeout: END_DELAY   ]        |   |\n *                       /                \\            |   |\n *                      v                  v           |   |\n *             [No page activity]    [Page activity]   |   |\n *                      |                 |            |   |\n *                      |                 '------------'   |\n *                      '-----------. ,--------------------'\n *                                   v\n *                                 (End)\n * ```\n *\n * Note: by assuming that maxDuration is greater than VALIDATION_DELAY, we are sure that if the\n * process is still alive after maxDuration, it has been validated.\n */\nexport function waitPageActivityEnd(lifeCycle, domMutationObservable, configuration, pageActivityEndCallback, maxDuration) {\n  var pageActivityObservable = createPageActivityObservable(lifeCycle, domMutationObservable, configuration);\n  return doWaitPageActivityEnd(pageActivityObservable, pageActivityEndCallback, maxDuration);\n}\nexport function doWaitPageActivityEnd(pageActivityObservable, pageActivityEndCallback, maxDuration) {\n  var pageActivityEndTimeoutId;\n  var hasCompleted = false;\n  var validationTimeoutId = setTimeout(monitor(function () {\n    return complete({\n      hadActivity: false\n    });\n  }), PAGE_ACTIVITY_VALIDATION_DELAY);\n  var maxDurationTimeoutId = maxDuration !== undefined ? setTimeout(monitor(function () {\n    return complete({\n      hadActivity: true,\n      end: timeStampNow()\n    });\n  }), maxDuration) : undefined;\n  var pageActivitySubscription = pageActivityObservable.subscribe(function (_a) {\n    var isBusy = _a.isBusy;\n    clearTimeout(validationTimeoutId);\n    clearTimeout(pageActivityEndTimeoutId);\n    var lastChangeTime = timeStampNow();\n    if (!isBusy) {\n      pageActivityEndTimeoutId = setTimeout(monitor(function () {\n        return complete({\n          hadActivity: true,\n          end: lastChangeTime\n        });\n      }), PAGE_ACTIVITY_END_DELAY);\n    }\n  });\n  var stop = function () {\n    hasCompleted = true;\n    clearTimeout(validationTimeoutId);\n    clearTimeout(pageActivityEndTimeoutId);\n    clearTimeout(maxDurationTimeoutId);\n    pageActivitySubscription.unsubscribe();\n  };\n  function complete(event) {\n    if (hasCompleted) {\n      return;\n    }\n    stop();\n    pageActivityEndCallback(event);\n  }\n  return {\n    stop: stop\n  };\n}\nexport function createPageActivityObservable(lifeCycle, domMutationObservable, configuration) {\n  return new Observable(function (observable) {\n    var subscriptions = [];\n    var firstRequestIndex;\n    var pendingRequestsCount = 0;\n    subscriptions.push(domMutationObservable.subscribe(notifyPageActivity), lifeCycle.subscribe(0 /* LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED */, function (entries) {\n      if (entries.some(function (entry) {\n        return entry.entryType === RumPerformanceEntryType.RESOURCE && !isExcludedUrl(configuration, entry.name);\n      })) {\n        notifyPageActivity();\n      }\n    }), lifeCycle.subscribe(7 /* LifeCycleEventType.REQUEST_STARTED */, function (startEvent) {\n      if (isExcludedUrl(configuration, startEvent.url)) {\n        return;\n      }\n      if (firstRequestIndex === undefined) {\n        firstRequestIndex = startEvent.requestIndex;\n      }\n      pendingRequestsCount += 1;\n      notifyPageActivity();\n    }), lifeCycle.subscribe(8 /* LifeCycleEventType.REQUEST_COMPLETED */, function (request) {\n      if (isExcludedUrl(configuration, request.url) || firstRequestIndex === undefined ||\n      // If the request started before the tracking start, ignore it\n      request.requestIndex < firstRequestIndex) {\n        return;\n      }\n      pendingRequestsCount -= 1;\n      notifyPageActivity();\n    }));\n    var stopTrackingWindowOpen = trackWindowOpen(notifyPageActivity).stop;\n    return function () {\n      stopTrackingWindowOpen();\n      subscriptions.forEach(function (s) {\n        return s.unsubscribe();\n      });\n    };\n    function notifyPageActivity() {\n      observable.notify({\n        isBusy: pendingRequestsCount > 0\n      });\n    }\n  });\n}\nfunction isExcludedUrl(configuration, requestUrl) {\n  return matchList(configuration.excludedActivityUrls, requestUrl);\n}\nfunction trackWindowOpen(callback) {\n  return instrumentMethod(window, 'open', callback);\n}","map":{"version":3,"names":["instrumentMethod","matchList","monitor","Observable","timeStampNow","setTimeout","clearTimeout","RumPerformanceEntryType","PAGE_ACTIVITY_VALIDATION_DELAY","PAGE_ACTIVITY_END_DELAY","waitPageActivityEnd","lifeCycle","domMutationObservable","configuration","pageActivityEndCallback","maxDuration","pageActivityObservable","createPageActivityObservable","doWaitPageActivityEnd","pageActivityEndTimeoutId","hasCompleted","validationTimeoutId","complete","hadActivity","maxDurationTimeoutId","undefined","end","pageActivitySubscription","subscribe","_a","isBusy","lastChangeTime","stop","unsubscribe","event","observable","subscriptions","firstRequestIndex","pendingRequestsCount","push","notifyPageActivity","entries","some","entry","entryType","RESOURCE","isExcludedUrl","name","startEvent","url","requestIndex","request","stopTrackingWindowOpen","trackWindowOpen","forEach","s","notify","requestUrl","excludedActivityUrls","callback","window"],"sources":["D:\\edu'\\Spritle\\Spritle\\node_modules\\@datadog\\browser-rum-core\\src\\domain\\waitPageActivityEnd.ts"],"sourcesContent":["import type { Subscription, TimeoutId, TimeStamp } from '@datadog/browser-core'\nimport {\n  instrumentMethod,\n  matchList,\n  monitor,\n  Observable,\n  timeStampNow,\n  setTimeout,\n  clearTimeout,\n} from '@datadog/browser-core'\nimport { RumPerformanceEntryType } from '../browser/performanceCollection'\nimport type { RumConfiguration } from './configuration'\nimport type { LifeCycle } from './lifeCycle'\nimport { LifeCycleEventType } from './lifeCycle'\n\n// Delay to wait for a page activity to validate the tracking process\nexport const PAGE_ACTIVITY_VALIDATION_DELAY = 100\n// Delay to wait after a page activity to end the tracking process\nexport const PAGE_ACTIVITY_END_DELAY = 100\n\nexport interface PageActivityEvent {\n  isBusy: boolean\n}\n\nexport type PageActivityEndEvent = { hadActivity: true; end: TimeStamp } | { hadActivity: false }\n\n/**\n * Wait for the page activity end\n *\n * Detection lifecycle:\n * ```\n *                        Wait page activity end\n *              .-------------------'--------------------.\n *              v                                        v\n *     [Wait for a page activity ]          [Wait for a maximum duration]\n *     [timeout: VALIDATION_DELAY]          [  timeout: maxDuration     ]\n *          /                  \\                           |\n *         v                    v                          |\n *  [No page activity]   [Page activity]                   |\n *         |                   |,----------------------.   |\n *         v                   v                       |   |\n *     (Discard)     [Wait for a page activity]        |   |\n *                   [   timeout: END_DELAY   ]        |   |\n *                       /                \\            |   |\n *                      v                  v           |   |\n *             [No page activity]    [Page activity]   |   |\n *                      |                 |            |   |\n *                      |                 '------------'   |\n *                      '-----------. ,--------------------'\n *                                   v\n *                                 (End)\n * ```\n *\n * Note: by assuming that maxDuration is greater than VALIDATION_DELAY, we are sure that if the\n * process is still alive after maxDuration, it has been validated.\n */\nexport function waitPageActivityEnd(\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  configuration: RumConfiguration,\n  pageActivityEndCallback: (event: PageActivityEndEvent) => void,\n  maxDuration?: number\n) {\n  const pageActivityObservable = createPageActivityObservable(lifeCycle, domMutationObservable, configuration)\n  return doWaitPageActivityEnd(pageActivityObservable, pageActivityEndCallback, maxDuration)\n}\n\nexport function doWaitPageActivityEnd(\n  pageActivityObservable: Observable<PageActivityEvent>,\n  pageActivityEndCallback: (event: PageActivityEndEvent) => void,\n  maxDuration?: number\n) {\n  let pageActivityEndTimeoutId: TimeoutId\n  let hasCompleted = false\n\n  const validationTimeoutId = setTimeout(\n    monitor(() => complete({ hadActivity: false })),\n    PAGE_ACTIVITY_VALIDATION_DELAY\n  )\n  const maxDurationTimeoutId =\n    maxDuration !== undefined\n      ? setTimeout(\n          monitor(() => complete({ hadActivity: true, end: timeStampNow() })),\n          maxDuration\n        )\n      : undefined\n\n  const pageActivitySubscription = pageActivityObservable.subscribe(({ isBusy }) => {\n    clearTimeout(validationTimeoutId)\n    clearTimeout(pageActivityEndTimeoutId)\n    const lastChangeTime = timeStampNow()\n    if (!isBusy) {\n      pageActivityEndTimeoutId = setTimeout(\n        monitor(() => complete({ hadActivity: true, end: lastChangeTime })),\n        PAGE_ACTIVITY_END_DELAY\n      )\n    }\n  })\n\n  const stop = () => {\n    hasCompleted = true\n    clearTimeout(validationTimeoutId)\n    clearTimeout(pageActivityEndTimeoutId)\n    clearTimeout(maxDurationTimeoutId)\n    pageActivitySubscription.unsubscribe()\n  }\n\n  function complete(event: PageActivityEndEvent) {\n    if (hasCompleted) {\n      return\n    }\n    stop()\n    pageActivityEndCallback(event)\n  }\n  return { stop }\n}\n\nexport function createPageActivityObservable(\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  configuration: RumConfiguration\n): Observable<PageActivityEvent> {\n  return new Observable<PageActivityEvent>((observable) => {\n    const subscriptions: Subscription[] = []\n    let firstRequestIndex: undefined | number\n    let pendingRequestsCount = 0\n\n    subscriptions.push(\n      domMutationObservable.subscribe(notifyPageActivity),\n      lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED, (entries) => {\n        if (\n          entries.some(\n            (entry) => entry.entryType === RumPerformanceEntryType.RESOURCE && !isExcludedUrl(configuration, entry.name)\n          )\n        ) {\n          notifyPageActivity()\n        }\n      }),\n      lifeCycle.subscribe(LifeCycleEventType.REQUEST_STARTED, (startEvent) => {\n        if (isExcludedUrl(configuration, startEvent.url)) {\n          return\n        }\n        if (firstRequestIndex === undefined) {\n          firstRequestIndex = startEvent.requestIndex\n        }\n        pendingRequestsCount += 1\n        notifyPageActivity()\n      }),\n      lifeCycle.subscribe(LifeCycleEventType.REQUEST_COMPLETED, (request) => {\n        if (\n          isExcludedUrl(configuration, request.url) ||\n          firstRequestIndex === undefined ||\n          // If the request started before the tracking start, ignore it\n          request.requestIndex < firstRequestIndex\n        ) {\n          return\n        }\n        pendingRequestsCount -= 1\n        notifyPageActivity()\n      })\n    )\n\n    const { stop: stopTrackingWindowOpen } = trackWindowOpen(notifyPageActivity)\n\n    return () => {\n      stopTrackingWindowOpen()\n      subscriptions.forEach((s) => s.unsubscribe())\n    }\n\n    function notifyPageActivity() {\n      observable.notify({ isBusy: pendingRequestsCount > 0 })\n    }\n  })\n}\n\nfunction isExcludedUrl(configuration: RumConfiguration, requestUrl: string): boolean {\n  return matchList(configuration.excludedActivityUrls, requestUrl)\n}\n\nfunction trackWindowOpen(callback: () => void) {\n  return instrumentMethod(window, 'open', callback)\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}