{"ast":null,"code":"import { canUseEventBridge, noop, runOnReadyState, PageExitReason, bridgeSupports } from '@datadog/browser-core';\nimport { getReplayStats as getReplayStatsImpl } from '../domain/replayStats';\nimport { getSessionReplayLink } from '../domain/getSessionReplayLink';\nimport { createDeflateEncoder, startDeflateWorker, getDeflateWorkerStatus } from '../domain/deflate';\nimport { isBrowserSupported } from './isBrowserSupported';\nexport function makeRecorderApi(startRecordingImpl, createDeflateWorkerImpl) {\n  if (canUseEventBridge() && !bridgeSupports(\"records\" /* BridgeCapability.RECORDS */) || !isBrowserSupported()) {\n    return {\n      start: noop,\n      stop: noop,\n      getReplayStats: function () {\n        return undefined;\n      },\n      onRumStart: noop,\n      isRecording: function () {\n        return false;\n      },\n      getSessionReplayLink: function () {\n        return undefined;\n      }\n    };\n  }\n  var state = {\n    status: 1 /* RecorderStatus.IntentToStart */\n  };\n  var startStrategy = function () {\n    state = {\n      status: 1 /* RecorderStatus.IntentToStart */\n    };\n  };\n  var stopStrategy = function () {\n    state = {\n      status: 0 /* RecorderStatus.Stopped */\n    };\n  };\n  var getSessionReplayLinkStrategy = noop;\n  return {\n    start: function () {\n      return startStrategy();\n    },\n    stop: function () {\n      return stopStrategy();\n    },\n    getSessionReplayLink: function () {\n      return getSessionReplayLinkStrategy();\n    },\n    onRumStart: function (lifeCycle, configuration, sessionManager, viewContexts, worker) {\n      if (configuration.startSessionReplayRecordingManually) {\n        state = {\n          status: 0 /* RecorderStatus.Stopped */\n        };\n      }\n      lifeCycle.subscribe(9 /* LifeCycleEventType.SESSION_EXPIRED */, function () {\n        if (state.status === 2 /* RecorderStatus.Starting */ || state.status === 3 /* RecorderStatus.Started */) {\n          stopStrategy();\n          state = {\n            status: 1 /* RecorderStatus.IntentToStart */\n          };\n        }\n      });\n      // Stop the recorder on page unload to avoid sending records after the page is ended.\n      lifeCycle.subscribe(11 /* LifeCycleEventType.PAGE_EXITED */, function (pageExitEvent) {\n        if (pageExitEvent.reason === PageExitReason.UNLOADING || pageExitEvent.reason === PageExitReason.PAGEHIDE) {\n          stopStrategy();\n        }\n      });\n      lifeCycle.subscribe(10 /* LifeCycleEventType.SESSION_RENEWED */, function () {\n        if (state.status === 1 /* RecorderStatus.IntentToStart */) {\n          startStrategy();\n        }\n      });\n      var cachedDeflateEncoder;\n      function getOrCreateDeflateEncoder() {\n        if (!cachedDeflateEncoder) {\n          if (!worker) {\n            worker = startDeflateWorker(configuration, 'Datadog Session Replay', function () {\n              stopStrategy();\n            }, createDeflateWorkerImpl);\n          }\n          if (worker) {\n            cachedDeflateEncoder = createDeflateEncoder(configuration, worker, 1 /* DeflateEncoderStreamId.REPLAY */);\n          }\n        }\n        return cachedDeflateEncoder;\n      }\n      startStrategy = function () {\n        var session = sessionManager.findTrackedSession();\n        if (!session || !session.sessionReplayAllowed) {\n          state = {\n            status: 1 /* RecorderStatus.IntentToStart */\n          };\n          return;\n        }\n        if (state.status === 2 /* RecorderStatus.Starting */ || state.status === 3 /* RecorderStatus.Started */) {\n          return;\n        }\n        state = {\n          status: 2 /* RecorderStatus.Starting */\n        };\n        runOnReadyState(configuration, 'interactive', function () {\n          if (state.status !== 2 /* RecorderStatus.Starting */) {\n            return;\n          }\n          var deflateEncoder = getOrCreateDeflateEncoder();\n          if (!deflateEncoder) {\n            state = {\n              status: 0 /* RecorderStatus.Stopped */\n            };\n            return;\n          }\n          var stopRecording = startRecordingImpl(lifeCycle, configuration, sessionManager, viewContexts, deflateEncoder).stop;\n          state = {\n            status: 3 /* RecorderStatus.Started */,\n            stopRecording: stopRecording\n          };\n        });\n      };\n      stopStrategy = function () {\n        if (state.status === 0 /* RecorderStatus.Stopped */) {\n          return;\n        }\n        if (state.status === 3 /* RecorderStatus.Started */) {\n          state.stopRecording();\n        }\n        state = {\n          status: 0 /* RecorderStatus.Stopped */\n        };\n      };\n      getSessionReplayLinkStrategy = function () {\n        return getSessionReplayLink(configuration, sessionManager, viewContexts, state.status !== 0 /* RecorderStatus.Stopped */);\n      };\n      if (state.status === 1 /* RecorderStatus.IntentToStart */) {\n        startStrategy();\n      }\n    },\n    isRecording: function () {\n      // The worker is started optimistically, meaning we could have started to record but its\n      // initialization fails a bit later. This could happen when:\n      // * the worker URL (blob or plain URL) is blocked by CSP in Firefox only (Chromium and Safari\n      // throw an exception when instantiating the worker, and IE doesn't care about CSP)\n      // * the browser fails to load the worker in case the workerUrl is used\n      // * an unexpected error occurs in the Worker before initialization, ex:\n      //   * a runtime exception collected by monitor()\n      //   * a syntax error notified by the browser via an error event\n      // * the worker is unresponsive for some reason and timeouts\n      //\n      // It is not expected to happen often. Nonetheless, the \"replayable\" status on RUM events is\n      // an important part of the Datadog App:\n      // * If we have a false positive (we set has_replay: true even if no replay data is present),\n      // we might display broken links to the Session Replay player.\n      // * If we have a false negative (we don't set has_replay: true even if replay data is\n      // available), it is less noticeable because no link will be displayed.\n      //\n      // Thus, it is better to have false negative, so let's make sure the worker is correctly\n      // initialized before advertizing that we are recording.\n      //\n      // In the future, when the compression worker will also be used for RUM data, this will be\n      // less important since no RUM event will be sent when the worker fails to initialize.\n      return getDeflateWorkerStatus() === 3 /* DeflateWorkerStatus.Initialized */ && state.status === 3 /* RecorderStatus.Started */;\n    },\n    getReplayStats: function (viewId) {\n      return getDeflateWorkerStatus() === 3 /* DeflateWorkerStatus.Initialized */ ? getReplayStatsImpl(viewId) : undefined;\n    }\n  };\n}","map":{"version":3,"names":["canUseEventBridge","noop","runOnReadyState","PageExitReason","bridgeSupports","getReplayStats","getReplayStatsImpl","getSessionReplayLink","createDeflateEncoder","startDeflateWorker","getDeflateWorkerStatus","isBrowserSupported","makeRecorderApi","startRecordingImpl","createDeflateWorkerImpl","start","stop","undefined","onRumStart","isRecording","state","status","startStrategy","stopStrategy","getSessionReplayLinkStrategy","lifeCycle","configuration","sessionManager","viewContexts","worker","startSessionReplayRecordingManually","subscribe","pageExitEvent","reason","UNLOADING","PAGEHIDE","cachedDeflateEncoder","getOrCreateDeflateEncoder","session","findTrackedSession","sessionReplayAllowed","deflateEncoder","stopRecording","viewId"],"sources":["D:\\edu'\\Spritle\\Spritle\\node_modules\\@datadog\\browser-rum\\src\\boot\\recorderApi.ts"],"sourcesContent":["import type { DeflateEncoder } from '@datadog/browser-core'\nimport {\n  DeflateEncoderStreamId,\n  canUseEventBridge,\n  noop,\n  runOnReadyState,\n  PageExitReason,\n  BridgeCapability,\n  bridgeSupports,\n} from '@datadog/browser-core'\nimport type {\n  LifeCycle,\n  ViewContexts,\n  RumSessionManager,\n  RecorderApi,\n  RumConfiguration,\n} from '@datadog/browser-rum-core'\nimport { LifeCycleEventType } from '@datadog/browser-rum-core'\nimport { getReplayStats as getReplayStatsImpl } from '../domain/replayStats'\nimport { getSessionReplayLink } from '../domain/getSessionReplayLink'\nimport type { CreateDeflateWorker } from '../domain/deflate'\nimport {\n  createDeflateEncoder,\n  startDeflateWorker,\n  DeflateWorkerStatus,\n  getDeflateWorkerStatus,\n} from '../domain/deflate'\n\nimport type { startRecording } from './startRecording'\nimport { isBrowserSupported } from './isBrowserSupported'\n\nexport type StartRecording = typeof startRecording\n\nconst enum RecorderStatus {\n  // The recorder is stopped.\n  Stopped,\n  // The user started the recording while it wasn't possible yet. The recorder should start as soon\n  // as possible.\n  IntentToStart,\n  // The recorder is starting. It does not record anything yet.\n  Starting,\n  // The recorder is started, it records the session.\n  Started,\n}\ntype RecorderState =\n  | {\n      status: RecorderStatus.Stopped\n    }\n  | {\n      status: RecorderStatus.IntentToStart\n    }\n  | {\n      status: RecorderStatus.Starting\n    }\n  | {\n      status: RecorderStatus.Started\n      stopRecording: () => void\n    }\n\nexport function makeRecorderApi(\n  startRecordingImpl: StartRecording,\n  createDeflateWorkerImpl?: CreateDeflateWorker\n): RecorderApi {\n  if ((canUseEventBridge() && !bridgeSupports(BridgeCapability.RECORDS)) || !isBrowserSupported()) {\n    return {\n      start: noop,\n      stop: noop,\n      getReplayStats: () => undefined,\n      onRumStart: noop,\n      isRecording: () => false,\n      getSessionReplayLink: () => undefined,\n    }\n  }\n\n  let state: RecorderState = {\n    status: RecorderStatus.IntentToStart,\n  }\n\n  let startStrategy = () => {\n    state = { status: RecorderStatus.IntentToStart }\n  }\n  let stopStrategy = () => {\n    state = { status: RecorderStatus.Stopped }\n  }\n  let getSessionReplayLinkStrategy = noop as () => string | undefined\n\n  return {\n    start: () => startStrategy(),\n    stop: () => stopStrategy(),\n    getSessionReplayLink: () => getSessionReplayLinkStrategy(),\n    onRumStart: (\n      lifeCycle: LifeCycle,\n      configuration: RumConfiguration,\n      sessionManager: RumSessionManager,\n      viewContexts: ViewContexts,\n      worker\n    ) => {\n      if (configuration.startSessionReplayRecordingManually) {\n        state = { status: RecorderStatus.Stopped }\n      }\n      lifeCycle.subscribe(LifeCycleEventType.SESSION_EXPIRED, () => {\n        if (state.status === RecorderStatus.Starting || state.status === RecorderStatus.Started) {\n          stopStrategy()\n          state = { status: RecorderStatus.IntentToStart }\n        }\n      })\n\n      // Stop the recorder on page unload to avoid sending records after the page is ended.\n      lifeCycle.subscribe(LifeCycleEventType.PAGE_EXITED, (pageExitEvent) => {\n        if (pageExitEvent.reason === PageExitReason.UNLOADING || pageExitEvent.reason === PageExitReason.PAGEHIDE) {\n          stopStrategy()\n        }\n      })\n\n      lifeCycle.subscribe(LifeCycleEventType.SESSION_RENEWED, () => {\n        if (state.status === RecorderStatus.IntentToStart) {\n          startStrategy()\n        }\n      })\n\n      let cachedDeflateEncoder: DeflateEncoder | undefined\n\n      function getOrCreateDeflateEncoder() {\n        if (!cachedDeflateEncoder) {\n          if (!worker) {\n            worker = startDeflateWorker(\n              configuration,\n              'Datadog Session Replay',\n              () => {\n                stopStrategy()\n              },\n              createDeflateWorkerImpl\n            )\n          }\n          if (worker) {\n            cachedDeflateEncoder = createDeflateEncoder(configuration, worker, DeflateEncoderStreamId.REPLAY)\n          }\n        }\n        return cachedDeflateEncoder\n      }\n\n      startStrategy = () => {\n        const session = sessionManager.findTrackedSession()\n        if (!session || !session.sessionReplayAllowed) {\n          state = { status: RecorderStatus.IntentToStart }\n          return\n        }\n\n        if (state.status === RecorderStatus.Starting || state.status === RecorderStatus.Started) {\n          return\n        }\n\n        state = { status: RecorderStatus.Starting }\n\n        runOnReadyState(configuration, 'interactive', () => {\n          if (state.status !== RecorderStatus.Starting) {\n            return\n          }\n\n          const deflateEncoder = getOrCreateDeflateEncoder()\n          if (!deflateEncoder) {\n            state = {\n              status: RecorderStatus.Stopped,\n            }\n            return\n          }\n\n          const { stop: stopRecording } = startRecordingImpl(\n            lifeCycle,\n            configuration,\n            sessionManager,\n            viewContexts,\n            deflateEncoder\n          )\n          state = {\n            status: RecorderStatus.Started,\n            stopRecording,\n          }\n        })\n      }\n\n      stopStrategy = () => {\n        if (state.status === RecorderStatus.Stopped) {\n          return\n        }\n\n        if (state.status === RecorderStatus.Started) {\n          state.stopRecording()\n        }\n\n        state = {\n          status: RecorderStatus.Stopped,\n        }\n      }\n\n      getSessionReplayLinkStrategy = () =>\n        getSessionReplayLink(configuration, sessionManager, viewContexts, state.status !== RecorderStatus.Stopped)\n\n      if (state.status === RecorderStatus.IntentToStart) {\n        startStrategy()\n      }\n    },\n\n    isRecording: () =>\n      // The worker is started optimistically, meaning we could have started to record but its\n      // initialization fails a bit later. This could happen when:\n      // * the worker URL (blob or plain URL) is blocked by CSP in Firefox only (Chromium and Safari\n      // throw an exception when instantiating the worker, and IE doesn't care about CSP)\n      // * the browser fails to load the worker in case the workerUrl is used\n      // * an unexpected error occurs in the Worker before initialization, ex:\n      //   * a runtime exception collected by monitor()\n      //   * a syntax error notified by the browser via an error event\n      // * the worker is unresponsive for some reason and timeouts\n      //\n      // It is not expected to happen often. Nonetheless, the \"replayable\" status on RUM events is\n      // an important part of the Datadog App:\n      // * If we have a false positive (we set has_replay: true even if no replay data is present),\n      // we might display broken links to the Session Replay player.\n      // * If we have a false negative (we don't set has_replay: true even if replay data is\n      // available), it is less noticeable because no link will be displayed.\n      //\n      // Thus, it is better to have false negative, so let's make sure the worker is correctly\n      // initialized before advertizing that we are recording.\n      //\n      // In the future, when the compression worker will also be used for RUM data, this will be\n      // less important since no RUM event will be sent when the worker fails to initialize.\n      getDeflateWorkerStatus() === DeflateWorkerStatus.Initialized && state.status === RecorderStatus.Started,\n\n    getReplayStats: (viewId) =>\n      getDeflateWorkerStatus() === DeflateWorkerStatus.Initialized ? getReplayStatsImpl(viewId) : undefined,\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}