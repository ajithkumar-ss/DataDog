{"ast":null,"code":"import { includes, performDraw, ONE_SECOND, addTelemetryDebug, setInterval } from '@datadog/browser-core';\nexport var MEASURES_PERIOD_DURATION = 10 * ONE_SECOND;\nvar currentPeriodMeasures;\nvar currentBatchMeasures;\nvar batchHasRumEvent;\nexport function startCustomerDataTelemetry(configuration, telemetry, lifeCycle, customerDataTrackerManager, batchFlushObservable) {\n  var customerDataTelemetryEnabled = telemetry.enabled && performDraw(configuration.customerDataTelemetrySampleRate);\n  if (!customerDataTelemetryEnabled) {\n    return;\n  }\n  initCurrentPeriodMeasures();\n  initCurrentBatchMeasures();\n  // We measure the data of every view updates even if there could only be one per batch due to the upsert\n  // It means that contexts bytes count sums can be higher than it really is\n  lifeCycle.subscribe(13 /* LifeCycleEventType.RUM_EVENT_COLLECTED */, function (event) {\n    batchHasRumEvent = true;\n    updateMeasure(currentBatchMeasures.globalContextBytes, customerDataTrackerManager.getOrCreateTracker(2 /* CustomerDataType.GlobalContext */).getBytesCount());\n    updateMeasure(currentBatchMeasures.userContextBytes, customerDataTrackerManager.getOrCreateTracker(1 /* CustomerDataType.User */).getBytesCount());\n    updateMeasure(currentBatchMeasures.featureFlagBytes, includes([\"view\" /* RumEventType.VIEW */, \"error\" /* RumEventType.ERROR */], event.type) ? customerDataTrackerManager.getOrCreateTracker(0 /* CustomerDataType.FeatureFlag */).getBytesCount() : 0);\n  });\n  batchFlushObservable.subscribe(function (_a) {\n    var bytesCount = _a.bytesCount,\n      messagesCount = _a.messagesCount;\n    // Don't measure batch that only contains telemetry events to avoid batch sending loop\n    // It could happen because after each batch we are adding a customer data measures telemetry event to the next one\n    if (!batchHasRumEvent) {\n      return;\n    }\n    currentPeriodMeasures.batchCount += 1;\n    updateMeasure(currentPeriodMeasures.batchBytesCount, bytesCount);\n    updateMeasure(currentPeriodMeasures.batchMessagesCount, messagesCount);\n    mergeMeasure(currentPeriodMeasures.globalContextBytes, currentBatchMeasures.globalContextBytes);\n    mergeMeasure(currentPeriodMeasures.userContextBytes, currentBatchMeasures.userContextBytes);\n    mergeMeasure(currentPeriodMeasures.featureFlagBytes, currentBatchMeasures.featureFlagBytes);\n    initCurrentBatchMeasures();\n  });\n  setInterval(sendCurrentPeriodMeasures, MEASURES_PERIOD_DURATION);\n}\nfunction sendCurrentPeriodMeasures() {\n  if (currentPeriodMeasures.batchCount === 0) {\n    return;\n  }\n  addTelemetryDebug('Customer data measures', currentPeriodMeasures);\n  initCurrentPeriodMeasures();\n}\nfunction createMeasure() {\n  return {\n    min: Infinity,\n    max: 0,\n    sum: 0\n  };\n}\nfunction updateMeasure(measure, value) {\n  measure.sum += value;\n  measure.min = Math.min(measure.min, value);\n  measure.max = Math.max(measure.max, value);\n}\nfunction mergeMeasure(target, source) {\n  target.sum += source.sum;\n  target.min = Math.min(target.min, source.min);\n  target.max = Math.max(target.max, source.max);\n}\nfunction initCurrentPeriodMeasures() {\n  currentPeriodMeasures = {\n    batchCount: 0,\n    batchBytesCount: createMeasure(),\n    batchMessagesCount: createMeasure(),\n    globalContextBytes: createMeasure(),\n    userContextBytes: createMeasure(),\n    featureFlagBytes: createMeasure()\n  };\n}\nfunction initCurrentBatchMeasures() {\n  batchHasRumEvent = false;\n  currentBatchMeasures = {\n    globalContextBytes: createMeasure(),\n    userContextBytes: createMeasure(),\n    featureFlagBytes: createMeasure()\n  };\n}","map":{"version":3,"names":["includes","performDraw","ONE_SECOND","addTelemetryDebug","setInterval","MEASURES_PERIOD_DURATION","currentPeriodMeasures","currentBatchMeasures","batchHasRumEvent","startCustomerDataTelemetry","configuration","telemetry","lifeCycle","customerDataTrackerManager","batchFlushObservable","customerDataTelemetryEnabled","enabled","customerDataTelemetrySampleRate","initCurrentPeriodMeasures","initCurrentBatchMeasures","subscribe","event","updateMeasure","globalContextBytes","getOrCreateTracker","getBytesCount","userContextBytes","featureFlagBytes","type","_a","bytesCount","messagesCount","batchCount","batchBytesCount","batchMessagesCount","mergeMeasure","sendCurrentPeriodMeasures","createMeasure","min","Infinity","max","sum","measure","value","Math","target","source"],"sources":["D:\\edu'\\Spritle\\Spritle\\node_modules\\@datadog\\browser-rum-core\\src\\domain\\startCustomerDataTelemetry.ts"],"sourcesContent":["import type { Context, CustomerDataTrackerManager, FlushEvent, Observable, Telemetry } from '@datadog/browser-core'\nimport {\n  includes,\n  performDraw,\n  ONE_SECOND,\n  addTelemetryDebug,\n  setInterval,\n  CustomerDataType,\n} from '@datadog/browser-core'\nimport { RumEventType } from '../rawRumEvent.types'\nimport type { RumEvent } from '../rumEvent.types'\nimport type { RumConfiguration } from './configuration'\nimport type { LifeCycle } from './lifeCycle'\nimport { LifeCycleEventType } from './lifeCycle'\n\nexport const MEASURES_PERIOD_DURATION = 10 * ONE_SECOND\n\ntype Measure = {\n  min: number\n  max: number\n  sum: number\n}\n\ntype CurrentPeriodMeasures = {\n  batchCount: number\n  batchBytesCount: Measure\n  batchMessagesCount: Measure\n  globalContextBytes: Measure\n  userContextBytes: Measure\n  featureFlagBytes: Measure\n}\n\ntype CurrentBatchMeasures = {\n  globalContextBytes: Measure\n  userContextBytes: Measure\n  featureFlagBytes: Measure\n}\n\nlet currentPeriodMeasures: CurrentPeriodMeasures\nlet currentBatchMeasures: CurrentBatchMeasures\nlet batchHasRumEvent: boolean\n\nexport function startCustomerDataTelemetry(\n  configuration: RumConfiguration,\n  telemetry: Telemetry,\n  lifeCycle: LifeCycle,\n  customerDataTrackerManager: CustomerDataTrackerManager,\n  batchFlushObservable: Observable<FlushEvent>\n) {\n  const customerDataTelemetryEnabled = telemetry.enabled && performDraw(configuration.customerDataTelemetrySampleRate)\n  if (!customerDataTelemetryEnabled) {\n    return\n  }\n\n  initCurrentPeriodMeasures()\n  initCurrentBatchMeasures()\n\n  // We measure the data of every view updates even if there could only be one per batch due to the upsert\n  // It means that contexts bytes count sums can be higher than it really is\n  lifeCycle.subscribe(LifeCycleEventType.RUM_EVENT_COLLECTED, (event: RumEvent & Context) => {\n    batchHasRumEvent = true\n    updateMeasure(\n      currentBatchMeasures.globalContextBytes,\n      customerDataTrackerManager.getOrCreateTracker(CustomerDataType.GlobalContext).getBytesCount()\n    )\n\n    updateMeasure(\n      currentBatchMeasures.userContextBytes,\n      customerDataTrackerManager.getOrCreateTracker(CustomerDataType.User).getBytesCount()\n    )\n\n    updateMeasure(\n      currentBatchMeasures.featureFlagBytes,\n      includes([RumEventType.VIEW, RumEventType.ERROR], event.type)\n        ? customerDataTrackerManager.getOrCreateTracker(CustomerDataType.FeatureFlag).getBytesCount()\n        : 0\n    )\n  })\n\n  batchFlushObservable.subscribe(({ bytesCount, messagesCount }) => {\n    // Don't measure batch that only contains telemetry events to avoid batch sending loop\n    // It could happen because after each batch we are adding a customer data measures telemetry event to the next one\n    if (!batchHasRumEvent) {\n      return\n    }\n    currentPeriodMeasures.batchCount += 1\n    updateMeasure(currentPeriodMeasures.batchBytesCount, bytesCount)\n    updateMeasure(currentPeriodMeasures.batchMessagesCount, messagesCount)\n    mergeMeasure(currentPeriodMeasures.globalContextBytes, currentBatchMeasures.globalContextBytes)\n    mergeMeasure(currentPeriodMeasures.userContextBytes, currentBatchMeasures.userContextBytes)\n    mergeMeasure(currentPeriodMeasures.featureFlagBytes, currentBatchMeasures.featureFlagBytes)\n    initCurrentBatchMeasures()\n  })\n\n  setInterval(sendCurrentPeriodMeasures, MEASURES_PERIOD_DURATION)\n}\n\nfunction sendCurrentPeriodMeasures() {\n  if (currentPeriodMeasures.batchCount === 0) {\n    return\n  }\n\n  addTelemetryDebug('Customer data measures', currentPeriodMeasures)\n  initCurrentPeriodMeasures()\n}\n\nfunction createMeasure(): Measure {\n  return { min: Infinity, max: 0, sum: 0 }\n}\n\nfunction updateMeasure(measure: Measure, value: number) {\n  measure.sum += value\n  measure.min = Math.min(measure.min, value)\n  measure.max = Math.max(measure.max, value)\n}\n\nfunction mergeMeasure(target: Measure, source: Measure) {\n  target.sum += source.sum\n  target.min = Math.min(target.min, source.min)\n  target.max = Math.max(target.max, source.max)\n}\n\nfunction initCurrentPeriodMeasures() {\n  currentPeriodMeasures = {\n    batchCount: 0,\n    batchBytesCount: createMeasure(),\n    batchMessagesCount: createMeasure(),\n    globalContextBytes: createMeasure(),\n    userContextBytes: createMeasure(),\n    featureFlagBytes: createMeasure(),\n  }\n}\n\nfunction initCurrentBatchMeasures() {\n  batchHasRumEvent = false\n  currentBatchMeasures = {\n    globalContextBytes: createMeasure(),\n    userContextBytes: createMeasure(),\n    featureFlagBytes: createMeasure(),\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}