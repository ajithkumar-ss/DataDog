{"ast":null,"code":"import { display } from '../tools/display';\nimport { objectValues } from '../tools/utils/polyfills';\nimport { isPageExitReason } from '../browser/pageExitObservable';\nimport { jsonStringify } from '../tools/serialisation/jsonStringify';\nimport { computeBytesCount } from '../tools/utils/byteUtils';\nvar Batch = /** @class */function () {\n  function Batch(encoder, request, flushController, messageBytesLimit) {\n    var _this = this;\n    this.encoder = encoder;\n    this.request = request;\n    this.flushController = flushController;\n    this.messageBytesLimit = messageBytesLimit;\n    this.upsertBuffer = {};\n    this.flushSubscription = this.flushController.flushObservable.subscribe(function (event) {\n      return _this.flush(event);\n    });\n  }\n  Batch.prototype.add = function (message) {\n    this.addOrUpdate(message);\n  };\n  Batch.prototype.upsert = function (message, key) {\n    this.addOrUpdate(message, key);\n  };\n  Batch.prototype.stop = function () {\n    this.flushSubscription.unsubscribe();\n  };\n  Batch.prototype.flush = function (event) {\n    var upsertMessages = objectValues(this.upsertBuffer).join('\\n');\n    this.upsertBuffer = {};\n    var isPageExit = isPageExitReason(event.reason);\n    var send = isPageExit ? this.request.sendOnExit : this.request.send;\n    if (isPageExit &&\n    // Note: checking that the encoder is async is not strictly needed, but it's an optimization:\n    // if the encoder is async we need to send two requests in some cases (one for encoded data\n    // and the other for non-encoded data). But if it's not async, we don't have to worry about\n    // it and always send a single request.\n    this.encoder.isAsync) {\n      var encoderResult = this.encoder.finishSync();\n      // Send encoded messages\n      if (encoderResult.outputBytesCount) {\n        send(formatPayloadFromEncoder(encoderResult, event));\n      }\n      // Send messages that are not yet encoded at this point\n      var pendingMessages = [encoderResult.pendingData, upsertMessages].filter(Boolean).join('\\n');\n      if (pendingMessages) {\n        send({\n          data: pendingMessages,\n          bytesCount: computeBytesCount(pendingMessages),\n          flushReason: event.reason\n        });\n      }\n    } else {\n      if (upsertMessages) {\n        this.encoder.write(this.encoder.isEmpty ? upsertMessages : \"\\n\".concat(upsertMessages));\n      }\n      this.encoder.finish(function (encoderResult) {\n        send(formatPayloadFromEncoder(encoderResult, event));\n      });\n    }\n  };\n  Batch.prototype.addOrUpdate = function (message, key) {\n    var serializedMessage = jsonStringify(message);\n    var estimatedMessageBytesCount = this.encoder.estimateEncodedBytesCount(serializedMessage);\n    if (estimatedMessageBytesCount >= this.messageBytesLimit) {\n      display.warn(\"Discarded a message whose size was bigger than the maximum allowed size \".concat(this.messageBytesLimit, \"KB.\"));\n      return;\n    }\n    if (this.hasMessageFor(key)) {\n      this.remove(key);\n    }\n    this.push(serializedMessage, estimatedMessageBytesCount, key);\n  };\n  Batch.prototype.push = function (serializedMessage, estimatedMessageBytesCount, key) {\n    var _this = this;\n    this.flushController.notifyBeforeAddMessage(estimatedMessageBytesCount);\n    if (key !== undefined) {\n      this.upsertBuffer[key] = serializedMessage;\n      this.flushController.notifyAfterAddMessage();\n    } else {\n      this.encoder.write(this.encoder.isEmpty ? serializedMessage : \"\\n\".concat(serializedMessage), function (realMessageBytesCount) {\n        _this.flushController.notifyAfterAddMessage(realMessageBytesCount - estimatedMessageBytesCount);\n      });\n    }\n  };\n  Batch.prototype.remove = function (key) {\n    var removedMessage = this.upsertBuffer[key];\n    delete this.upsertBuffer[key];\n    var messageBytesCount = this.encoder.estimateEncodedBytesCount(removedMessage);\n    this.flushController.notifyAfterRemoveMessage(messageBytesCount);\n  };\n  Batch.prototype.hasMessageFor = function (key) {\n    return key !== undefined && this.upsertBuffer[key] !== undefined;\n  };\n  return Batch;\n}();\nexport { Batch };\nfunction formatPayloadFromEncoder(encoderResult, flushEvent) {\n  var data;\n  if (typeof encoderResult.output === 'string') {\n    data = encoderResult.output;\n  } else {\n    data = new Blob([encoderResult.output], {\n      // This will set the 'Content-Type: text/plain' header. Reasoning:\n      // * The intake rejects the request if there is no content type.\n      // * The browser will issue CORS preflight requests if we set it to 'application/json', which\n      // could induce higher intake load (and maybe has other impacts).\n      // * Also it's not quite JSON, since we are concatenating multiple JSON objects separated by\n      // new lines.\n      type: 'text/plain'\n    });\n  }\n  return {\n    data: data,\n    bytesCount: encoderResult.outputBytesCount,\n    encoding: encoderResult.encoding,\n    flushReason: flushEvent.reason\n  };\n}","map":{"version":3,"names":["display","objectValues","isPageExitReason","jsonStringify","computeBytesCount","Batch","encoder","request","flushController","messageBytesLimit","_this","upsertBuffer","flushSubscription","flushObservable","subscribe","event","flush","prototype","add","message","addOrUpdate","upsert","key","stop","unsubscribe","upsertMessages","join","isPageExit","reason","send","sendOnExit","isAsync","encoderResult","finishSync","outputBytesCount","formatPayloadFromEncoder","pendingMessages","pendingData","filter","Boolean","data","bytesCount","flushReason","write","isEmpty","concat","finish","serializedMessage","estimatedMessageBytesCount","estimateEncodedBytesCount","warn","hasMessageFor","remove","push","notifyBeforeAddMessage","undefined","notifyAfterAddMessage","realMessageBytesCount","removedMessage","messageBytesCount","notifyAfterRemoveMessage","flushEvent","output","Blob","type","encoding"],"sources":["D:\\edu'\\Spritle\\spritle\\node_modules\\@datadog\\browser-core\\src\\transport\\batch.ts"],"sourcesContent":["import { display } from '../tools/display'\nimport type { Context } from '../tools/serialisation/context'\nimport { objectValues } from '../tools/utils/polyfills'\nimport { isPageExitReason } from '../browser/pageExitObservable'\nimport { jsonStringify } from '../tools/serialisation/jsonStringify'\nimport type { Subscription } from '../tools/observable'\nimport type { Encoder, EncoderResult } from '../tools/encoder'\nimport { computeBytesCount } from '../tools/utils/byteUtils'\nimport type { HttpRequest, Payload } from './httpRequest'\nimport type { FlushController, FlushEvent } from './flushController'\n\nexport class Batch {\n  private upsertBuffer: { [key: string]: string } = {}\n  private flushSubscription: Subscription\n\n  constructor(\n    private encoder: Encoder,\n    private request: HttpRequest,\n    public flushController: FlushController,\n    private messageBytesLimit: number\n  ) {\n    this.flushSubscription = this.flushController.flushObservable.subscribe((event) => this.flush(event))\n  }\n\n  add(message: Context) {\n    this.addOrUpdate(message)\n  }\n\n  upsert(message: Context, key: string) {\n    this.addOrUpdate(message, key)\n  }\n\n  stop() {\n    this.flushSubscription.unsubscribe()\n  }\n\n  private flush(event: FlushEvent) {\n    const upsertMessages = objectValues(this.upsertBuffer).join('\\n')\n    this.upsertBuffer = {}\n\n    const isPageExit = isPageExitReason(event.reason)\n    const send = isPageExit ? this.request.sendOnExit : this.request.send\n\n    if (\n      isPageExit &&\n      // Note: checking that the encoder is async is not strictly needed, but it's an optimization:\n      // if the encoder is async we need to send two requests in some cases (one for encoded data\n      // and the other for non-encoded data). But if it's not async, we don't have to worry about\n      // it and always send a single request.\n      this.encoder.isAsync\n    ) {\n      const encoderResult = this.encoder.finishSync()\n\n      // Send encoded messages\n      if (encoderResult.outputBytesCount) {\n        send(formatPayloadFromEncoder(encoderResult, event))\n      }\n\n      // Send messages that are not yet encoded at this point\n      const pendingMessages = [encoderResult.pendingData, upsertMessages].filter(Boolean).join('\\n')\n      if (pendingMessages) {\n        send({\n          data: pendingMessages,\n          bytesCount: computeBytesCount(pendingMessages),\n          flushReason: event.reason,\n        })\n      }\n    } else {\n      if (upsertMessages) {\n        this.encoder.write(this.encoder.isEmpty ? upsertMessages : `\\n${upsertMessages}`)\n      }\n      this.encoder.finish((encoderResult) => {\n        send(formatPayloadFromEncoder(encoderResult, event))\n      })\n    }\n  }\n\n  private addOrUpdate(message: Context, key?: string) {\n    const serializedMessage = jsonStringify(message)!\n\n    const estimatedMessageBytesCount = this.encoder.estimateEncodedBytesCount(serializedMessage)\n\n    if (estimatedMessageBytesCount >= this.messageBytesLimit) {\n      display.warn(\n        `Discarded a message whose size was bigger than the maximum allowed size ${this.messageBytesLimit}KB.`\n      )\n      return\n    }\n\n    if (this.hasMessageFor(key)) {\n      this.remove(key)\n    }\n\n    this.push(serializedMessage, estimatedMessageBytesCount, key)\n  }\n\n  private push(serializedMessage: string, estimatedMessageBytesCount: number, key?: string) {\n    this.flushController.notifyBeforeAddMessage(estimatedMessageBytesCount)\n\n    if (key !== undefined) {\n      this.upsertBuffer[key] = serializedMessage\n      this.flushController.notifyAfterAddMessage()\n    } else {\n      this.encoder.write(\n        this.encoder.isEmpty ? serializedMessage : `\\n${serializedMessage}`,\n        (realMessageBytesCount) => {\n          this.flushController.notifyAfterAddMessage(realMessageBytesCount - estimatedMessageBytesCount)\n        }\n      )\n    }\n  }\n\n  private remove(key: string) {\n    const removedMessage = this.upsertBuffer[key]\n    delete this.upsertBuffer[key]\n    const messageBytesCount = this.encoder.estimateEncodedBytesCount(removedMessage)\n    this.flushController.notifyAfterRemoveMessage(messageBytesCount)\n  }\n\n  private hasMessageFor(key?: string): key is string {\n    return key !== undefined && this.upsertBuffer[key] !== undefined\n  }\n}\n\nfunction formatPayloadFromEncoder(encoderResult: EncoderResult, flushEvent: FlushEvent): Payload {\n  let data: string | Blob\n  if (typeof encoderResult.output === 'string') {\n    data = encoderResult.output\n  } else {\n    data = new Blob([encoderResult.output], {\n      // This will set the 'Content-Type: text/plain' header. Reasoning:\n      // * The intake rejects the request if there is no content type.\n      // * The browser will issue CORS preflight requests if we set it to 'application/json', which\n      // could induce higher intake load (and maybe has other impacts).\n      // * Also it's not quite JSON, since we are concatenating multiple JSON objects separated by\n      // new lines.\n      type: 'text/plain',\n    })\n  }\n\n  return {\n    data,\n    bytesCount: encoderResult.outputBytesCount,\n    encoding: encoderResult.encoding,\n    flushReason: flushEvent.reason,\n  }\n}\n"],"mappings":"AAAA,SAASA,OAAO,QAAQ,kBAAkB;AAE1C,SAASC,YAAY,QAAQ,0BAA0B;AACvD,SAASC,gBAAgB,QAAQ,+BAA+B;AAChE,SAASC,aAAa,QAAQ,sCAAsC;AAGpE,SAASC,iBAAiB,QAAQ,0BAA0B;AAI5D,IAAAC,KAAA;EAIE,SAAAA,MACUC,OAAgB,EAChBC,OAAoB,EACrBC,eAAgC,EAC/BC,iBAAyB;IAJnC,IAAAC,KAAA;IACU,KAAAJ,OAAO,GAAPA,OAAO;IACP,KAAAC,OAAO,GAAPA,OAAO;IACR,KAAAC,eAAe,GAAfA,eAAe;IACd,KAAAC,iBAAiB,GAAjBA,iBAAiB;IAPnB,KAAAE,YAAY,GAA8B,EAAE;IASlD,IAAI,CAACC,iBAAiB,GAAG,IAAI,CAACJ,eAAe,CAACK,eAAe,CAACC,SAAS,CAAC,UAACC,KAAK;MAAK,OAAAL,KAAI,CAACM,KAAK,CAACD,KAAK,CAAC;IAAjB,CAAiB,CAAC;EACvG;EAEAV,KAAA,CAAAY,SAAA,CAAAC,GAAG,GAAH,UAAIC,OAAgB;IAClB,IAAI,CAACC,WAAW,CAACD,OAAO,CAAC;EAC3B,CAAC;EAEDd,KAAA,CAAAY,SAAA,CAAAI,MAAM,GAAN,UAAOF,OAAgB,EAAEG,GAAW;IAClC,IAAI,CAACF,WAAW,CAACD,OAAO,EAAEG,GAAG,CAAC;EAChC,CAAC;EAEDjB,KAAA,CAAAY,SAAA,CAAAM,IAAI,GAAJ;IACE,IAAI,CAACX,iBAAiB,CAACY,WAAW,EAAE;EACtC,CAAC;EAEOnB,KAAA,CAAAY,SAAA,CAAAD,KAAK,GAAb,UAAcD,KAAiB;IAC7B,IAAMU,cAAc,GAAGxB,YAAY,CAAC,IAAI,CAACU,YAAY,CAAC,CAACe,IAAI,CAAC,IAAI,CAAC;IACjE,IAAI,CAACf,YAAY,GAAG,EAAE;IAEtB,IAAMgB,UAAU,GAAGzB,gBAAgB,CAACa,KAAK,CAACa,MAAM,CAAC;IACjD,IAAMC,IAAI,GAAGF,UAAU,GAAG,IAAI,CAACpB,OAAO,CAACuB,UAAU,GAAG,IAAI,CAACvB,OAAO,CAACsB,IAAI;IAErE,IACEF,UAAU;IACV;IACA;IACA;IACA;IACA,IAAI,CAACrB,OAAO,CAACyB,OAAO,EACpB;MACA,IAAMC,aAAa,GAAG,IAAI,CAAC1B,OAAO,CAAC2B,UAAU,EAAE;MAE/C;MACA,IAAID,aAAa,CAACE,gBAAgB,EAAE;QAClCL,IAAI,CAACM,wBAAwB,CAACH,aAAa,EAAEjB,KAAK,CAAC,CAAC;MACtD;MAEA;MACA,IAAMqB,eAAe,GAAG,CAACJ,aAAa,CAACK,WAAW,EAAEZ,cAAc,CAAC,CAACa,MAAM,CAACC,OAAO,CAAC,CAACb,IAAI,CAAC,IAAI,CAAC;MAC9F,IAAIU,eAAe,EAAE;QACnBP,IAAI,CAAC;UACHW,IAAI,EAAEJ,eAAe;UACrBK,UAAU,EAAErC,iBAAiB,CAACgC,eAAe,CAAC;UAC9CM,WAAW,EAAE3B,KAAK,CAACa;SACpB,CAAC;MACJ;IACF,CAAC,MAAM;MACL,IAAIH,cAAc,EAAE;QAClB,IAAI,CAACnB,OAAO,CAACqC,KAAK,CAAC,IAAI,CAACrC,OAAO,CAACsC,OAAO,GAAGnB,cAAc,GAAG,KAAAoB,MAAA,CAAKpB,cAAc,CAAE,CAAC;MACnF;MACA,IAAI,CAACnB,OAAO,CAACwC,MAAM,CAAC,UAACd,aAAa;QAChCH,IAAI,CAACM,wBAAwB,CAACH,aAAa,EAAEjB,KAAK,CAAC,CAAC;MACtD,CAAC,CAAC;IACJ;EACF,CAAC;EAEOV,KAAA,CAAAY,SAAA,CAAAG,WAAW,GAAnB,UAAoBD,OAAgB,EAAEG,GAAY;IAChD,IAAMyB,iBAAiB,GAAG5C,aAAa,CAACgB,OAAO,CAAE;IAEjD,IAAM6B,0BAA0B,GAAG,IAAI,CAAC1C,OAAO,CAAC2C,yBAAyB,CAACF,iBAAiB,CAAC;IAE5F,IAAIC,0BAA0B,IAAI,IAAI,CAACvC,iBAAiB,EAAE;MACxDT,OAAO,CAACkD,IAAI,CACV,2EAAAL,MAAA,CAA2E,IAAI,CAACpC,iBAAiB,QAAK,CACvG;MACD;IACF;IAEA,IAAI,IAAI,CAAC0C,aAAa,CAAC7B,GAAG,CAAC,EAAE;MAC3B,IAAI,CAAC8B,MAAM,CAAC9B,GAAG,CAAC;IAClB;IAEA,IAAI,CAAC+B,IAAI,CAACN,iBAAiB,EAAEC,0BAA0B,EAAE1B,GAAG,CAAC;EAC/D,CAAC;EAEOjB,KAAA,CAAAY,SAAA,CAAAoC,IAAI,GAAZ,UAAaN,iBAAyB,EAAEC,0BAAkC,EAAE1B,GAAY;IAAxF,IAAAZ,KAAA;IACE,IAAI,CAACF,eAAe,CAAC8C,sBAAsB,CAACN,0BAA0B,CAAC;IAEvE,IAAI1B,GAAG,KAAKiC,SAAS,EAAE;MACrB,IAAI,CAAC5C,YAAY,CAACW,GAAG,CAAC,GAAGyB,iBAAiB;MAC1C,IAAI,CAACvC,eAAe,CAACgD,qBAAqB,EAAE;IAC9C,CAAC,MAAM;MACL,IAAI,CAAClD,OAAO,CAACqC,KAAK,CAChB,IAAI,CAACrC,OAAO,CAACsC,OAAO,GAAGG,iBAAiB,GAAG,KAAAF,MAAA,CAAKE,iBAAiB,CAAE,EACnE,UAACU,qBAAqB;QACpB/C,KAAI,CAACF,eAAe,CAACgD,qBAAqB,CAACC,qBAAqB,GAAGT,0BAA0B,CAAC;MAChG,CAAC,CACF;IACH;EACF,CAAC;EAEO3C,KAAA,CAAAY,SAAA,CAAAmC,MAAM,GAAd,UAAe9B,GAAW;IACxB,IAAMoC,cAAc,GAAG,IAAI,CAAC/C,YAAY,CAACW,GAAG,CAAC;IAC7C,OAAO,IAAI,CAACX,YAAY,CAACW,GAAG,CAAC;IAC7B,IAAMqC,iBAAiB,GAAG,IAAI,CAACrD,OAAO,CAAC2C,yBAAyB,CAACS,cAAc,CAAC;IAChF,IAAI,CAAClD,eAAe,CAACoD,wBAAwB,CAACD,iBAAiB,CAAC;EAClE,CAAC;EAEOtD,KAAA,CAAAY,SAAA,CAAAkC,aAAa,GAArB,UAAsB7B,GAAY;IAChC,OAAOA,GAAG,KAAKiC,SAAS,IAAI,IAAI,CAAC5C,YAAY,CAACW,GAAG,CAAC,KAAKiC,SAAS;EAClE,CAAC;EACH,OAAAlD,KAAC;AAAD,CAAC,CA/GD;;AAiHA,SAAS8B,wBAAwBA,CAACH,aAA4B,EAAE6B,UAAsB;EACpF,IAAIrB,IAAmB;EACvB,IAAI,OAAOR,aAAa,CAAC8B,MAAM,KAAK,QAAQ,EAAE;IAC5CtB,IAAI,GAAGR,aAAa,CAAC8B,MAAM;EAC7B,CAAC,MAAM;IACLtB,IAAI,GAAG,IAAIuB,IAAI,CAAC,CAAC/B,aAAa,CAAC8B,MAAM,CAAC,EAAE;MACtC;MACA;MACA;MACA;MACA;MACA;MACAE,IAAI,EAAE;KACP,CAAC;EACJ;EAEA,OAAO;IACLxB,IAAI,EAAAA,IAAA;IACJC,UAAU,EAAET,aAAa,CAACE,gBAAgB;IAC1C+B,QAAQ,EAAEjC,aAAa,CAACiC,QAAQ;IAChCvB,WAAW,EAAEmB,UAAU,CAACjC;GACzB;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}