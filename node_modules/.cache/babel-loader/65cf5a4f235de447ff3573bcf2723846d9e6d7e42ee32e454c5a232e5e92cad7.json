{"ast":null,"code":"import { instrumentSetter, assign, DOM_EVENT, addEventListeners, forEach, noop } from '@datadog/browser-core';\nimport { cssEscape } from '@datadog/browser-rum-core';\nimport { NodePrivacyLevel } from '../../../constants';\nimport { IncrementalSource } from '../../../types';\nimport { getEventTarget } from '../eventsUtils';\nimport { getNodePrivacyLevel, shouldMaskNode } from '../privacy';\nimport { getElementInputValue, getSerializedNodeId, hasSerializedNode } from '../serialization';\nimport { assembleIncrementalSnapshot } from '../assembly';\nexport function trackInput(configuration, inputCb, target) {\n  if (target === void 0) {\n    target = document;\n  }\n  var defaultPrivacyLevel = configuration.defaultPrivacyLevel;\n  var lastInputStateMap = new WeakMap();\n  var isShadowRoot = target !== document;\n  var stopEventListeners = addEventListeners(configuration, target,\n  // The 'input' event bubbles across shadow roots, so we don't have to listen for it on shadow\n  // roots since it will be handled by the event listener that we did add to the document. Only\n  // the 'change' event is blocked and needs to be handled on shadow roots.\n  isShadowRoot ? [DOM_EVENT.CHANGE] : [DOM_EVENT.INPUT, DOM_EVENT.CHANGE], function (event) {\n    var target = getEventTarget(event);\n    if (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement || target instanceof HTMLSelectElement) {\n      onElementChange(target);\n    }\n  }, {\n    capture: true,\n    passive: true\n  }).stop;\n  var stopPropertySetterInstrumentation;\n  if (!isShadowRoot) {\n    var instrumentationStoppers_1 = [instrumentSetter(HTMLInputElement.prototype, 'value', onElementChange), instrumentSetter(HTMLInputElement.prototype, 'checked', onElementChange), instrumentSetter(HTMLSelectElement.prototype, 'value', onElementChange), instrumentSetter(HTMLTextAreaElement.prototype, 'value', onElementChange), instrumentSetter(HTMLSelectElement.prototype, 'selectedIndex', onElementChange)];\n    stopPropertySetterInstrumentation = function () {\n      instrumentationStoppers_1.forEach(function (stopper) {\n        return stopper.stop();\n      });\n    };\n  } else {\n    stopPropertySetterInstrumentation = noop;\n  }\n  return {\n    stop: function () {\n      stopPropertySetterInstrumentation();\n      stopEventListeners();\n    }\n  };\n  function onElementChange(target) {\n    var nodePrivacyLevel = getNodePrivacyLevel(target, defaultPrivacyLevel);\n    if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n      return;\n    }\n    var type = target.type;\n    var inputState;\n    if (type === 'radio' || type === 'checkbox') {\n      if (shouldMaskNode(target, nodePrivacyLevel)) {\n        return;\n      }\n      inputState = {\n        isChecked: target.checked\n      };\n    } else {\n      var value = getElementInputValue(target, nodePrivacyLevel);\n      if (value === undefined) {\n        return;\n      }\n      inputState = {\n        text: value\n      };\n    }\n    // Can be multiple changes on the same node within the same batched mutation observation.\n    cbWithDedup(target, inputState);\n    // If a radio was checked, other radios with the same name attribute will be unchecked.\n    var name = target.name;\n    if (type === 'radio' && name && target.checked) {\n      forEach(document.querySelectorAll(\"input[type=\\\"radio\\\"][name=\\\"\".concat(cssEscape(name), \"\\\"]\")), function (el) {\n        if (el !== target) {\n          // TODO: Consider the privacy implications for various differing input privacy levels\n          cbWithDedup(el, {\n            isChecked: false\n          });\n        }\n      });\n    }\n  }\n  /**\n   * There can be multiple changes on the same node within the same batched mutation observation.\n   */\n  function cbWithDedup(target, inputState) {\n    if (!hasSerializedNode(target)) {\n      return;\n    }\n    var lastInputState = lastInputStateMap.get(target);\n    if (!lastInputState || lastInputState.text !== inputState.text || lastInputState.isChecked !== inputState.isChecked) {\n      lastInputStateMap.set(target, inputState);\n      inputCb(assembleIncrementalSnapshot(IncrementalSource.Input, assign({\n        id: getSerializedNodeId(target)\n      }, inputState)));\n    }\n  }\n}","map":{"version":3,"names":["instrumentSetter","assign","DOM_EVENT","addEventListeners","forEach","noop","cssEscape","NodePrivacyLevel","IncrementalSource","getEventTarget","getNodePrivacyLevel","shouldMaskNode","getElementInputValue","getSerializedNodeId","hasSerializedNode","assembleIncrementalSnapshot","trackInput","configuration","inputCb","target","document","defaultPrivacyLevel","lastInputStateMap","WeakMap","isShadowRoot","stopEventListeners","CHANGE","INPUT","event","HTMLInputElement","HTMLTextAreaElement","HTMLSelectElement","onElementChange","capture","passive","stop","stopPropertySetterInstrumentation","instrumentationStoppers_1","prototype","stopper","nodePrivacyLevel","HIDDEN","type","inputState","isChecked","checked","value","undefined","text","cbWithDedup","name","querySelectorAll","concat","el","lastInputState","get","set","Input","id"],"sources":["D:\\edu'\\Spritle\\spritle\\node_modules\\@datadog\\browser-rum\\src\\domain\\record\\trackers\\trackInput.ts"],"sourcesContent":["import { instrumentSetter, assign, DOM_EVENT, addEventListeners, forEach, noop } from '@datadog/browser-core'\nimport { cssEscape } from '@datadog/browser-rum-core'\nimport type { RumConfiguration } from '@datadog/browser-rum-core'\nimport { NodePrivacyLevel } from '../../../constants'\nimport { IncrementalSource } from '../../../types'\nimport type { BrowserIncrementalSnapshotRecord, InputData, InputState } from '../../../types'\nimport { getEventTarget } from '../eventsUtils'\nimport { getNodePrivacyLevel, shouldMaskNode } from '../privacy'\nimport { getElementInputValue, getSerializedNodeId, hasSerializedNode } from '../serialization'\nimport { assembleIncrementalSnapshot } from '../assembly'\nimport type { Tracker } from './types'\n\nexport type InputCallback = (incrementalSnapshotRecord: BrowserIncrementalSnapshotRecord) => void\n\nexport function trackInput(\n  configuration: RumConfiguration,\n  inputCb: InputCallback,\n  target: Document | ShadowRoot = document\n): Tracker {\n  const defaultPrivacyLevel = configuration.defaultPrivacyLevel\n  const lastInputStateMap: WeakMap<Node, InputState> = new WeakMap()\n\n  const isShadowRoot = target !== document\n\n  const { stop: stopEventListeners } = addEventListeners(\n    configuration,\n    target,\n    // The 'input' event bubbles across shadow roots, so we don't have to listen for it on shadow\n    // roots since it will be handled by the event listener that we did add to the document. Only\n    // the 'change' event is blocked and needs to be handled on shadow roots.\n    isShadowRoot ? [DOM_EVENT.CHANGE] : [DOM_EVENT.INPUT, DOM_EVENT.CHANGE],\n    (event) => {\n      const target = getEventTarget(event)\n      if (\n        target instanceof HTMLInputElement ||\n        target instanceof HTMLTextAreaElement ||\n        target instanceof HTMLSelectElement\n      ) {\n        onElementChange(target)\n      }\n    },\n    {\n      capture: true,\n      passive: true,\n    }\n  )\n\n  let stopPropertySetterInstrumentation: () => void\n  if (!isShadowRoot) {\n    const instrumentationStoppers = [\n      instrumentSetter(HTMLInputElement.prototype, 'value', onElementChange),\n      instrumentSetter(HTMLInputElement.prototype, 'checked', onElementChange),\n      instrumentSetter(HTMLSelectElement.prototype, 'value', onElementChange),\n      instrumentSetter(HTMLTextAreaElement.prototype, 'value', onElementChange),\n      instrumentSetter(HTMLSelectElement.prototype, 'selectedIndex', onElementChange),\n    ]\n    stopPropertySetterInstrumentation = () => {\n      instrumentationStoppers.forEach((stopper) => stopper.stop())\n    }\n  } else {\n    stopPropertySetterInstrumentation = noop\n  }\n\n  return {\n    stop: () => {\n      stopPropertySetterInstrumentation()\n      stopEventListeners()\n    },\n  }\n\n  function onElementChange(target: HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement) {\n    const nodePrivacyLevel = getNodePrivacyLevel(target, defaultPrivacyLevel)\n    if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n      return\n    }\n\n    const type = target.type\n\n    let inputState: InputState\n    if (type === 'radio' || type === 'checkbox') {\n      if (shouldMaskNode(target, nodePrivacyLevel)) {\n        return\n      }\n      inputState = { isChecked: (target as HTMLInputElement).checked }\n    } else {\n      const value = getElementInputValue(target, nodePrivacyLevel)\n      if (value === undefined) {\n        return\n      }\n      inputState = { text: value }\n    }\n\n    // Can be multiple changes on the same node within the same batched mutation observation.\n    cbWithDedup(target, inputState)\n\n    // If a radio was checked, other radios with the same name attribute will be unchecked.\n    const name = target.name\n    if (type === 'radio' && name && (target as HTMLInputElement).checked) {\n      forEach(document.querySelectorAll(`input[type=\"radio\"][name=\"${cssEscape(name)}\"]`), (el: Element) => {\n        if (el !== target) {\n          // TODO: Consider the privacy implications for various differing input privacy levels\n          cbWithDedup(el, { isChecked: false })\n        }\n      })\n    }\n  }\n\n  /**\n   * There can be multiple changes on the same node within the same batched mutation observation.\n   */\n  function cbWithDedup(target: Node, inputState: InputState) {\n    if (!hasSerializedNode(target)) {\n      return\n    }\n    const lastInputState = lastInputStateMap.get(target)\n    if (\n      !lastInputState ||\n      (lastInputState as { text?: string }).text !== (inputState as { text?: string }).text ||\n      (lastInputState as { isChecked?: boolean }).isChecked !== (inputState as { isChecked?: boolean }).isChecked\n    ) {\n      lastInputStateMap.set(target, inputState)\n      inputCb(\n        assembleIncrementalSnapshot<InputData>(\n          IncrementalSource.Input,\n          assign(\n            {\n              id: getSerializedNodeId(target),\n            },\n            inputState\n          )\n        )\n      )\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}