{"ast":null,"code":"import { setTimeout } from './timer';\nimport { callMonitored } from './monitor';\nimport { noop } from './utils/functionUtils';\nimport { arrayFrom, startsWith } from './utils/polyfills';\n/**\n * Instruments a method on a object, calling the given callback before the original method is\n * invoked. The callback receives an object with information about the method call.\n *\n * This function makes sure that we are \"good citizens\" regarding third party instrumentations: when\n * removing the instrumentation, the original method is usually restored, but if a third party\n * instrumentation was set after ours, we keep it in place and just replace our instrumentation with\n * a noop.\n *\n * Note: it is generally better to instrument methods that are \"owned\" by the object instead of ones\n * that are inherited from the prototype chain. Example:\n * * do:    `instrumentMethod(Array.prototype, 'push', ...)`\n * * don't: `instrumentMethod([], 'push', ...)`\n *\n * This method is also used to set event handler properties (ex: window.onerror = ...), as it has\n * the same requirements as instrumenting a method:\n * * if the event handler is already set by a third party, we need to call it and not just blindly\n * override it.\n * * if the event handler is set by a third party after us, we need to keep it in place when\n * removing ours.\n *\n * @example\n *\n *  instrumentMethod(window, 'fetch', ({ target, parameters, onPostCall }) => {\n *    console.log('Before calling fetch on', target, 'with parameters', parameters)\n *\n *    onPostCall((result) => {\n *      console.log('After fetch calling on', target, 'with parameters', parameters, 'and result', result)\n *    })\n *  })\n */\nexport function instrumentMethod(targetPrototype, method, onPreCall) {\n  var original = targetPrototype[method];\n  if (typeof original !== 'function') {\n    if (startsWith(method, 'on')) {\n      original = noop;\n    } else {\n      return {\n        stop: noop\n      };\n    }\n  }\n  var instrumentation = createInstrumentedMethod(original, onPreCall);\n  var instrumentationWrapper = function () {\n    if (typeof instrumentation !== 'function') {\n      return undefined;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-call\n    return instrumentation.apply(this, arguments);\n  };\n  targetPrototype[method] = instrumentationWrapper;\n  return {\n    stop: function () {\n      if (targetPrototype[method] === instrumentationWrapper) {\n        targetPrototype[method] = original;\n      } else {\n        instrumentation = original;\n      }\n    }\n  };\n}\nfunction createInstrumentedMethod(original, onPreCall) {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n  return function () {\n    var parameters = arrayFrom(arguments);\n    var postCallCallback;\n    callMonitored(onPreCall, null, [{\n      target: this,\n      parameters: parameters,\n      onPostCall: function (callback) {\n        postCallCallback = callback;\n      }\n    }]);\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n    var result = original.apply(this, parameters);\n    if (postCallCallback) {\n      callMonitored(postCallCallback, null, [result]);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return result;\n  };\n}\nexport function instrumentSetter(targetPrototype, property, after) {\n  var originalDescriptor = Object.getOwnPropertyDescriptor(targetPrototype, property);\n  if (!originalDescriptor || !originalDescriptor.set || !originalDescriptor.configurable) {\n    return {\n      stop: noop\n    };\n  }\n  var stoppedInstrumentation = noop;\n  var instrumentation = function (target, value) {\n    // put hooked setter into event loop to avoid of set latency\n    setTimeout(function () {\n      if (instrumentation !== stoppedInstrumentation) {\n        after(target, value);\n      }\n    }, 0);\n  };\n  var instrumentationWrapper = function (value) {\n    originalDescriptor.set.call(this, value);\n    instrumentation(this, value);\n  };\n  Object.defineProperty(targetPrototype, property, {\n    set: instrumentationWrapper\n  });\n  return {\n    stop: function () {\n      var _a;\n      if (((_a = Object.getOwnPropertyDescriptor(targetPrototype, property)) === null || _a === void 0 ? void 0 : _a.set) === instrumentationWrapper) {\n        Object.defineProperty(targetPrototype, property, originalDescriptor);\n      }\n      instrumentation = stoppedInstrumentation;\n    }\n  };\n}","map":{"version":3,"names":["setTimeout","callMonitored","noop","arrayFrom","startsWith","instrumentMethod","targetPrototype","method","onPreCall","original","stop","instrumentation","createInstrumentedMethod","instrumentationWrapper","undefined","apply","arguments","parameters","postCallCallback","target","onPostCall","callback","result","instrumentSetter","property","after","originalDescriptor","Object","getOwnPropertyDescriptor","set","configurable","stoppedInstrumentation","value","call","defineProperty","_a"],"sources":["D:\\edu'\\Spritle\\spritle\\node_modules\\@datadog\\browser-core\\src\\tools\\instrumentMethod.ts"],"sourcesContent":["import { setTimeout } from './timer'\nimport { callMonitored } from './monitor'\nimport { noop } from './utils/functionUtils'\nimport { arrayFrom, startsWith } from './utils/polyfills'\n\n/**\n * Object passed to the callback of an instrumented method call. See `instrumentMethod` for more\n * info.\n */\nexport type InstrumentedMethodCall<TARGET extends { [key: string]: any }, METHOD extends keyof TARGET> = {\n  /**\n   * The target object on which the method was called.\n   */\n  target: TARGET\n\n  /**\n   * The parameters with which the method was called.\n   *\n   * Note: if needed, parameters can be mutated by the instrumentation\n   */\n  parameters: Parameters<TARGET[METHOD]>\n\n  /**\n   * Registers a callback that will be called after the original method is called, with the method\n   * result passed as argument.\n   */\n  onPostCall: (callback: PostCallCallback<TARGET, METHOD>) => void\n}\n\ntype PostCallCallback<TARGET extends { [key: string]: any }, METHOD extends keyof TARGET> = (\n  result: ReturnType<TARGET[METHOD]>\n) => void\n\n/**\n * Instruments a method on a object, calling the given callback before the original method is\n * invoked. The callback receives an object with information about the method call.\n *\n * This function makes sure that we are \"good citizens\" regarding third party instrumentations: when\n * removing the instrumentation, the original method is usually restored, but if a third party\n * instrumentation was set after ours, we keep it in place and just replace our instrumentation with\n * a noop.\n *\n * Note: it is generally better to instrument methods that are \"owned\" by the object instead of ones\n * that are inherited from the prototype chain. Example:\n * * do:    `instrumentMethod(Array.prototype, 'push', ...)`\n * * don't: `instrumentMethod([], 'push', ...)`\n *\n * This method is also used to set event handler properties (ex: window.onerror = ...), as it has\n * the same requirements as instrumenting a method:\n * * if the event handler is already set by a third party, we need to call it and not just blindly\n * override it.\n * * if the event handler is set by a third party after us, we need to keep it in place when\n * removing ours.\n *\n * @example\n *\n *  instrumentMethod(window, 'fetch', ({ target, parameters, onPostCall }) => {\n *    console.log('Before calling fetch on', target, 'with parameters', parameters)\n *\n *    onPostCall((result) => {\n *      console.log('After fetch calling on', target, 'with parameters', parameters, 'and result', result)\n *    })\n *  })\n */\nexport function instrumentMethod<TARGET extends { [key: string]: any }, METHOD extends keyof TARGET & string>(\n  targetPrototype: TARGET,\n  method: METHOD,\n  onPreCall: (this: null, callInfos: InstrumentedMethodCall<TARGET, METHOD>) => void\n) {\n  let original = targetPrototype[method]\n\n  if (typeof original !== 'function') {\n    if (startsWith(method, 'on')) {\n      original = noop as TARGET[METHOD]\n    } else {\n      return { stop: noop }\n    }\n  }\n\n  let instrumentation = createInstrumentedMethod(original, onPreCall)\n\n  const instrumentationWrapper = function (this: TARGET): ReturnType<TARGET[METHOD]> | undefined {\n    if (typeof instrumentation !== 'function') {\n      return undefined\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-call\n    return instrumentation.apply(this, arguments as unknown as Parameters<TARGET[METHOD]>)\n  }\n  targetPrototype[method] = instrumentationWrapper as TARGET[METHOD]\n\n  return {\n    stop: () => {\n      if (targetPrototype[method] === instrumentationWrapper) {\n        targetPrototype[method] = original\n      } else {\n        instrumentation = original\n      }\n    },\n  }\n}\n\nfunction createInstrumentedMethod<TARGET extends { [key: string]: any }, METHOD extends keyof TARGET>(\n  original: TARGET[METHOD],\n  onPreCall: (this: null, callInfos: InstrumentedMethodCall<TARGET, METHOD>) => void\n): TARGET[METHOD] {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n  return function (this: TARGET) {\n    const parameters = arrayFrom(arguments) as Parameters<TARGET[METHOD]>\n\n    let postCallCallback: PostCallCallback<TARGET, METHOD> | undefined\n\n    callMonitored(onPreCall, null, [\n      {\n        target: this,\n        parameters,\n        onPostCall: (callback) => {\n          postCallCallback = callback\n        },\n      },\n    ])\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n    const result = original.apply(this, parameters)\n\n    if (postCallCallback) {\n      callMonitored(postCallCallback, null, [result])\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return result\n  } as TARGET[METHOD]\n}\n\nexport function instrumentSetter<TARGET extends { [key: string]: any }, PROPERTY extends keyof TARGET>(\n  targetPrototype: TARGET,\n  property: PROPERTY,\n  after: (target: TARGET, value: TARGET[PROPERTY]) => void\n) {\n  const originalDescriptor = Object.getOwnPropertyDescriptor(targetPrototype, property)\n  if (!originalDescriptor || !originalDescriptor.set || !originalDescriptor.configurable) {\n    return { stop: noop }\n  }\n\n  const stoppedInstrumentation = noop\n  let instrumentation = (target: TARGET, value: TARGET[PROPERTY]) => {\n    // put hooked setter into event loop to avoid of set latency\n    setTimeout(() => {\n      if (instrumentation !== stoppedInstrumentation) {\n        after(target, value)\n      }\n    }, 0)\n  }\n\n  const instrumentationWrapper = function (this: TARGET, value: TARGET[PROPERTY]) {\n    originalDescriptor.set!.call(this, value)\n    instrumentation(this, value)\n  }\n\n  Object.defineProperty(targetPrototype, property, {\n    set: instrumentationWrapper,\n  })\n\n  return {\n    stop: () => {\n      if (Object.getOwnPropertyDescriptor(targetPrototype, property)?.set === instrumentationWrapper) {\n        Object.defineProperty(targetPrototype, property, originalDescriptor)\n      }\n      instrumentation = stoppedInstrumentation\n    },\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}