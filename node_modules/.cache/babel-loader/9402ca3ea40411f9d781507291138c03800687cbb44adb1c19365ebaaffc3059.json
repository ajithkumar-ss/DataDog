{"ast":null,"code":"import { dateNow, findCommaSeparatedValue, ONE_MINUTE } from '@datadog/browser-core';\nimport { isCommentNode, isTextNode } from '../../browser/htmlDomUtils';\nexport var INITIAL_DOCUMENT_OUTDATED_TRACE_ID_THRESHOLD = 2 * ONE_MINUTE;\nexport function getDocumentTraceId(document) {\n  var data = getDocumentTraceDataFromMeta(document) || getDocumentTraceDataFromComment(document);\n  if (!data || data.traceTime <= dateNow() - INITIAL_DOCUMENT_OUTDATED_TRACE_ID_THRESHOLD) {\n    return undefined;\n  }\n  return data.traceId;\n}\nexport function getDocumentTraceDataFromMeta(document) {\n  var traceIdMeta = document.querySelector('meta[name=dd-trace-id]');\n  var traceTimeMeta = document.querySelector('meta[name=dd-trace-time]');\n  return createDocumentTraceData(traceIdMeta && traceIdMeta.content, traceTimeMeta && traceTimeMeta.content);\n}\nexport function getDocumentTraceDataFromComment(document) {\n  var comment = findTraceComment(document);\n  if (!comment) {\n    return undefined;\n  }\n  return createDocumentTraceData(findCommaSeparatedValue(comment, 'trace-id'), findCommaSeparatedValue(comment, 'trace-time'));\n}\nexport function createDocumentTraceData(traceId, rawTraceTime) {\n  var traceTime = rawTraceTime && Number(rawTraceTime);\n  if (!traceId || !traceTime) {\n    return undefined;\n  }\n  return {\n    traceId: traceId,\n    traceTime: traceTime\n  };\n}\nexport function findTraceComment(document) {\n  // 1. Try to find the comment as a direct child of the document\n  // Note: TSLint advises to use a 'for of', but TS doesn't allow to use 'for of' if the iterated\n  // value is not an array or string (here, a NodeList).\n  for (var i = 0; i < document.childNodes.length; i += 1) {\n    var comment = getTraceCommentFromNode(document.childNodes[i]);\n    if (comment) {\n      return comment;\n    }\n  }\n  // 2. If the comment is placed after the </html> tag, but have some space or new lines before or\n  // after, the DOM parser will lift it (and the surrounding text) at the end of the <body> tag.\n  // Try to look for the comment at the end of the <body> by by iterating over its child nodes in\n  // reverse order, stopping if we come across a non-text node.\n  if (document.body) {\n    for (var i = document.body.childNodes.length - 1; i >= 0; i -= 1) {\n      var node = document.body.childNodes[i];\n      var comment = getTraceCommentFromNode(node);\n      if (comment) {\n        return comment;\n      }\n      if (!isTextNode(node)) {\n        break;\n      }\n    }\n  }\n}\nfunction getTraceCommentFromNode(node) {\n  if (node && isCommentNode(node)) {\n    var match = /^\\s*DATADOG;(.*?)\\s*$/.exec(node.data);\n    if (match) {\n      return match[1];\n    }\n  }\n}","map":{"version":3,"names":["dateNow","findCommaSeparatedValue","ONE_MINUTE","isCommentNode","isTextNode","INITIAL_DOCUMENT_OUTDATED_TRACE_ID_THRESHOLD","getDocumentTraceId","document","data","getDocumentTraceDataFromMeta","getDocumentTraceDataFromComment","traceTime","undefined","traceId","traceIdMeta","querySelector","traceTimeMeta","createDocumentTraceData","content","comment","findTraceComment","rawTraceTime","Number","i","childNodes","length","getTraceCommentFromNode","body","node","match","exec"],"sources":["D:\\edu'\\Spritle\\spritle\\node_modules\\@datadog\\browser-rum-core\\src\\domain\\tracing\\getDocumentTraceId.ts"],"sourcesContent":["import type { TimeStamp } from '@datadog/browser-core'\nimport { dateNow, findCommaSeparatedValue, ONE_MINUTE } from '@datadog/browser-core'\nimport { isCommentNode, isTextNode } from '../../browser/htmlDomUtils'\n\ninterface DocumentTraceData {\n  traceId: string\n  traceTime: TimeStamp\n}\n\nexport const INITIAL_DOCUMENT_OUTDATED_TRACE_ID_THRESHOLD = 2 * ONE_MINUTE\n\nexport function getDocumentTraceId(document: Document): string | undefined {\n  const data = getDocumentTraceDataFromMeta(document) || getDocumentTraceDataFromComment(document)\n\n  if (!data || data.traceTime <= dateNow() - INITIAL_DOCUMENT_OUTDATED_TRACE_ID_THRESHOLD) {\n    return undefined\n  }\n\n  return data.traceId\n}\n\nexport function getDocumentTraceDataFromMeta(document: Document): DocumentTraceData | undefined {\n  const traceIdMeta = document.querySelector<HTMLMetaElement>('meta[name=dd-trace-id]')\n  const traceTimeMeta = document.querySelector<HTMLMetaElement>('meta[name=dd-trace-time]')\n  return createDocumentTraceData(traceIdMeta && traceIdMeta.content, traceTimeMeta && traceTimeMeta.content)\n}\n\nexport function getDocumentTraceDataFromComment(document: Document): DocumentTraceData | undefined {\n  const comment = findTraceComment(document)\n  if (!comment) {\n    return undefined\n  }\n  return createDocumentTraceData(\n    findCommaSeparatedValue(comment, 'trace-id'),\n    findCommaSeparatedValue(comment, 'trace-time')\n  )\n}\n\nexport function createDocumentTraceData(\n  traceId: string | undefined | null,\n  rawTraceTime: string | undefined | null\n): DocumentTraceData | undefined {\n  const traceTime = rawTraceTime && (Number(rawTraceTime) as TimeStamp)\n  if (!traceId || !traceTime) {\n    return undefined\n  }\n\n  return {\n    traceId,\n    traceTime,\n  }\n}\n\nexport function findTraceComment(document: Document): string | undefined {\n  // 1. Try to find the comment as a direct child of the document\n  // Note: TSLint advises to use a 'for of', but TS doesn't allow to use 'for of' if the iterated\n  // value is not an array or string (here, a NodeList).\n  for (let i = 0; i < document.childNodes.length; i += 1) {\n    const comment = getTraceCommentFromNode(document.childNodes[i])\n    if (comment) {\n      return comment\n    }\n  }\n\n  // 2. If the comment is placed after the </html> tag, but have some space or new lines before or\n  // after, the DOM parser will lift it (and the surrounding text) at the end of the <body> tag.\n  // Try to look for the comment at the end of the <body> by by iterating over its child nodes in\n  // reverse order, stopping if we come across a non-text node.\n  if (document.body) {\n    for (let i = document.body.childNodes.length - 1; i >= 0; i -= 1) {\n      const node = document.body.childNodes[i]\n      const comment = getTraceCommentFromNode(node)\n      if (comment) {\n        return comment\n      }\n      if (!isTextNode(node)) {\n        break\n      }\n    }\n  }\n}\n\nfunction getTraceCommentFromNode(node: Node | null) {\n  if (node && isCommentNode(node)) {\n    const match = /^\\s*DATADOG;(.*?)\\s*$/.exec(node.data)\n    if (match) {\n      return match[1]\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}