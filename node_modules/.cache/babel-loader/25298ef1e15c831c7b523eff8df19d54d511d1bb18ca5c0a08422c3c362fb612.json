{"ast":null,"code":"import { ONE_KIBI_BYTE, computeBytesCount } from '../../tools/utils/byteUtils';\nimport { throttle } from '../../tools/utils/functionUtils';\nimport { jsonStringify } from '../../tools/serialisation/jsonStringify';\nimport { display } from '../../tools/display';\nimport { isEmptyObject } from '../../tools/utils/objectUtils';\n// RUM and logs batch bytes limit is 16KB\n// ensure that we leave room for other event attributes and maintain a decent amount of event per batch\n// (3KB (customer data) + 1KB (other attributes)) * 4 (events per batch) = 16KB\nexport var CUSTOMER_DATA_BYTES_LIMIT = 3 * ONE_KIBI_BYTE;\n// We observed that the compression ratio is around 8 in general, but we also want to keep a margin\n// because some data might not be compressed (ex: last view update on page exit). We chose 16KiB\n// because it is also the limit of the 'batchBytesCount' that we use for RUM and Logs data, but this\n// is a bit arbitrary.\nexport var CUSTOMER_COMPRESSED_DATA_BYTES_LIMIT = 16 * ONE_KIBI_BYTE;\nexport var BYTES_COMPUTATION_THROTTLING_DELAY = 200;\nexport function createCustomerDataTrackerManager(compressionStatus) {\n  if (compressionStatus === void 0) {\n    compressionStatus = 2 /* CustomerDataCompressionStatus.Disabled */;\n  }\n  var customerDataTrackers = new Map();\n  var alreadyWarned = false;\n  function checkCustomerDataLimit(initialBytesCount) {\n    if (initialBytesCount === void 0) {\n      initialBytesCount = 0;\n    }\n    if (alreadyWarned || compressionStatus === 0 /* CustomerDataCompressionStatus.Unknown */) {\n      return;\n    }\n    var bytesCountLimit = compressionStatus === 2 /* CustomerDataCompressionStatus.Disabled */ ? CUSTOMER_DATA_BYTES_LIMIT : CUSTOMER_COMPRESSED_DATA_BYTES_LIMIT;\n    var bytesCount = initialBytesCount;\n    customerDataTrackers.forEach(function (tracker) {\n      bytesCount += tracker.getBytesCount();\n    });\n    if (bytesCount > bytesCountLimit) {\n      displayCustomerDataLimitReachedWarning(bytesCountLimit);\n      alreadyWarned = true;\n    }\n  }\n  return {\n    /**\n     * Creates a detached tracker. The manager will not store a reference to that tracker, and the\n     * bytes count will be counted independently from other detached trackers.\n     *\n     * This is particularly useful when we don't know when the tracker will be unused, so we don't\n     * leak memory (ex: when used in Logger instances).\n     */\n    createDetachedTracker: function () {\n      var tracker = createCustomerDataTracker(function () {\n        return checkCustomerDataLimit(tracker.getBytesCount());\n      });\n      return tracker;\n    },\n    /**\n     * Creates a tracker if it doesn't exist, and returns it.\n     */\n    getOrCreateTracker: function (type) {\n      if (!customerDataTrackers.has(type)) {\n        customerDataTrackers.set(type, createCustomerDataTracker(checkCustomerDataLimit));\n      }\n      return customerDataTrackers.get(type);\n    },\n    setCompressionStatus: function (newCompressionStatus) {\n      if (compressionStatus === 0 /* CustomerDataCompressionStatus.Unknown */) {\n        compressionStatus = newCompressionStatus;\n        checkCustomerDataLimit();\n      }\n    },\n    getCompressionStatus: function () {\n      return compressionStatus;\n    },\n    stop: function () {\n      customerDataTrackers.forEach(function (tracker) {\n        return tracker.stop();\n      });\n      customerDataTrackers.clear();\n    }\n  };\n}\nexport function createCustomerDataTracker(checkCustomerDataLimit) {\n  var bytesCountCache = 0;\n  // Throttle the bytes computation to minimize the impact on performance.\n  // Especially useful if the user call context APIs synchronously multiple times in a row\n  var _a = throttle(function (context) {\n      bytesCountCache = computeBytesCount(jsonStringify(context));\n      checkCustomerDataLimit();\n    }, BYTES_COMPUTATION_THROTTLING_DELAY),\n    computeBytesCountThrottled = _a.throttled,\n    cancelComputeBytesCount = _a.cancel;\n  var resetBytesCount = function () {\n    cancelComputeBytesCount();\n    bytesCountCache = 0;\n  };\n  return {\n    updateCustomerData: function (context) {\n      if (isEmptyObject(context)) {\n        resetBytesCount();\n      } else {\n        computeBytesCountThrottled(context);\n      }\n    },\n    resetCustomerData: resetBytesCount,\n    getBytesCount: function () {\n      return bytesCountCache;\n    },\n    stop: function () {\n      cancelComputeBytesCount();\n    }\n  };\n}\nfunction displayCustomerDataLimitReachedWarning(bytesCountLimit) {\n  display.warn(\"Customer data exceeds the recommended \".concat(bytesCountLimit / ONE_KIBI_BYTE, \"KiB threshold. More details: https://docs.datadoghq.com/real_user_monitoring/browser/troubleshooting/#customer-data-exceeds-the-recommended-threshold-warning\"));\n}","map":{"version":3,"names":["ONE_KIBI_BYTE","computeBytesCount","throttle","jsonStringify","display","isEmptyObject","CUSTOMER_DATA_BYTES_LIMIT","CUSTOMER_COMPRESSED_DATA_BYTES_LIMIT","BYTES_COMPUTATION_THROTTLING_DELAY","createCustomerDataTrackerManager","compressionStatus","customerDataTrackers","Map","alreadyWarned","checkCustomerDataLimit","initialBytesCount","bytesCountLimit","bytesCount","forEach","tracker","getBytesCount","displayCustomerDataLimitReachedWarning","createDetachedTracker","createCustomerDataTracker","getOrCreateTracker","type","has","set","get","setCompressionStatus","newCompressionStatus","getCompressionStatus","stop","clear","bytesCountCache","_a","context","computeBytesCountThrottled","throttled","cancelComputeBytesCount","cancel","resetBytesCount","updateCustomerData","resetCustomerData","warn","concat"],"sources":["D:\\edu'\\Spritle\\Spritle\\node_modules\\@datadog\\browser-core\\src\\domain\\context\\customerDataTracker.ts"],"sourcesContent":["import { ONE_KIBI_BYTE, computeBytesCount } from '../../tools/utils/byteUtils'\nimport { throttle } from '../../tools/utils/functionUtils'\nimport type { Context } from '../../tools/serialisation/context'\nimport { jsonStringify } from '../../tools/serialisation/jsonStringify'\nimport { display } from '../../tools/display'\nimport { isEmptyObject } from '../../tools/utils/objectUtils'\nimport type { CustomerDataType } from './contextConstants'\n\n// RUM and logs batch bytes limit is 16KB\n// ensure that we leave room for other event attributes and maintain a decent amount of event per batch\n// (3KB (customer data) + 1KB (other attributes)) * 4 (events per batch) = 16KB\nexport const CUSTOMER_DATA_BYTES_LIMIT = 3 * ONE_KIBI_BYTE\n\n// We observed that the compression ratio is around 8 in general, but we also want to keep a margin\n// because some data might not be compressed (ex: last view update on page exit). We chose 16KiB\n// because it is also the limit of the 'batchBytesCount' that we use for RUM and Logs data, but this\n// is a bit arbitrary.\nexport const CUSTOMER_COMPRESSED_DATA_BYTES_LIMIT = 16 * ONE_KIBI_BYTE\n\nexport const BYTES_COMPUTATION_THROTTLING_DELAY = 200\n\nexport type CustomerDataTracker = ReturnType<typeof createCustomerDataTracker>\nexport type CustomerDataTrackerManager = ReturnType<typeof createCustomerDataTrackerManager>\n\nexport const enum CustomerDataCompressionStatus {\n  Unknown,\n  Enabled,\n  Disabled,\n}\n\nexport function createCustomerDataTrackerManager(\n  compressionStatus: CustomerDataCompressionStatus = CustomerDataCompressionStatus.Disabled\n) {\n  const customerDataTrackers = new Map<CustomerDataType, CustomerDataTracker>()\n\n  let alreadyWarned = false\n  function checkCustomerDataLimit(initialBytesCount = 0) {\n    if (alreadyWarned || compressionStatus === CustomerDataCompressionStatus.Unknown) {\n      return\n    }\n\n    const bytesCountLimit =\n      compressionStatus === CustomerDataCompressionStatus.Disabled\n        ? CUSTOMER_DATA_BYTES_LIMIT\n        : CUSTOMER_COMPRESSED_DATA_BYTES_LIMIT\n\n    let bytesCount = initialBytesCount\n    customerDataTrackers.forEach((tracker) => {\n      bytesCount += tracker.getBytesCount()\n    })\n\n    if (bytesCount > bytesCountLimit) {\n      displayCustomerDataLimitReachedWarning(bytesCountLimit)\n      alreadyWarned = true\n    }\n  }\n\n  return {\n    /**\n     * Creates a detached tracker. The manager will not store a reference to that tracker, and the\n     * bytes count will be counted independently from other detached trackers.\n     *\n     * This is particularly useful when we don't know when the tracker will be unused, so we don't\n     * leak memory (ex: when used in Logger instances).\n     */\n    createDetachedTracker: () => {\n      const tracker = createCustomerDataTracker(() => checkCustomerDataLimit(tracker.getBytesCount()))\n      return tracker\n    },\n\n    /**\n     * Creates a tracker if it doesn't exist, and returns it.\n     */\n    getOrCreateTracker: (type: CustomerDataType) => {\n      if (!customerDataTrackers.has(type)) {\n        customerDataTrackers.set(type, createCustomerDataTracker(checkCustomerDataLimit))\n      }\n      return customerDataTrackers.get(type)!\n    },\n\n    setCompressionStatus: (newCompressionStatus: CustomerDataCompressionStatus) => {\n      if (compressionStatus === CustomerDataCompressionStatus.Unknown) {\n        compressionStatus = newCompressionStatus\n        checkCustomerDataLimit()\n      }\n    },\n\n    getCompressionStatus: () => compressionStatus,\n\n    stop: () => {\n      customerDataTrackers.forEach((tracker) => tracker.stop())\n      customerDataTrackers.clear()\n    },\n  }\n}\n\nexport function createCustomerDataTracker(checkCustomerDataLimit: () => void) {\n  let bytesCountCache = 0\n\n  // Throttle the bytes computation to minimize the impact on performance.\n  // Especially useful if the user call context APIs synchronously multiple times in a row\n  const { throttled: computeBytesCountThrottled, cancel: cancelComputeBytesCount } = throttle((context: Context) => {\n    bytesCountCache = computeBytesCount(jsonStringify(context)!)\n    checkCustomerDataLimit()\n  }, BYTES_COMPUTATION_THROTTLING_DELAY)\n\n  const resetBytesCount = () => {\n    cancelComputeBytesCount()\n    bytesCountCache = 0\n  }\n\n  return {\n    updateCustomerData: (context: Context) => {\n      if (isEmptyObject(context)) {\n        resetBytesCount()\n      } else {\n        computeBytesCountThrottled(context)\n      }\n    },\n    resetCustomerData: resetBytesCount,\n    getBytesCount: () => bytesCountCache,\n    stop: () => {\n      cancelComputeBytesCount()\n    },\n  }\n}\n\nfunction displayCustomerDataLimitReachedWarning(bytesCountLimit: number) {\n  display.warn(\n    `Customer data exceeds the recommended ${\n      bytesCountLimit / ONE_KIBI_BYTE\n    }KiB threshold. More details: https://docs.datadoghq.com/real_user_monitoring/browser/troubleshooting/#customer-data-exceeds-the-recommended-threshold-warning`\n  )\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}