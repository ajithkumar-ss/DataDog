{"ast":null,"code":"import { getType } from './utils/typeUtils';\n/**\n * Iterate over source and affect its sub values into destination, recursively.\n * If the source and destination can't be merged, return source.\n */\nexport function mergeInto(destination, source, circularReferenceChecker) {\n  if (circularReferenceChecker === void 0) {\n    circularReferenceChecker = createCircularReferenceChecker();\n  }\n  // ignore the source if it is undefined\n  if (source === undefined) {\n    return destination;\n  }\n  if (typeof source !== 'object' || source === null) {\n    // primitive values - just return source\n    return source;\n  } else if (source instanceof Date) {\n    return new Date(source.getTime());\n  } else if (source instanceof RegExp) {\n    var flags = source.flags ||\n    // old browsers compatibility\n    [source.global ? 'g' : '', source.ignoreCase ? 'i' : '', source.multiline ? 'm' : '', source.sticky ? 'y' : '', source.unicode ? 'u' : ''].join('');\n    return new RegExp(source.source, flags);\n  }\n  if (circularReferenceChecker.hasAlreadyBeenSeen(source)) {\n    // remove circular references\n    return undefined;\n  } else if (Array.isArray(source)) {\n    var merged_1 = Array.isArray(destination) ? destination : [];\n    for (var i = 0; i < source.length; ++i) {\n      merged_1[i] = mergeInto(merged_1[i], source[i], circularReferenceChecker);\n    }\n    return merged_1;\n  }\n  var merged = getType(destination) === 'object' ? destination : {};\n  for (var key in source) {\n    if (Object.prototype.hasOwnProperty.call(source, key)) {\n      merged[key] = mergeInto(merged[key], source[key], circularReferenceChecker);\n    }\n  }\n  return merged;\n}\n/**\n * A simplistic implementation of a deep clone algorithm.\n * Caveats:\n * - It doesn't maintain prototype chains - don't use with instances of custom classes.\n * - It doesn't handle Map and Set\n */\nexport function deepClone(value) {\n  return mergeInto(undefined, value);\n}\nexport function combine() {\n  var sources = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    sources[_i] = arguments[_i];\n  }\n  var destination;\n  for (var _a = 0, sources_1 = sources; _a < sources_1.length; _a++) {\n    var source = sources_1[_a];\n    // Ignore any undefined or null sources.\n    if (source === undefined || source === null) {\n      continue;\n    }\n    destination = mergeInto(destination, source);\n  }\n  return destination;\n}\nfunction createCircularReferenceChecker() {\n  if (typeof WeakSet !== 'undefined') {\n    var set_1 = new WeakSet();\n    return {\n      hasAlreadyBeenSeen: function (value) {\n        var has = set_1.has(value);\n        if (!has) {\n          set_1.add(value);\n        }\n        return has;\n      }\n    };\n  }\n  var array = [];\n  return {\n    hasAlreadyBeenSeen: function (value) {\n      var has = array.indexOf(value) >= 0;\n      if (!has) {\n        array.push(value);\n      }\n      return has;\n    }\n  };\n}","map":{"version":3,"names":["getType","mergeInto","destination","source","circularReferenceChecker","createCircularReferenceChecker","undefined","Date","getTime","RegExp","flags","global","ignoreCase","multiline","sticky","unicode","join","hasAlreadyBeenSeen","Array","isArray","merged_1","i","length","merged","key","Object","prototype","hasOwnProperty","call","deepClone","value","combine","sources","_i","arguments","_a","sources_1","WeakSet","set_1","has","add","array","indexOf","push"],"sources":["D:\\edu'\\Spritle\\Spritle\\node_modules\\@datadog\\browser-core\\src\\tools\\mergeInto.ts"],"sourcesContent":["import { getType } from './utils/typeUtils'\n\ntype Merged<TDestination, TSource> =\n  // case 1 - source is undefined - return destination\n  TSource extends undefined\n    ? TDestination\n    : // case 2 - destination is undefined - return source\n      TDestination extends undefined\n      ? TSource\n      : // case 3 - source is an array - see if it merges or overwrites\n        TSource extends any[]\n        ? TDestination extends any[]\n          ? TDestination & TSource\n          : TSource\n        : // case 4 - source is an object - see if it merges or overwrites\n          TSource extends object\n          ? TDestination extends object\n            ? TDestination extends any[]\n              ? TSource\n              : TDestination & TSource\n            : TSource\n          : // case 5 - cannot merge - return source\n            TSource\n\n/**\n * Iterate over source and affect its sub values into destination, recursively.\n * If the source and destination can't be merged, return source.\n */\nexport function mergeInto<D, S>(\n  destination: D,\n  source: S,\n  circularReferenceChecker = createCircularReferenceChecker()\n): Merged<D, S> {\n  // ignore the source if it is undefined\n  if (source === undefined) {\n    return destination as Merged<D, S>\n  }\n\n  if (typeof source !== 'object' || source === null) {\n    // primitive values - just return source\n    return source as Merged<D, S>\n  } else if (source instanceof Date) {\n    return new Date(source.getTime()) as unknown as Merged<D, S>\n  } else if (source instanceof RegExp) {\n    const flags =\n      source.flags ||\n      // old browsers compatibility\n      [\n        source.global ? 'g' : '',\n        source.ignoreCase ? 'i' : '',\n        source.multiline ? 'm' : '',\n        source.sticky ? 'y' : '',\n        source.unicode ? 'u' : '',\n      ].join('')\n    return new RegExp(source.source, flags) as unknown as Merged<D, S>\n  }\n\n  if (circularReferenceChecker.hasAlreadyBeenSeen(source)) {\n    // remove circular references\n    return undefined as unknown as Merged<D, S>\n  } else if (Array.isArray(source)) {\n    const merged: any[] = Array.isArray(destination) ? destination : []\n    for (let i = 0; i < source.length; ++i) {\n      merged[i] = mergeInto(merged[i], source[i], circularReferenceChecker)\n    }\n    return merged as unknown as Merged<D, S>\n  }\n\n  const merged = getType(destination) === 'object' ? (destination as Record<any, any>) : {}\n  for (const key in source) {\n    if (Object.prototype.hasOwnProperty.call(source, key)) {\n      merged[key] = mergeInto(merged[key], source[key], circularReferenceChecker)\n    }\n  }\n  return merged as unknown as Merged<D, S>\n}\n\n/**\n * A simplistic implementation of a deep clone algorithm.\n * Caveats:\n * - It doesn't maintain prototype chains - don't use with instances of custom classes.\n * - It doesn't handle Map and Set\n */\nexport function deepClone<T>(value: T): T {\n  return mergeInto(undefined, value) as T\n}\n\ntype Combined<A, B> = A extends null ? B : B extends null ? A : Merged<A, B>\n\n/*\n * Performs a deep merge of objects and arrays.\n * - Arguments won't be mutated\n * - Object and arrays in the output value are de-referenced (\"deep cloned\")\n * - Arrays values are merged index by index\n * - Objects are merged by keys\n * - Values get replaced, unless undefined\n */\nexport function combine<A, B>(a: A, b: B): Combined<A, B>\nexport function combine<A, B, C>(a: A, b: B, c: C): Combined<Combined<A, B>, C>\nexport function combine<A, B, C, D>(a: A, b: B, c: C, d: D): Combined<Combined<Combined<A, B>, C>, D>\nexport function combine<A, B, C, D, E>(\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n  e: E\n): Combined<Combined<Combined<Combined<A, B>, C>, D>, E>\nexport function combine<A, B, C, D, E, F>(\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n  e: E,\n  f: F\n): Combined<Combined<Combined<Combined<Combined<A, B>, C>, D>, E>, F>\nexport function combine<A, B, C, D, E, F, G>(\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n  e: E,\n  f: F,\n  g: G\n): Combined<Combined<Combined<Combined<Combined<Combined<A, B>, C>, D>, E>, F>, G>\nexport function combine<A, B, C, D, E, F, G, H>(\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n  e: E,\n  f: F,\n  g: G,\n  h: H\n): Combined<Combined<Combined<Combined<Combined<Combined<Combined<A, B>, C>, D>, E>, F>, G>, H>\nexport function combine(...sources: any[]): unknown {\n  let destination: any\n\n  for (const source of sources) {\n    // Ignore any undefined or null sources.\n    if (source === undefined || source === null) {\n      continue\n    }\n\n    destination = mergeInto(destination, source)\n  }\n\n  return destination as unknown\n}\n\ninterface CircularReferenceChecker {\n  hasAlreadyBeenSeen(value: any): boolean\n}\n\nfunction createCircularReferenceChecker(): CircularReferenceChecker {\n  if (typeof WeakSet !== 'undefined') {\n    const set: WeakSet<any> = new WeakSet()\n    return {\n      hasAlreadyBeenSeen(value) {\n        const has = set.has(value)\n        if (!has) {\n          set.add(value)\n        }\n        return has\n      },\n    }\n  }\n  const array: any[] = []\n  return {\n    hasAlreadyBeenSeen(value) {\n      const has = array.indexOf(value) >= 0\n      if (!has) {\n        array.push(value)\n      }\n      return has\n    },\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}