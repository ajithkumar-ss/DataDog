{"ast":null,"code":"import { isPageExitReason, ONE_SECOND, clearTimeout, setTimeout } from '@datadog/browser-core';\nimport { buildReplayPayload } from './buildReplayPayload';\nimport { Segment } from './segment';\nexport var SEGMENT_DURATION_LIMIT = 30 * ONE_SECOND;\n/**\n * beacon payload max queue size implementation is 64kb\n * ensure that we leave room for logs, rum and potential other users\n */\nexport var SEGMENT_BYTES_LIMIT = 60000;\n// Segments are the main data structure for session replays. They contain context information used\n// for indexing or UI needs, and a list of records (RRWeb 'events', renamed to avoid confusing\n// namings). They are stored without any processing from the intake, and fetched one after the\n// other while a session is being replayed. Their encoding (deflate) are carefully crafted to allow\n// concatenating multiple segments together. Segments have a size overhead (metadata), so our goal is to\n// build segments containing as many records as possible while complying with the various flush\n// strategies to guarantee a good replay quality.\n//\n// When the recording starts, a segment is initially created.  The segment is flushed (finalized and\n// sent) based on various events (non-exhaustive list):\n//\n// * the page visibility change or becomes to unload\n// * the segment duration reaches a limit\n// * the encoded segment bytes count reaches a limit\n// * ...\n//\n// A segment cannot be created without its context.  If the RUM session ends and no session id is\n// available when creating a new segment, records will be ignored, until the session is renewed and\n// a new session id is available.\n//\n// Empty segments (segments with no record) aren't useful and should be ignored.\n//\n// To help investigate session replays issues, each segment is created with a \"creation reason\",\n// indicating why the session has been created.\nexport function startSegmentCollection(lifeCycle, configuration, sessionManager, viewContexts, httpRequest, encoder) {\n  return doStartSegmentCollection(lifeCycle, function () {\n    return computeSegmentContext(configuration.applicationId, sessionManager, viewContexts);\n  }, httpRequest, encoder);\n}\nexport function doStartSegmentCollection(lifeCycle, getSegmentContext, httpRequest, encoder) {\n  var state = {\n    status: 0 /* SegmentCollectionStatus.WaitingForInitialRecord */,\n    nextSegmentCreationReason: 'init'\n  };\n  var unsubscribeViewCreated = lifeCycle.subscribe(3 /* LifeCycleEventType.VIEW_CREATED */, function () {\n    flushSegment('view_change');\n  }).unsubscribe;\n  var unsubscribePageExited = lifeCycle.subscribe(11 /* LifeCycleEventType.PAGE_EXITED */, function (pageExitEvent) {\n    flushSegment(pageExitEvent.reason);\n  }).unsubscribe;\n  function flushSegment(flushReason) {\n    if (state.status === 1 /* SegmentCollectionStatus.SegmentPending */) {\n      state.segment.flush(function (metadata, encoderResult) {\n        var payload = buildReplayPayload(encoderResult.output, metadata, encoderResult.rawBytesCount);\n        if (isPageExitReason(flushReason)) {\n          httpRequest.sendOnExit(payload);\n        } else {\n          httpRequest.send(payload);\n        }\n      });\n      clearTimeout(state.expirationTimeoutId);\n    }\n    if (flushReason !== 'stop') {\n      state = {\n        status: 0 /* SegmentCollectionStatus.WaitingForInitialRecord */,\n        nextSegmentCreationReason: flushReason\n      };\n    } else {\n      state = {\n        status: 2 /* SegmentCollectionStatus.Stopped */\n      };\n    }\n  }\n  return {\n    addRecord: function (record) {\n      if (state.status === 2 /* SegmentCollectionStatus.Stopped */) {\n        return;\n      }\n      if (state.status === 0 /* SegmentCollectionStatus.WaitingForInitialRecord */) {\n        var context = getSegmentContext();\n        if (!context) {\n          return;\n        }\n        state = {\n          status: 1 /* SegmentCollectionStatus.SegmentPending */,\n          segment: new Segment(encoder, context, state.nextSegmentCreationReason),\n          expirationTimeoutId: setTimeout(function () {\n            flushSegment('segment_duration_limit');\n          }, SEGMENT_DURATION_LIMIT)\n        };\n      }\n      state.segment.addRecord(record, function (encodedBytesCount) {\n        if (encodedBytesCount > SEGMENT_BYTES_LIMIT) {\n          flushSegment('segment_bytes_limit');\n        }\n      });\n    },\n    stop: function () {\n      flushSegment('stop');\n      unsubscribeViewCreated();\n      unsubscribePageExited();\n    }\n  };\n}\nexport function computeSegmentContext(applicationId, sessionManager, viewContexts) {\n  var session = sessionManager.findTrackedSession();\n  var viewContext = viewContexts.findView();\n  if (!session || !viewContext) {\n    return undefined;\n  }\n  return {\n    application: {\n      id: applicationId\n    },\n    session: {\n      id: session.id\n    },\n    view: {\n      id: viewContext.id\n    }\n  };\n}\nexport function setSegmentBytesLimit(newSegmentBytesLimit) {\n  if (newSegmentBytesLimit === void 0) {\n    newSegmentBytesLimit = 60000;\n  }\n  SEGMENT_BYTES_LIMIT = newSegmentBytesLimit;\n}","map":{"version":3,"names":["isPageExitReason","ONE_SECOND","clearTimeout","setTimeout","buildReplayPayload","Segment","SEGMENT_DURATION_LIMIT","SEGMENT_BYTES_LIMIT","startSegmentCollection","lifeCycle","configuration","sessionManager","viewContexts","httpRequest","encoder","doStartSegmentCollection","computeSegmentContext","applicationId","getSegmentContext","state","status","nextSegmentCreationReason","unsubscribeViewCreated","subscribe","flushSegment","unsubscribe","unsubscribePageExited","pageExitEvent","reason","flushReason","segment","flush","metadata","encoderResult","payload","output","rawBytesCount","sendOnExit","send","expirationTimeoutId","addRecord","record","context","encodedBytesCount","stop","session","findTrackedSession","viewContext","findView","undefined","application","id","view","setSegmentBytesLimit","newSegmentBytesLimit"],"sources":["D:\\edu'\\Spritle\\spritle\\node_modules\\@datadog\\browser-rum\\src\\domain\\segmentCollection\\segmentCollection.ts"],"sourcesContent":["import type { DeflateEncoder, HttpRequest, TimeoutId } from '@datadog/browser-core'\nimport { isPageExitReason, ONE_SECOND, clearTimeout, setTimeout } from '@datadog/browser-core'\nimport type { LifeCycle, ViewContexts, RumSessionManager, RumConfiguration } from '@datadog/browser-rum-core'\nimport { LifeCycleEventType } from '@datadog/browser-rum-core'\nimport type { BrowserRecord, CreationReason, SegmentContext } from '../../types'\nimport { buildReplayPayload } from './buildReplayPayload'\nimport type { FlushReason } from './segment'\nimport { Segment } from './segment'\n\nexport const SEGMENT_DURATION_LIMIT = 30 * ONE_SECOND\n/**\n * beacon payload max queue size implementation is 64kb\n * ensure that we leave room for logs, rum and potential other users\n */\nexport let SEGMENT_BYTES_LIMIT = 60_000\n\n// Segments are the main data structure for session replays. They contain context information used\n// for indexing or UI needs, and a list of records (RRWeb 'events', renamed to avoid confusing\n// namings). They are stored without any processing from the intake, and fetched one after the\n// other while a session is being replayed. Their encoding (deflate) are carefully crafted to allow\n// concatenating multiple segments together. Segments have a size overhead (metadata), so our goal is to\n// build segments containing as many records as possible while complying with the various flush\n// strategies to guarantee a good replay quality.\n//\n// When the recording starts, a segment is initially created.  The segment is flushed (finalized and\n// sent) based on various events (non-exhaustive list):\n//\n// * the page visibility change or becomes to unload\n// * the segment duration reaches a limit\n// * the encoded segment bytes count reaches a limit\n// * ...\n//\n// A segment cannot be created without its context.  If the RUM session ends and no session id is\n// available when creating a new segment, records will be ignored, until the session is renewed and\n// a new session id is available.\n//\n// Empty segments (segments with no record) aren't useful and should be ignored.\n//\n// To help investigate session replays issues, each segment is created with a \"creation reason\",\n// indicating why the session has been created.\n\nexport function startSegmentCollection(\n  lifeCycle: LifeCycle,\n  configuration: RumConfiguration,\n  sessionManager: RumSessionManager,\n  viewContexts: ViewContexts,\n  httpRequest: HttpRequest,\n  encoder: DeflateEncoder\n) {\n  return doStartSegmentCollection(\n    lifeCycle,\n    () => computeSegmentContext(configuration.applicationId, sessionManager, viewContexts),\n    httpRequest,\n    encoder\n  )\n}\n\nconst enum SegmentCollectionStatus {\n  WaitingForInitialRecord,\n  SegmentPending,\n  Stopped,\n}\ntype SegmentCollectionState =\n  | {\n      status: SegmentCollectionStatus.WaitingForInitialRecord\n      nextSegmentCreationReason: CreationReason\n    }\n  | {\n      status: SegmentCollectionStatus.SegmentPending\n      segment: Segment\n      expirationTimeoutId: TimeoutId\n    }\n  | {\n      status: SegmentCollectionStatus.Stopped\n    }\n\nexport function doStartSegmentCollection(\n  lifeCycle: LifeCycle,\n  getSegmentContext: () => SegmentContext | undefined,\n  httpRequest: HttpRequest,\n  encoder: DeflateEncoder\n) {\n  let state: SegmentCollectionState = {\n    status: SegmentCollectionStatus.WaitingForInitialRecord,\n    nextSegmentCreationReason: 'init',\n  }\n\n  const { unsubscribe: unsubscribeViewCreated } = lifeCycle.subscribe(LifeCycleEventType.VIEW_CREATED, () => {\n    flushSegment('view_change')\n  })\n\n  const { unsubscribe: unsubscribePageExited } = lifeCycle.subscribe(\n    LifeCycleEventType.PAGE_EXITED,\n    (pageExitEvent) => {\n      flushSegment(pageExitEvent.reason as FlushReason)\n    }\n  )\n\n  function flushSegment(flushReason: FlushReason) {\n    if (state.status === SegmentCollectionStatus.SegmentPending) {\n      state.segment.flush((metadata, encoderResult) => {\n        const payload = buildReplayPayload(encoderResult.output, metadata, encoderResult.rawBytesCount)\n\n        if (isPageExitReason(flushReason)) {\n          httpRequest.sendOnExit(payload)\n        } else {\n          httpRequest.send(payload)\n        }\n      })\n      clearTimeout(state.expirationTimeoutId)\n    }\n\n    if (flushReason !== 'stop') {\n      state = {\n        status: SegmentCollectionStatus.WaitingForInitialRecord,\n        nextSegmentCreationReason: flushReason,\n      }\n    } else {\n      state = {\n        status: SegmentCollectionStatus.Stopped,\n      }\n    }\n  }\n\n  return {\n    addRecord: (record: BrowserRecord) => {\n      if (state.status === SegmentCollectionStatus.Stopped) {\n        return\n      }\n\n      if (state.status === SegmentCollectionStatus.WaitingForInitialRecord) {\n        const context = getSegmentContext()\n        if (!context) {\n          return\n        }\n\n        state = {\n          status: SegmentCollectionStatus.SegmentPending,\n          segment: new Segment(encoder, context, state.nextSegmentCreationReason),\n          expirationTimeoutId: setTimeout(() => {\n            flushSegment('segment_duration_limit')\n          }, SEGMENT_DURATION_LIMIT),\n        }\n      }\n\n      state.segment.addRecord(record, (encodedBytesCount) => {\n        if (encodedBytesCount > SEGMENT_BYTES_LIMIT) {\n          flushSegment('segment_bytes_limit')\n        }\n      })\n    },\n\n    stop: () => {\n      flushSegment('stop')\n      unsubscribeViewCreated()\n      unsubscribePageExited()\n    },\n  }\n}\n\nexport function computeSegmentContext(\n  applicationId: string,\n  sessionManager: RumSessionManager,\n  viewContexts: ViewContexts\n) {\n  const session = sessionManager.findTrackedSession()\n  const viewContext = viewContexts.findView()\n  if (!session || !viewContext) {\n    return undefined\n  }\n  return {\n    application: {\n      id: applicationId,\n    },\n    session: {\n      id: session.id,\n    },\n    view: {\n      id: viewContext.id,\n    },\n  }\n}\n\nexport function setSegmentBytesLimit(newSegmentBytesLimit = 60_000) {\n  SEGMENT_BYTES_LIMIT = newSegmentBytesLimit\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}