{"ast":null,"code":"import { isExperimentalFeatureEnabled, ExperimentalFeature } from '../tools/experimentalFeatures';\nimport { Observable } from '../tools/observable';\nimport { objectValues, includes } from '../tools/utils/polyfills';\nimport { noop } from '../tools/utils/functionUtils';\nimport { addEventListeners, addEventListener, DOM_EVENT } from './addEventListener';\nexport var PageExitReason = {\n  HIDDEN: 'visibility_hidden',\n  UNLOADING: 'before_unload',\n  PAGEHIDE: 'page_hide',\n  FROZEN: 'page_frozen'\n};\nexport function createPageExitObservable(configuration) {\n  return new Observable(function (observable) {\n    var pagehideEnabled = isExperimentalFeatureEnabled(ExperimentalFeature.PAGEHIDE);\n    var stopListeners = addEventListeners(configuration, window, [DOM_EVENT.VISIBILITY_CHANGE, DOM_EVENT.FREEZE, DOM_EVENT.PAGE_HIDE], function (event) {\n      if (event.type === DOM_EVENT.PAGE_HIDE && pagehideEnabled) {\n        /**\n         * Only event that detect page unload events while being compatible with the back/forward cache (bfcache)\n         */\n        observable.notify({\n          reason: PageExitReason.PAGEHIDE\n        });\n      } else if (event.type === DOM_EVENT.VISIBILITY_CHANGE && document.visibilityState === 'hidden') {\n        /**\n         * Only event that guarantee to fire on mobile devices when the page transitions to background state\n         * (e.g. when user switches to a different application, goes to homescreen, etc), or is being unloaded.\n         */\n        observable.notify({\n          reason: PageExitReason.HIDDEN\n        });\n      } else if (event.type === DOM_EVENT.FREEZE) {\n        /**\n         * After transitioning in background a tab can be freezed to preserve resources. (cf: https://developer.chrome.com/blog/page-lifecycle-api)\n         * Allow to collect events happening between hidden and frozen state.\n         */\n        observable.notify({\n          reason: PageExitReason.FROZEN\n        });\n      }\n    }, {\n      capture: true\n    }).stop;\n    var stopBeforeUnloadListener = noop;\n    if (!pagehideEnabled) {\n      stopBeforeUnloadListener = addEventListener(configuration, window, DOM_EVENT.BEFORE_UNLOAD, function () {\n        observable.notify({\n          reason: PageExitReason.UNLOADING\n        });\n      }).stop;\n    }\n    return function () {\n      stopListeners();\n      stopBeforeUnloadListener();\n    };\n  });\n}\nexport function isPageExitReason(reason) {\n  return includes(objectValues(PageExitReason), reason);\n}","map":{"version":3,"names":["isExperimentalFeatureEnabled","ExperimentalFeature","Observable","objectValues","includes","noop","addEventListeners","addEventListener","DOM_EVENT","PageExitReason","HIDDEN","UNLOADING","PAGEHIDE","FROZEN","createPageExitObservable","configuration","observable","pagehideEnabled","stopListeners","window","VISIBILITY_CHANGE","FREEZE","PAGE_HIDE","event","type","notify","reason","document","visibilityState","capture","stop","stopBeforeUnloadListener","BEFORE_UNLOAD","isPageExitReason"],"sources":["D:\\edu'\\Spritle\\spritle\\node_modules\\@datadog\\browser-core\\src\\browser\\pageExitObservable.ts"],"sourcesContent":["import { isExperimentalFeatureEnabled, ExperimentalFeature } from '../tools/experimentalFeatures'\nimport { Observable } from '../tools/observable'\nimport { objectValues, includes } from '../tools/utils/polyfills'\nimport { noop } from '../tools/utils/functionUtils'\nimport type { Configuration } from '../domain/configuration'\nimport { addEventListeners, addEventListener, DOM_EVENT } from './addEventListener'\n\nexport const PageExitReason = {\n  HIDDEN: 'visibility_hidden',\n  UNLOADING: 'before_unload',\n  PAGEHIDE: 'page_hide',\n  FROZEN: 'page_frozen',\n} as const\n\nexport type PageExitReason = (typeof PageExitReason)[keyof typeof PageExitReason]\n\nexport interface PageExitEvent {\n  reason: PageExitReason\n}\n\nexport function createPageExitObservable(configuration: Configuration): Observable<PageExitEvent> {\n  return new Observable<PageExitEvent>((observable) => {\n    const pagehideEnabled = isExperimentalFeatureEnabled(ExperimentalFeature.PAGEHIDE)\n    const { stop: stopListeners } = addEventListeners(\n      configuration,\n      window,\n      [DOM_EVENT.VISIBILITY_CHANGE, DOM_EVENT.FREEZE, DOM_EVENT.PAGE_HIDE],\n      (event) => {\n        if (event.type === DOM_EVENT.PAGE_HIDE && pagehideEnabled) {\n          /**\n           * Only event that detect page unload events while being compatible with the back/forward cache (bfcache)\n           */\n          observable.notify({ reason: PageExitReason.PAGEHIDE })\n        } else if (event.type === DOM_EVENT.VISIBILITY_CHANGE && document.visibilityState === 'hidden') {\n          /**\n           * Only event that guarantee to fire on mobile devices when the page transitions to background state\n           * (e.g. when user switches to a different application, goes to homescreen, etc), or is being unloaded.\n           */\n          observable.notify({ reason: PageExitReason.HIDDEN })\n        } else if (event.type === DOM_EVENT.FREEZE) {\n          /**\n           * After transitioning in background a tab can be freezed to preserve resources. (cf: https://developer.chrome.com/blog/page-lifecycle-api)\n           * Allow to collect events happening between hidden and frozen state.\n           */\n          observable.notify({ reason: PageExitReason.FROZEN })\n        }\n      },\n      { capture: true }\n    )\n\n    let stopBeforeUnloadListener = noop\n    if (!pagehideEnabled) {\n      stopBeforeUnloadListener = addEventListener(configuration, window, DOM_EVENT.BEFORE_UNLOAD, () => {\n        observable.notify({ reason: PageExitReason.UNLOADING })\n      }).stop\n    }\n\n    return () => {\n      stopListeners()\n      stopBeforeUnloadListener()\n    }\n  })\n}\n\nexport function isPageExitReason(reason: string | undefined): reason is PageExitReason {\n  return includes(objectValues(PageExitReason), reason)\n}\n"],"mappings":"AAAA,SAASA,4BAA4B,EAAEC,mBAAmB,QAAQ,+BAA+B;AACjG,SAASC,UAAU,QAAQ,qBAAqB;AAChD,SAASC,YAAY,EAAEC,QAAQ,QAAQ,0BAA0B;AACjE,SAASC,IAAI,QAAQ,8BAA8B;AAEnD,SAASC,iBAAiB,EAAEC,gBAAgB,EAAEC,SAAS,QAAQ,oBAAoB;AAEnF,OAAO,IAAMC,cAAc,GAAG;EAC5BC,MAAM,EAAE,mBAAmB;EAC3BC,SAAS,EAAE,eAAe;EAC1BC,QAAQ,EAAE,WAAW;EACrBC,MAAM,EAAE;CACA;AAQV,OAAM,SAAUC,wBAAwBA,CAACC,aAA4B;EACnE,OAAO,IAAIb,UAAU,CAAgB,UAACc,UAAU;IAC9C,IAAMC,eAAe,GAAGjB,4BAA4B,CAACC,mBAAmB,CAACW,QAAQ,CAAC;IAC1E,IAAMM,aAAa,GAAKZ,iBAAiB,CAC/CS,aAAa,EACbI,MAAM,EACN,CAACX,SAAS,CAACY,iBAAiB,EAAEZ,SAAS,CAACa,MAAM,EAAEb,SAAS,CAACc,SAAS,CAAC,EACpE,UAACC,KAAK;MACJ,IAAIA,KAAK,CAACC,IAAI,KAAKhB,SAAS,CAACc,SAAS,IAAIL,eAAe,EAAE;QACzD;;;QAGAD,UAAU,CAACS,MAAM,CAAC;UAAEC,MAAM,EAAEjB,cAAc,CAACG;QAAQ,CAAE,CAAC;MACxD,CAAC,MAAM,IAAIW,KAAK,CAACC,IAAI,KAAKhB,SAAS,CAACY,iBAAiB,IAAIO,QAAQ,CAACC,eAAe,KAAK,QAAQ,EAAE;QAC9F;;;;QAIAZ,UAAU,CAACS,MAAM,CAAC;UAAEC,MAAM,EAAEjB,cAAc,CAACC;QAAM,CAAE,CAAC;MACtD,CAAC,MAAM,IAAIa,KAAK,CAACC,IAAI,KAAKhB,SAAS,CAACa,MAAM,EAAE;QAC1C;;;;QAIAL,UAAU,CAACS,MAAM,CAAC;UAAEC,MAAM,EAAEjB,cAAc,CAACI;QAAM,CAAE,CAAC;MACtD;IACF,CAAC,EACD;MAAEgB,OAAO,EAAE;IAAI,CAAE,CAClB,CAAAC,IAzB0B;IA2B3B,IAAIC,wBAAwB,GAAG1B,IAAI;IACnC,IAAI,CAACY,eAAe,EAAE;MACpBc,wBAAwB,GAAGxB,gBAAgB,CAACQ,aAAa,EAAEI,MAAM,EAAEX,SAAS,CAACwB,aAAa,EAAE;QAC1FhB,UAAU,CAACS,MAAM,CAAC;UAAEC,MAAM,EAAEjB,cAAc,CAACE;QAAS,CAAE,CAAC;MACzD,CAAC,CAAC,CAACmB,IAAI;IACT;IAEA,OAAO;MACLZ,aAAa,EAAE;MACfa,wBAAwB,EAAE;IAC5B,CAAC;EACH,CAAC,CAAC;AACJ;AAEA,OAAM,SAAUE,gBAAgBA,CAACP,MAA0B;EACzD,OAAOtB,QAAQ,CAACD,YAAY,CAACM,cAAc,CAAC,EAAEiB,MAAM,CAAC;AACvD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}