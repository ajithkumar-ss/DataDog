{"ast":null,"code":"import { addTelemetryUsage, timeStampToClocks, isExperimentalFeatureEnabled, ExperimentalFeature, assign, createContextManager, deepClone, makePublicApi, monitor, clocksNow, callMonitored, createHandlingStack, checkUser, sanitizeUser, sanitize, createIdentityEncoder, createCustomerDataTrackerManager, storeContextManager, displayAlreadyInitializedError, createTrackingConsentState } from '@datadog/browser-core';\nimport { buildCommonContext } from '../domain/contexts/commonContext';\nimport { createPreStartStrategy } from './preStartRum';\nvar RUM_STORAGE_KEY = 'rum';\nexport function makeRumPublicApi(startRumImpl, recorderApi, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var customerDataTrackerManager = createCustomerDataTrackerManager(0 /* CustomerDataCompressionStatus.Unknown */);\n  var globalContextManager = createContextManager(customerDataTrackerManager.getOrCreateTracker(2 /* CustomerDataType.GlobalContext */));\n  var userContextManager = createContextManager(customerDataTrackerManager.getOrCreateTracker(1 /* CustomerDataType.User */));\n  var trackingConsentState = createTrackingConsentState();\n  function getCommonContext() {\n    return buildCommonContext(globalContextManager, userContextManager, recorderApi);\n  }\n  var strategy = createPreStartStrategy(options, getCommonContext, trackingConsentState, function (initConfiguration, configuration, deflateWorker, initialViewOptions) {\n    if (isExperimentalFeatureEnabled(ExperimentalFeature.CUSTOM_VITALS)) {\n      /**\n       * Start a custom duration vital\n       * stored in @vital.custom.<name>\n       *\n       * @param name name of the custom vital\n       * @param options.context custom context attached to the vital\n       * @param options.startTime epoch timestamp of the start of the custom vital (if not set, will use current time)\n       */\n      ;\n      rumPublicApi.startDurationVital = monitor(function (name, options) {\n        strategy.startDurationVital({\n          name: sanitize(name),\n          startClocks: (options === null || options === void 0 ? void 0 : options.startTime) ? timeStampToClocks(options.startTime) : clocksNow(),\n          context: sanitize(options === null || options === void 0 ? void 0 : options.context)\n        });\n      });\n      rumPublicApi.stopDurationVital = monitor(function (name, options) {\n        strategy.stopDurationVital({\n          name: sanitize(name),\n          stopClocks: (options === null || options === void 0 ? void 0 : options.stopTime) ? timeStampToClocks(options.stopTime) : clocksNow(),\n          context: sanitize(options === null || options === void 0 ? void 0 : options.context)\n        });\n      });\n    }\n    if (initConfiguration.storeContextsAcrossPages) {\n      storeContextManager(configuration, globalContextManager, RUM_STORAGE_KEY, 2 /* CustomerDataType.GlobalContext */);\n      storeContextManager(configuration, userContextManager, RUM_STORAGE_KEY, 1 /* CustomerDataType.User */);\n    }\n    customerDataTrackerManager.setCompressionStatus(deflateWorker ? 1 /* CustomerDataCompressionStatus.Enabled */ : 2 /* CustomerDataCompressionStatus.Disabled */);\n    var startRumResult = startRumImpl(initConfiguration, configuration, recorderApi, customerDataTrackerManager, getCommonContext, initialViewOptions, deflateWorker && options.createDeflateEncoder ? function (streamId) {\n      return options.createDeflateEncoder(configuration, deflateWorker, streamId);\n    } : createIdentityEncoder, trackingConsentState);\n    recorderApi.onRumStart(startRumResult.lifeCycle, configuration, startRumResult.session, startRumResult.viewContexts, deflateWorker);\n    strategy = createPostStartStrategy(initConfiguration, startRumResult);\n    return startRumResult;\n  });\n  var startView = monitor(function (options) {\n    var sanitizedOptions = typeof options === 'object' ? options : {\n      name: options\n    };\n    strategy.startView(sanitizedOptions);\n  });\n  var rumPublicApi = makePublicApi({\n    init: monitor(function (initConfiguration) {\n      return strategy.init(initConfiguration);\n    }),\n    /**\n     * Set the tracking consent of the current user.\n     *\n     * @param {\"granted\" | \"not-granted\"} trackingConsent The user tracking consent\n     *\n     * Data will be sent only if it is set to \"granted\". This value won't be stored by the library\n     * across page loads: you will need to call this method or set the appropriate `trackingConsent`\n     * field in the init() method at each page load.\n     *\n     * If this method is called before the init() method, the provided value will take precedence\n     * over the one provided as initialization parameter.\n     */\n    setTrackingConsent: monitor(function (trackingConsent) {\n      trackingConsentState.update(trackingConsent);\n      addTelemetryUsage({\n        feature: 'set-tracking-consent',\n        tracking_consent: trackingConsent\n      });\n    }),\n    setGlobalContextProperty: monitor(function (key, value) {\n      return globalContextManager.setContextProperty(key, value);\n    }),\n    removeGlobalContextProperty: monitor(function (key) {\n      return globalContextManager.removeContextProperty(key);\n    }),\n    getGlobalContext: monitor(function () {\n      return globalContextManager.getContext();\n    }),\n    setGlobalContext: monitor(function (context) {\n      return globalContextManager.setContext(context);\n    }),\n    clearGlobalContext: monitor(function () {\n      return globalContextManager.clearContext();\n    }),\n    getInternalContext: monitor(function (startTime) {\n      return strategy.getInternalContext(startTime);\n    }),\n    getInitConfiguration: monitor(function () {\n      return deepClone(strategy.initConfiguration);\n    }),\n    addAction: monitor(function (name, context) {\n      strategy.addAction({\n        name: sanitize(name),\n        context: sanitize(context),\n        startClocks: clocksNow(),\n        type: \"custom\" /* ActionType.CUSTOM */\n      });\n    }),\n    addError: function (error, context) {\n      var handlingStack = createHandlingStack();\n      callMonitored(function () {\n        strategy.addError({\n          error: error,\n          // Do not sanitize error here, it is needed unserialized by computeRawError()\n          handlingStack: handlingStack,\n          context: sanitize(context),\n          startClocks: clocksNow()\n        });\n      });\n    },\n    /**\n     * Add a custom timing relative to the start of the current view,\n     * stored in `@view.custom_timings.<timing_name>`\n     *\n     * @param name Name of the custom timing\n     * @param [time] Epoch timestamp of the custom timing (if not set, will use current time)\n     *\n     * Note: passing a relative time is discouraged since it is actually used as-is but displayed relative to the view start.\n     * We currently don't provide a way to retrieve the view start time, so it can be challenging to provide a timing relative to the view start.\n     * see https://github.com/DataDog/browser-sdk/issues/2552\n     */\n    addTiming: monitor(function (name, time) {\n      // TODO: next major decide to drop relative time support or update its behaviour\n      strategy.addTiming(sanitize(name), time);\n    }),\n    setUser: monitor(function (newUser) {\n      if (checkUser(newUser)) {\n        userContextManager.setContext(sanitizeUser(newUser));\n      }\n    }),\n    getUser: monitor(function () {\n      return userContextManager.getContext();\n    }),\n    setUserProperty: monitor(function (key, property) {\n      var _a;\n      var sanitizedProperty = sanitizeUser((_a = {}, _a[key] = property, _a))[key];\n      userContextManager.setContextProperty(key, sanitizedProperty);\n    }),\n    removeUserProperty: monitor(function (key) {\n      return userContextManager.removeContextProperty(key);\n    }),\n    clearUser: monitor(function () {\n      return userContextManager.clearContext();\n    }),\n    startView: startView,\n    stopSession: monitor(function () {\n      strategy.stopSession();\n      addTelemetryUsage({\n        feature: 'stop-session'\n      });\n    }),\n    /**\n     * Add a feature flag evaluation,\n     * stored in `@feature_flags.<feature_flag_key>`\n     *\n     * @param {string} key The key of the feature flag.\n     * @param {any} value The value of the feature flag.\n     *\n     * We recommend enabling the intake request compression when using feature flags `compressIntakeRequests: true`.\n     * For more information see the full [feature flag tracking guide](https://docs.datadoghq.com/real_user_monitoring/feature_flag_tracking/).\n     */\n    addFeatureFlagEvaluation: monitor(function (key, value) {\n      strategy.addFeatureFlagEvaluation(sanitize(key), sanitize(value));\n    }),\n    getSessionReplayLink: monitor(function () {\n      return recorderApi.getSessionReplayLink();\n    }),\n    startSessionReplayRecording: monitor(function () {\n      recorderApi.start();\n      addTelemetryUsage({\n        feature: 'start-session-replay-recording'\n      });\n    }),\n    stopSessionReplayRecording: monitor(function () {\n      return recorderApi.stop();\n    })\n  });\n  return rumPublicApi;\n}\nfunction createPostStartStrategy(initConfiguration, startRumResult) {\n  return assign({\n    init: function (initConfiguration) {\n      displayAlreadyInitializedError('DD_RUM', initConfiguration);\n    },\n    initConfiguration: initConfiguration\n  }, startRumResult);\n}","map":{"version":3,"names":["addTelemetryUsage","timeStampToClocks","isExperimentalFeatureEnabled","ExperimentalFeature","assign","createContextManager","deepClone","makePublicApi","monitor","clocksNow","callMonitored","createHandlingStack","checkUser","sanitizeUser","sanitize","createIdentityEncoder","createCustomerDataTrackerManager","storeContextManager","displayAlreadyInitializedError","createTrackingConsentState","buildCommonContext","createPreStartStrategy","RUM_STORAGE_KEY","makeRumPublicApi","startRumImpl","recorderApi","options","customerDataTrackerManager","globalContextManager","getOrCreateTracker","userContextManager","trackingConsentState","getCommonContext","strategy","initConfiguration","configuration","deflateWorker","initialViewOptions","CUSTOM_VITALS","rumPublicApi","startDurationVital","name","startClocks","startTime","context","stopDurationVital","stopClocks","stopTime","storeContextsAcrossPages","setCompressionStatus","startRumResult","createDeflateEncoder","streamId","onRumStart","lifeCycle","session","viewContexts","createPostStartStrategy","startView","sanitizedOptions","init","setTrackingConsent","trackingConsent","update","feature","tracking_consent","setGlobalContextProperty","key","value","setContextProperty","removeGlobalContextProperty","removeContextProperty","getGlobalContext","getContext","setGlobalContext","setContext","clearGlobalContext","clearContext","getInternalContext","getInitConfiguration","addAction","type","addError","error","handlingStack","addTiming","time","setUser","newUser","getUser","setUserProperty","property","sanitizedProperty","_a","removeUserProperty","clearUser","stopSession","addFeatureFlagEvaluation","getSessionReplayLink","startSessionReplayRecording","start","stopSessionReplayRecording","stop"],"sources":["D:\\edu'\\Spritle\\spritle\\node_modules\\@datadog\\browser-rum-core\\src\\boot\\rumPublicApi.ts"],"sourcesContent":["import type {\n  Context,\n  TimeStamp,\n  RelativeTime,\n  User,\n  DeflateWorker,\n  DeflateEncoderStreamId,\n  DeflateEncoder,\n  TrackingConsent,\n} from '@datadog/browser-core'\nimport {\n  addTelemetryUsage,\n  timeStampToClocks,\n  isExperimentalFeatureEnabled,\n  ExperimentalFeature,\n  CustomerDataType,\n  assign,\n  createContextManager,\n  deepClone,\n  makePublicApi,\n  monitor,\n  clocksNow,\n  callMonitored,\n  createHandlingStack,\n  checkUser,\n  sanitizeUser,\n  sanitize,\n  createIdentityEncoder,\n  CustomerDataCompressionStatus,\n  createCustomerDataTrackerManager,\n  storeContextManager,\n  displayAlreadyInitializedError,\n  createTrackingConsentState,\n} from '@datadog/browser-core'\nimport type { LifeCycle } from '../domain/lifeCycle'\nimport type { ViewContexts } from '../domain/contexts/viewContexts'\nimport type { RumSessionManager } from '../domain/rumSessionManager'\nimport type { ReplayStats } from '../rawRumEvent.types'\nimport { ActionType } from '../rawRumEvent.types'\nimport type { RumConfiguration, RumInitConfiguration } from '../domain/configuration'\nimport type { ViewOptions } from '../domain/view/trackViews'\nimport { buildCommonContext } from '../domain/contexts/commonContext'\nimport { createPreStartStrategy } from './preStartRum'\nimport type { StartRum, StartRumResult } from './startRum'\n\nexport type RumPublicApi = ReturnType<typeof makeRumPublicApi>\n\nexport interface RecorderApi {\n  start: () => void\n  stop: () => void\n  onRumStart: (\n    lifeCycle: LifeCycle,\n    configuration: RumConfiguration,\n    sessionManager: RumSessionManager,\n    viewContexts: ViewContexts,\n    deflateWorker: DeflateWorker | undefined\n  ) => void\n  isRecording: () => boolean\n  getReplayStats: (viewId: string) => ReplayStats | undefined\n  getSessionReplayLink: () => string | undefined\n}\n\nexport interface RumPublicApiOptions {\n  ignoreInitIfSyntheticsWillInjectRum?: boolean\n  startDeflateWorker?: (\n    configuration: RumConfiguration,\n    source: string,\n    onInitializationFailure: () => void\n  ) => DeflateWorker | undefined\n  createDeflateEncoder?: (\n    configuration: RumConfiguration,\n    worker: DeflateWorker,\n    streamId: DeflateEncoderStreamId\n  ) => DeflateEncoder\n}\n\nconst RUM_STORAGE_KEY = 'rum'\n\nexport interface Strategy {\n  init: (initConfiguration: RumInitConfiguration) => void\n  initConfiguration: RumInitConfiguration | undefined\n  getInternalContext: StartRumResult['getInternalContext']\n  stopSession: StartRumResult['stopSession']\n  addTiming: StartRumResult['addTiming']\n  startView: StartRumResult['startView']\n  addAction: StartRumResult['addAction']\n  addError: StartRumResult['addError']\n  addFeatureFlagEvaluation: StartRumResult['addFeatureFlagEvaluation']\n  startDurationVital: StartRumResult['startDurationVital']\n  stopDurationVital: StartRumResult['stopDurationVital']\n}\n\nexport function makeRumPublicApi(startRumImpl: StartRum, recorderApi: RecorderApi, options: RumPublicApiOptions = {}) {\n  const customerDataTrackerManager = createCustomerDataTrackerManager(CustomerDataCompressionStatus.Unknown)\n  const globalContextManager = createContextManager(\n    customerDataTrackerManager.getOrCreateTracker(CustomerDataType.GlobalContext)\n  )\n  const userContextManager = createContextManager(customerDataTrackerManager.getOrCreateTracker(CustomerDataType.User))\n  const trackingConsentState = createTrackingConsentState()\n\n  function getCommonContext() {\n    return buildCommonContext(globalContextManager, userContextManager, recorderApi)\n  }\n\n  let strategy = createPreStartStrategy(\n    options,\n    getCommonContext,\n    trackingConsentState,\n\n    (initConfiguration, configuration, deflateWorker, initialViewOptions) => {\n      if (isExperimentalFeatureEnabled(ExperimentalFeature.CUSTOM_VITALS)) {\n        /**\n         * Start a custom duration vital\n         * stored in @vital.custom.<name>\n         *\n         * @param name name of the custom vital\n         * @param options.context custom context attached to the vital\n         * @param options.startTime epoch timestamp of the start of the custom vital (if not set, will use current time)\n         */\n        ;(rumPublicApi as any).startDurationVital = monitor(\n          (name: string, options?: { context?: object; startTime?: number }) => {\n            strategy.startDurationVital({\n              name: sanitize(name)!,\n              startClocks: options?.startTime ? timeStampToClocks(options.startTime as TimeStamp) : clocksNow(),\n              context: sanitize(options?.context) as Context,\n            })\n          }\n        )\n\n        /**\n         * Stop a custom duration vital\n         * stored in @vital.custom.<name>\n         *\n         * @param name name of the custom vital\n         * @param options.context custom context attached to the vital\n         * @param options.stopTime epoch timestamp of the stop of the custom vital (if not set, will use current time)\n         */\n        ;(rumPublicApi as any).stopDurationVital = monitor(\n          (name: string, options?: { context?: object; stopTime?: number }) => {\n            strategy.stopDurationVital({\n              name: sanitize(name)!,\n              stopClocks: options?.stopTime ? timeStampToClocks(options.stopTime as TimeStamp) : clocksNow(),\n              context: sanitize(options?.context) as Context,\n            })\n          }\n        )\n      }\n\n      if (initConfiguration.storeContextsAcrossPages) {\n        storeContextManager(configuration, globalContextManager, RUM_STORAGE_KEY, CustomerDataType.GlobalContext)\n        storeContextManager(configuration, userContextManager, RUM_STORAGE_KEY, CustomerDataType.User)\n      }\n\n      customerDataTrackerManager.setCompressionStatus(\n        deflateWorker ? CustomerDataCompressionStatus.Enabled : CustomerDataCompressionStatus.Disabled\n      )\n\n      const startRumResult = startRumImpl(\n        initConfiguration,\n        configuration,\n        recorderApi,\n        customerDataTrackerManager,\n        getCommonContext,\n        initialViewOptions,\n        deflateWorker && options.createDeflateEncoder\n          ? (streamId) => options.createDeflateEncoder!(configuration, deflateWorker, streamId)\n          : createIdentityEncoder,\n        trackingConsentState\n      )\n\n      recorderApi.onRumStart(\n        startRumResult.lifeCycle,\n        configuration,\n        startRumResult.session,\n        startRumResult.viewContexts,\n        deflateWorker\n      )\n\n      strategy = createPostStartStrategy(initConfiguration, startRumResult)\n\n      return startRumResult\n    }\n  )\n\n  const startView: {\n    (name?: string): void\n    (options: ViewOptions): void\n  } = monitor((options?: string | ViewOptions) => {\n    const sanitizedOptions = typeof options === 'object' ? options : { name: options }\n    strategy.startView(sanitizedOptions)\n  })\n  const rumPublicApi = makePublicApi({\n    init: monitor((initConfiguration: RumInitConfiguration) => strategy.init(initConfiguration)),\n\n    /**\n     * Set the tracking consent of the current user.\n     *\n     * @param {\"granted\" | \"not-granted\"} trackingConsent The user tracking consent\n     *\n     * Data will be sent only if it is set to \"granted\". This value won't be stored by the library\n     * across page loads: you will need to call this method or set the appropriate `trackingConsent`\n     * field in the init() method at each page load.\n     *\n     * If this method is called before the init() method, the provided value will take precedence\n     * over the one provided as initialization parameter.\n     */\n    setTrackingConsent: monitor((trackingConsent: TrackingConsent) => {\n      trackingConsentState.update(trackingConsent)\n      addTelemetryUsage({ feature: 'set-tracking-consent', tracking_consent: trackingConsent })\n    }),\n\n    setGlobalContextProperty: monitor((key, value) => globalContextManager.setContextProperty(key, value)),\n\n    removeGlobalContextProperty: monitor((key) => globalContextManager.removeContextProperty(key)),\n\n    getGlobalContext: monitor(() => globalContextManager.getContext()),\n\n    setGlobalContext: monitor((context) => globalContextManager.setContext(context)),\n\n    clearGlobalContext: monitor(() => globalContextManager.clearContext()),\n\n    getInternalContext: monitor((startTime?: number) => strategy.getInternalContext(startTime)),\n\n    getInitConfiguration: monitor(() => deepClone(strategy.initConfiguration)),\n\n    addAction: monitor((name: string, context?: object) => {\n      strategy.addAction({\n        name: sanitize(name)!,\n        context: sanitize(context) as Context,\n        startClocks: clocksNow(),\n        type: ActionType.CUSTOM,\n      })\n    }),\n\n    addError: (error: unknown, context?: object) => {\n      const handlingStack = createHandlingStack()\n      callMonitored(() => {\n        strategy.addError({\n          error, // Do not sanitize error here, it is needed unserialized by computeRawError()\n          handlingStack,\n          context: sanitize(context) as Context,\n          startClocks: clocksNow(),\n        })\n      })\n    },\n\n    /**\n     * Add a custom timing relative to the start of the current view,\n     * stored in `@view.custom_timings.<timing_name>`\n     *\n     * @param name Name of the custom timing\n     * @param [time] Epoch timestamp of the custom timing (if not set, will use current time)\n     *\n     * Note: passing a relative time is discouraged since it is actually used as-is but displayed relative to the view start.\n     * We currently don't provide a way to retrieve the view start time, so it can be challenging to provide a timing relative to the view start.\n     * see https://github.com/DataDog/browser-sdk/issues/2552\n     */\n    addTiming: monitor((name: string, time?: number) => {\n      // TODO: next major decide to drop relative time support or update its behaviour\n      strategy.addTiming(sanitize(name)!, time as RelativeTime | TimeStamp | undefined)\n    }),\n\n    setUser: monitor((newUser: User) => {\n      if (checkUser(newUser)) {\n        userContextManager.setContext(sanitizeUser(newUser as Context))\n      }\n    }),\n\n    getUser: monitor(() => userContextManager.getContext()),\n\n    setUserProperty: monitor((key, property) => {\n      const sanitizedProperty = sanitizeUser({ [key]: property })[key]\n      userContextManager.setContextProperty(key, sanitizedProperty)\n    }),\n\n    removeUserProperty: monitor((key) => userContextManager.removeContextProperty(key)),\n\n    clearUser: monitor(() => userContextManager.clearContext()),\n\n    startView,\n\n    stopSession: monitor(() => {\n      strategy.stopSession()\n      addTelemetryUsage({ feature: 'stop-session' })\n    }),\n\n    /**\n     * Add a feature flag evaluation,\n     * stored in `@feature_flags.<feature_flag_key>`\n     *\n     * @param {string} key The key of the feature flag.\n     * @param {any} value The value of the feature flag.\n     *\n     * We recommend enabling the intake request compression when using feature flags `compressIntakeRequests: true`.\n     * For more information see the full [feature flag tracking guide](https://docs.datadoghq.com/real_user_monitoring/feature_flag_tracking/).\n     */\n    addFeatureFlagEvaluation: monitor((key: string, value: any) => {\n      strategy.addFeatureFlagEvaluation(sanitize(key)!, sanitize(value))\n    }),\n\n    getSessionReplayLink: monitor(() => recorderApi.getSessionReplayLink()),\n    startSessionReplayRecording: monitor(() => {\n      recorderApi.start()\n      addTelemetryUsage({ feature: 'start-session-replay-recording' })\n    }),\n    stopSessionReplayRecording: monitor(() => recorderApi.stop()),\n  })\n\n  return rumPublicApi\n}\n\nfunction createPostStartStrategy(initConfiguration: RumInitConfiguration, startRumResult: StartRumResult): Strategy {\n  return assign(\n    {\n      init: (initConfiguration: RumInitConfiguration) => {\n        displayAlreadyInitializedError('DD_RUM', initConfiguration)\n      },\n      initConfiguration,\n    },\n    startRumResult\n  )\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}