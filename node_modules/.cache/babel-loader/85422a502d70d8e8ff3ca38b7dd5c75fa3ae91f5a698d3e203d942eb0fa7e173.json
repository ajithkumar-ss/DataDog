{"ast":null,"code":"import { instrumentMethod } from '@datadog/browser-core';\nimport { IncrementalSource } from '../../../types';\nimport { getSerializedNodeId, hasSerializedNode } from '../serialization';\nimport { assembleIncrementalSnapshot } from '../assembly';\nexport function trackStyleSheet(styleSheetCb) {\n  function checkStyleSheetAndCallback(styleSheet, callback) {\n    if (styleSheet && hasSerializedNode(styleSheet.ownerNode)) {\n      callback(getSerializedNodeId(styleSheet.ownerNode));\n    }\n  }\n  var instrumentationStoppers = [instrumentMethod(CSSStyleSheet.prototype, 'insertRule', function (_a) {\n    var styleSheet = _a.target,\n      _b = _a.parameters,\n      rule = _b[0],\n      index = _b[1];\n    checkStyleSheetAndCallback(styleSheet, function (id) {\n      return styleSheetCb(assembleIncrementalSnapshot(IncrementalSource.StyleSheetRule, {\n        id: id,\n        adds: [{\n          rule: rule,\n          index: index\n        }]\n      }));\n    });\n  }), instrumentMethod(CSSStyleSheet.prototype, 'deleteRule', function (_a) {\n    var styleSheet = _a.target,\n      index = _a.parameters[0];\n    checkStyleSheetAndCallback(styleSheet, function (id) {\n      return styleSheetCb(assembleIncrementalSnapshot(IncrementalSource.StyleSheetRule, {\n        id: id,\n        removes: [{\n          index: index\n        }]\n      }));\n    });\n  })];\n  if (typeof CSSGroupingRule !== 'undefined') {\n    instrumentGroupingCSSRuleClass(CSSGroupingRule);\n  } else {\n    instrumentGroupingCSSRuleClass(CSSMediaRule);\n    instrumentGroupingCSSRuleClass(CSSSupportsRule);\n  }\n  function instrumentGroupingCSSRuleClass(cls) {\n    instrumentationStoppers.push(instrumentMethod(cls.prototype, 'insertRule', function (_a) {\n      var styleSheet = _a.target,\n        _b = _a.parameters,\n        rule = _b[0],\n        index = _b[1];\n      checkStyleSheetAndCallback(styleSheet.parentStyleSheet, function (id) {\n        var path = getPathToNestedCSSRule(styleSheet);\n        if (path) {\n          path.push(index || 0);\n          styleSheetCb(assembleIncrementalSnapshot(IncrementalSource.StyleSheetRule, {\n            id: id,\n            adds: [{\n              rule: rule,\n              index: path\n            }]\n          }));\n        }\n      });\n    }), instrumentMethod(cls.prototype, 'deleteRule', function (_a) {\n      var styleSheet = _a.target,\n        index = _a.parameters[0];\n      checkStyleSheetAndCallback(styleSheet.parentStyleSheet, function (id) {\n        var path = getPathToNestedCSSRule(styleSheet);\n        if (path) {\n          path.push(index);\n          styleSheetCb(assembleIncrementalSnapshot(IncrementalSource.StyleSheetRule, {\n            id: id,\n            removes: [{\n              index: path\n            }]\n          }));\n        }\n      });\n    }));\n  }\n  return {\n    stop: function () {\n      instrumentationStoppers.forEach(function (stopper) {\n        return stopper.stop();\n      });\n    }\n  };\n}\nexport function getPathToNestedCSSRule(rule) {\n  var path = [];\n  var currentRule = rule;\n  while (currentRule.parentRule) {\n    var rules_1 = Array.from(currentRule.parentRule.cssRules);\n    var index_1 = rules_1.indexOf(currentRule);\n    path.unshift(index_1);\n    currentRule = currentRule.parentRule;\n  }\n  // A rule may not be attached to a stylesheet\n  if (!currentRule.parentStyleSheet) {\n    return;\n  }\n  var rules = Array.from(currentRule.parentStyleSheet.cssRules);\n  var index = rules.indexOf(currentRule);\n  path.unshift(index);\n  return path;\n}","map":{"version":3,"names":["instrumentMethod","IncrementalSource","getSerializedNodeId","hasSerializedNode","assembleIncrementalSnapshot","trackStyleSheet","styleSheetCb","checkStyleSheetAndCallback","styleSheet","callback","ownerNode","instrumentationStoppers","CSSStyleSheet","prototype","_a","target","_b","parameters","rule","index","id","StyleSheetRule","adds","removes","CSSGroupingRule","instrumentGroupingCSSRuleClass","CSSMediaRule","CSSSupportsRule","cls","push","parentStyleSheet","path","getPathToNestedCSSRule","stop","forEach","stopper","currentRule","parentRule","rules_1","Array","from","cssRules","index_1","indexOf","unshift","rules"],"sources":["D:\\edu'\\Spritle\\Spritle\\node_modules\\@datadog\\browser-rum\\src\\domain\\record\\trackers\\trackStyleSheet.ts"],"sourcesContent":["import { instrumentMethod } from '@datadog/browser-core'\nimport { IncrementalSource } from '../../../types'\nimport type { StyleSheetRuleData, BrowserIncrementalSnapshotRecord } from '../../../types'\nimport { getSerializedNodeId, hasSerializedNode } from '../serialization'\nimport { assembleIncrementalSnapshot } from '../assembly'\nimport type { Tracker } from './types'\n\ntype GroupingCSSRuleTypes = typeof CSSGroupingRule | typeof CSSMediaRule | typeof CSSSupportsRule\n\nexport type StyleSheetCallback = (incrementalSnapshotRecord: BrowserIncrementalSnapshotRecord) => void\n\nexport function trackStyleSheet(styleSheetCb: StyleSheetCallback): Tracker {\n  function checkStyleSheetAndCallback(styleSheet: CSSStyleSheet | null, callback: (id: number) => void): void {\n    if (styleSheet && hasSerializedNode(styleSheet.ownerNode!)) {\n      callback(getSerializedNodeId(styleSheet.ownerNode))\n    }\n  }\n\n  const instrumentationStoppers = [\n    instrumentMethod(CSSStyleSheet.prototype, 'insertRule', ({ target: styleSheet, parameters: [rule, index] }) => {\n      checkStyleSheetAndCallback(styleSheet, (id) =>\n        styleSheetCb(\n          assembleIncrementalSnapshot<StyleSheetRuleData>(IncrementalSource.StyleSheetRule, {\n            id,\n            adds: [{ rule, index }],\n          })\n        )\n      )\n    }),\n\n    instrumentMethod(CSSStyleSheet.prototype, 'deleteRule', ({ target: styleSheet, parameters: [index] }) => {\n      checkStyleSheetAndCallback(styleSheet, (id) =>\n        styleSheetCb(\n          assembleIncrementalSnapshot<StyleSheetRuleData>(IncrementalSource.StyleSheetRule, {\n            id,\n            removes: [{ index }],\n          })\n        )\n      )\n    }),\n  ]\n\n  if (typeof CSSGroupingRule !== 'undefined') {\n    instrumentGroupingCSSRuleClass(CSSGroupingRule)\n  } else {\n    instrumentGroupingCSSRuleClass(CSSMediaRule)\n    instrumentGroupingCSSRuleClass(CSSSupportsRule)\n  }\n\n  function instrumentGroupingCSSRuleClass(cls: GroupingCSSRuleTypes) {\n    instrumentationStoppers.push(\n      instrumentMethod(cls.prototype, 'insertRule', ({ target: styleSheet, parameters: [rule, index] }) => {\n        checkStyleSheetAndCallback(styleSheet.parentStyleSheet, (id) => {\n          const path = getPathToNestedCSSRule(styleSheet)\n          if (path) {\n            path.push(index || 0)\n            styleSheetCb(\n              assembleIncrementalSnapshot<StyleSheetRuleData>(IncrementalSource.StyleSheetRule, {\n                id,\n                adds: [{ rule, index: path }],\n              })\n            )\n          }\n        })\n      }),\n\n      instrumentMethod(cls.prototype, 'deleteRule', ({ target: styleSheet, parameters: [index] }) => {\n        checkStyleSheetAndCallback(styleSheet.parentStyleSheet, (id) => {\n          const path = getPathToNestedCSSRule(styleSheet)\n          if (path) {\n            path.push(index)\n            styleSheetCb(\n              assembleIncrementalSnapshot<StyleSheetRuleData>(IncrementalSource.StyleSheetRule, {\n                id,\n                removes: [{ index: path }],\n              })\n            )\n          }\n        })\n      })\n    )\n  }\n\n  return {\n    stop: () => {\n      instrumentationStoppers.forEach((stopper) => stopper.stop())\n    },\n  }\n}\n\nexport function getPathToNestedCSSRule(rule: CSSRule): number[] | undefined {\n  const path: number[] = []\n  let currentRule = rule\n  while (currentRule.parentRule) {\n    const rules = Array.from((currentRule.parentRule as CSSGroupingRule).cssRules)\n    const index = rules.indexOf(currentRule)\n    path.unshift(index)\n    currentRule = currentRule.parentRule\n  }\n  // A rule may not be attached to a stylesheet\n  if (!currentRule.parentStyleSheet) {\n    return\n  }\n\n  const rules = Array.from(currentRule.parentStyleSheet.cssRules)\n  const index = rules.indexOf(currentRule)\n  path.unshift(index)\n\n  return path\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}