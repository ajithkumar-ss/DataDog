{"ast":null,"code":"import { dateNow, assign, addEventListeners, DOM_EVENT, getRelativeTime, isNumber, monitor, setTimeout, relativeNow, runOnReadyState, addEventListener, objectHasValue } from '@datadog/browser-core';\nimport { FAKE_INITIAL_DOCUMENT, isAllowedRequestUrl } from '../domain/resource/resourceUtils';\nimport { getDocumentTraceId } from '../domain/tracing/getDocumentTraceId';\n// We want to use a real enum (i.e. not a const enum) here, to be able to check whether an arbitrary\n// string is an expected performance entry\n// eslint-disable-next-line no-restricted-syntax\nexport var RumPerformanceEntryType;\n(function (RumPerformanceEntryType) {\n  RumPerformanceEntryType[\"EVENT\"] = \"event\";\n  RumPerformanceEntryType[\"FIRST_INPUT\"] = \"first-input\";\n  RumPerformanceEntryType[\"LARGEST_CONTENTFUL_PAINT\"] = \"largest-contentful-paint\";\n  RumPerformanceEntryType[\"LAYOUT_SHIFT\"] = \"layout-shift\";\n  RumPerformanceEntryType[\"LONG_TASK\"] = \"longtask\";\n  RumPerformanceEntryType[\"NAVIGATION\"] = \"navigation\";\n  RumPerformanceEntryType[\"PAINT\"] = \"paint\";\n  RumPerformanceEntryType[\"RESOURCE\"] = \"resource\";\n})(RumPerformanceEntryType || (RumPerformanceEntryType = {}));\nfunction supportPerformanceObject() {\n  return window.performance !== undefined && 'getEntries' in performance;\n}\nexport function supportPerformanceTimingEvent(entryType) {\n  return window.PerformanceObserver && PerformanceObserver.supportedEntryTypes !== undefined && PerformanceObserver.supportedEntryTypes.includes(entryType);\n}\nexport function startPerformanceCollection(lifeCycle, configuration) {\n  var cleanupTasks = [];\n  retrieveInitialDocumentResourceTiming(configuration, function (timing) {\n    handleRumPerformanceEntries(lifeCycle, configuration, [timing]);\n  });\n  if (supportPerformanceObject()) {\n    var performanceEntries_1 = performance.getEntries();\n    // Because the performance entry list can be quite large\n    // delay the computation to prevent the SDK from blocking the main thread on init\n    setTimeout(function () {\n      return handleRumPerformanceEntries(lifeCycle, configuration, performanceEntries_1);\n    });\n  }\n  if (window.PerformanceObserver) {\n    var handlePerformanceEntryList_1 = monitor(function (entries) {\n      return handleRumPerformanceEntries(lifeCycle, configuration, entries.getEntries());\n    });\n    var mainEntries = [RumPerformanceEntryType.RESOURCE, RumPerformanceEntryType.NAVIGATION, RumPerformanceEntryType.LONG_TASK, RumPerformanceEntryType.PAINT];\n    var experimentalEntries = [RumPerformanceEntryType.LARGEST_CONTENTFUL_PAINT, RumPerformanceEntryType.FIRST_INPUT, RumPerformanceEntryType.LAYOUT_SHIFT, RumPerformanceEntryType.EVENT];\n    try {\n      // Experimental entries are not retrieved by performance.getEntries()\n      // use a single PerformanceObserver with buffered flag by type\n      // to get values that could happen before SDK init\n      experimentalEntries.forEach(function (type) {\n        var observer = new window.PerformanceObserver(handlePerformanceEntryList_1);\n        observer.observe({\n          type: type,\n          buffered: true,\n          // durationThreshold only impact PerformanceEventTiming entries used for INP computation which requires a threshold at 40 (default is 104ms)\n          // cf: https://github.com/GoogleChrome/web-vitals/blob/3806160ffbc93c3c4abf210a167b81228172b31c/src/onINP.ts#L209\n          durationThreshold: 40\n        });\n        cleanupTasks.push(function () {\n          return observer.disconnect();\n        });\n      });\n    } catch (e) {\n      // Some old browser versions (ex: chrome 67) don't support the PerformanceObserver type and buffered options\n      // In these cases, fallback to PerformanceObserver with entryTypes\n      mainEntries.push.apply(mainEntries, experimentalEntries);\n    }\n    var mainObserver_1 = new PerformanceObserver(handlePerformanceEntryList_1);\n    mainObserver_1.observe({\n      entryTypes: mainEntries\n    });\n    cleanupTasks.push(function () {\n      return mainObserver_1.disconnect();\n    });\n    if (supportPerformanceObject() && 'addEventListener' in performance) {\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=1559377\n      var removePerformanceListener = addEventListener(configuration, performance, 'resourcetimingbufferfull', function () {\n        performance.clearResourceTimings();\n      }).stop;\n      cleanupTasks.push(removePerformanceListener);\n    }\n  }\n  if (!supportPerformanceTimingEvent(RumPerformanceEntryType.NAVIGATION)) {\n    retrieveNavigationTiming(configuration, function (timing) {\n      handleRumPerformanceEntries(lifeCycle, configuration, [timing]);\n    });\n  }\n  if (!supportPerformanceTimingEvent(RumPerformanceEntryType.FIRST_INPUT)) {\n    var stopFirstInputTiming = retrieveFirstInputTiming(configuration, function (timing) {\n      handleRumPerformanceEntries(lifeCycle, configuration, [timing]);\n    }).stop;\n    cleanupTasks.push(stopFirstInputTiming);\n  }\n  return {\n    stop: function () {\n      cleanupTasks.forEach(function (task) {\n        return task();\n      });\n    }\n  };\n}\nexport function retrieveInitialDocumentResourceTiming(configuration, callback) {\n  runOnReadyState(configuration, 'interactive', function () {\n    var timing;\n    var forcedAttributes = {\n      entryType: RumPerformanceEntryType.RESOURCE,\n      initiatorType: FAKE_INITIAL_DOCUMENT,\n      traceId: getDocumentTraceId(document),\n      toJSON: function () {\n        return assign({}, timing, {\n          toJSON: undefined\n        });\n      }\n    };\n    if (supportPerformanceTimingEvent(RumPerformanceEntryType.NAVIGATION) && performance.getEntriesByType(RumPerformanceEntryType.NAVIGATION).length > 0) {\n      var navigationEntry = performance.getEntriesByType(RumPerformanceEntryType.NAVIGATION)[0];\n      timing = assign(navigationEntry.toJSON(), forcedAttributes);\n    } else {\n      var relativePerformanceTiming = computeRelativePerformanceTiming();\n      timing = assign(relativePerformanceTiming, {\n        decodedBodySize: 0,\n        encodedBodySize: 0,\n        transferSize: 0,\n        renderBlockingStatus: 'non-blocking',\n        duration: relativePerformanceTiming.responseEnd,\n        name: window.location.href,\n        startTime: 0\n      }, forcedAttributes);\n    }\n    callback(timing);\n  });\n}\nfunction retrieveNavigationTiming(configuration, callback) {\n  function sendFakeTiming() {\n    callback(assign(computeRelativePerformanceTiming(), {\n      entryType: RumPerformanceEntryType.NAVIGATION\n    }));\n  }\n  runOnReadyState(configuration, 'complete', function () {\n    // Send it a bit after the actual load event, so the \"loadEventEnd\" timing is accurate\n    setTimeout(sendFakeTiming);\n  });\n}\n/**\n * first-input timing entry polyfill based on\n * https://github.com/GoogleChrome/web-vitals/blob/master/src/lib/polyfills/firstInputPolyfill.ts\n */\nfunction retrieveFirstInputTiming(configuration, callback) {\n  var startTimeStamp = dateNow();\n  var timingSent = false;\n  var removeEventListeners = addEventListeners(configuration, window, [DOM_EVENT.CLICK, DOM_EVENT.MOUSE_DOWN, DOM_EVENT.KEY_DOWN, DOM_EVENT.TOUCH_START, DOM_EVENT.POINTER_DOWN], function (evt) {\n    // Only count cancelable events, which should trigger behavior important to the user.\n    if (!evt.cancelable) {\n      return;\n    }\n    // This timing will be used to compute the \"first Input delay\", which is the delta between\n    // when the system received the event (e.g. evt.timeStamp) and when it could run the callback\n    // (e.g. performance.now()).\n    var timing = {\n      entryType: RumPerformanceEntryType.FIRST_INPUT,\n      processingStart: relativeNow(),\n      processingEnd: relativeNow(),\n      startTime: evt.timeStamp,\n      duration: 0,\n      // arbitrary value to avoid nullable duration and simplify INP logic\n      name: ''\n    };\n    if (evt.type === DOM_EVENT.POINTER_DOWN) {\n      sendTimingIfPointerIsNotCancelled(configuration, timing);\n    } else {\n      sendTiming(timing);\n    }\n  }, {\n    passive: true,\n    capture: true\n  }).stop;\n  return {\n    stop: removeEventListeners\n  };\n  /**\n   * Pointer events are a special case, because they can trigger main or compositor thread behavior.\n   * We differentiate these cases based on whether or not we see a pointercancel event, which are\n   * fired when we scroll. If we're scrolling we don't need to report input delay since FID excludes\n   * scrolling and pinch/zooming.\n   */\n  function sendTimingIfPointerIsNotCancelled(configuration, timing) {\n    addEventListeners(configuration, window, [DOM_EVENT.POINTER_UP, DOM_EVENT.POINTER_CANCEL], function (event) {\n      if (event.type === DOM_EVENT.POINTER_UP) {\n        sendTiming(timing);\n      }\n    }, {\n      once: true\n    });\n  }\n  function sendTiming(timing) {\n    if (!timingSent) {\n      timingSent = true;\n      removeEventListeners();\n      // In some cases the recorded delay is clearly wrong, e.g. it's negative or it's larger than\n      // the time between now and when the page was loaded.\n      // - https://github.com/GoogleChromeLabs/first-input-delay/issues/4\n      // - https://github.com/GoogleChromeLabs/first-input-delay/issues/6\n      // - https://github.com/GoogleChromeLabs/first-input-delay/issues/7\n      var delay = timing.processingStart - timing.startTime;\n      if (delay >= 0 && delay < dateNow() - startTimeStamp) {\n        callback(timing);\n      }\n    }\n  }\n}\nfunction computeRelativePerformanceTiming() {\n  var result = {};\n  var timing = performance.timing;\n  for (var key in timing) {\n    if (isNumber(timing[key])) {\n      var numberKey = key;\n      var timingElement = timing[numberKey];\n      result[numberKey] = timingElement === 0 ? 0 : getRelativeTime(timingElement);\n    }\n  }\n  return result;\n}\nfunction handleRumPerformanceEntries(lifeCycle, configuration, entries) {\n  var rumPerformanceEntries = entries.filter(function (entry) {\n    return objectHasValue(RumPerformanceEntryType, entry.entryType);\n  });\n  var rumAllowedPerformanceEntries = rumPerformanceEntries.filter(function (entry) {\n    return !isIncompleteNavigation(entry) && !isForbiddenResource(configuration, entry);\n  });\n  if (rumAllowedPerformanceEntries.length) {\n    lifeCycle.notify(0 /* LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED */, rumAllowedPerformanceEntries);\n  }\n}\nfunction isIncompleteNavigation(entry) {\n  return entry.entryType === RumPerformanceEntryType.NAVIGATION && entry.loadEventEnd <= 0;\n}\nfunction isForbiddenResource(configuration, entry) {\n  return entry.entryType === RumPerformanceEntryType.RESOURCE && !isAllowedRequestUrl(configuration, entry.name);\n}","map":{"version":3,"names":["dateNow","assign","addEventListeners","DOM_EVENT","getRelativeTime","isNumber","monitor","setTimeout","relativeNow","runOnReadyState","addEventListener","objectHasValue","FAKE_INITIAL_DOCUMENT","isAllowedRequestUrl","getDocumentTraceId","RumPerformanceEntryType","supportPerformanceObject","window","performance","undefined","supportPerformanceTimingEvent","entryType","PerformanceObserver","supportedEntryTypes","includes","startPerformanceCollection","lifeCycle","configuration","cleanupTasks","retrieveInitialDocumentResourceTiming","timing","handleRumPerformanceEntries","performanceEntries_1","getEntries","handlePerformanceEntryList_1","entries","mainEntries","RESOURCE","NAVIGATION","LONG_TASK","PAINT","experimentalEntries","LARGEST_CONTENTFUL_PAINT","FIRST_INPUT","LAYOUT_SHIFT","EVENT","forEach","type","observer","observe","buffered","durationThreshold","push","disconnect","e","apply","mainObserver_1","entryTypes","removePerformanceListener","clearResourceTimings","stop","retrieveNavigationTiming","stopFirstInputTiming","retrieveFirstInputTiming","task","callback","forcedAttributes","initiatorType","traceId","document","toJSON","getEntriesByType","length","navigationEntry","relativePerformanceTiming","computeRelativePerformanceTiming","decodedBodySize","encodedBodySize","transferSize","renderBlockingStatus","duration","responseEnd","name","location","href","startTime","sendFakeTiming","startTimeStamp","timingSent","removeEventListeners","CLICK","MOUSE_DOWN","KEY_DOWN","TOUCH_START","POINTER_DOWN","evt","cancelable","processingStart","processingEnd","timeStamp","sendTimingIfPointerIsNotCancelled","sendTiming","passive","capture","POINTER_UP","POINTER_CANCEL","event","once","delay","result","key","numberKey","timingElement","rumPerformanceEntries","filter","entry","rumAllowedPerformanceEntries","isIncompleteNavigation","isForbiddenResource","notify","loadEventEnd"],"sources":["D:\\edu'\\Spritle\\spritle\\node_modules\\@datadog\\browser-rum-core\\src\\browser\\performanceCollection.ts"],"sourcesContent":["import type { Duration, RelativeTime, TimeStamp } from '@datadog/browser-core'\nimport {\n  dateNow,\n  assign,\n  addEventListeners,\n  DOM_EVENT,\n  getRelativeTime,\n  isNumber,\n  monitor,\n  setTimeout,\n  relativeNow,\n  runOnReadyState,\n  addEventListener,\n  objectHasValue,\n} from '@datadog/browser-core'\n\nimport type { RumConfiguration } from '../domain/configuration'\nimport type { LifeCycle } from '../domain/lifeCycle'\nimport { LifeCycleEventType } from '../domain/lifeCycle'\nimport { FAKE_INITIAL_DOCUMENT, isAllowedRequestUrl } from '../domain/resource/resourceUtils'\n\nimport { getDocumentTraceId } from '../domain/tracing/getDocumentTraceId'\n\ntype RumPerformanceObserverConstructor = new (callback: PerformanceObserverCallback) => RumPerformanceObserver\n\nexport interface BrowserWindow extends Window {\n  PerformanceObserver: RumPerformanceObserverConstructor\n  performance: Performance & { interactionCount?: number }\n}\n\nexport interface RumPerformanceObserver extends PerformanceObserver {\n  observe(options?: PerformanceObserverInit & { durationThreshold: number }): void\n}\n\n// We want to use a real enum (i.e. not a const enum) here, to be able to check whether an arbitrary\n// string is an expected performance entry\n// eslint-disable-next-line no-restricted-syntax\nexport enum RumPerformanceEntryType {\n  EVENT = 'event',\n  FIRST_INPUT = 'first-input',\n  LARGEST_CONTENTFUL_PAINT = 'largest-contentful-paint',\n  LAYOUT_SHIFT = 'layout-shift',\n  LONG_TASK = 'longtask',\n  NAVIGATION = 'navigation',\n  PAINT = 'paint',\n  RESOURCE = 'resource',\n}\n\nexport interface RumPerformanceResourceTiming {\n  entryType: RumPerformanceEntryType.RESOURCE\n  initiatorType: string\n  responseStatus?: number\n  name: string\n  startTime: RelativeTime\n  duration: Duration\n  fetchStart: RelativeTime\n  domainLookupStart: RelativeTime\n  domainLookupEnd: RelativeTime\n  connectStart: RelativeTime\n  secureConnectionStart: RelativeTime\n  connectEnd: RelativeTime\n  requestStart: RelativeTime\n  responseStart: RelativeTime\n  responseEnd: RelativeTime\n  redirectStart: RelativeTime\n  redirectEnd: RelativeTime\n  decodedBodySize: number\n  encodedBodySize: number\n  transferSize: number\n  renderBlockingStatus?: string\n  traceId?: string\n  toJSON(): Omit<PerformanceEntry, 'toJSON'>\n}\n\nexport interface RumPerformanceLongTaskTiming {\n  name: string\n  entryType: RumPerformanceEntryType.LONG_TASK\n  startTime: RelativeTime\n  duration: Duration\n  toJSON(): Omit<PerformanceEntry, 'toJSON'>\n}\n\nexport interface RumPerformancePaintTiming {\n  entryType: RumPerformanceEntryType.PAINT\n  name: 'first-paint' | 'first-contentful-paint'\n  startTime: RelativeTime\n}\n\nexport interface RumPerformanceNavigationTiming {\n  entryType: RumPerformanceEntryType.NAVIGATION\n  domComplete: RelativeTime\n  domContentLoadedEventEnd: RelativeTime\n  domInteractive: RelativeTime\n  loadEventEnd: RelativeTime\n  responseStart: RelativeTime\n}\n\nexport interface RumLargestContentfulPaintTiming {\n  entryType: RumPerformanceEntryType.LARGEST_CONTENTFUL_PAINT\n  startTime: RelativeTime\n  size: number\n  element?: Element\n  toJSON(): Omit<RumLargestContentfulPaintTiming, 'toJSON'>\n}\n\nexport interface RumFirstInputTiming {\n  entryType: RumPerformanceEntryType.FIRST_INPUT\n  startTime: RelativeTime\n  processingStart: RelativeTime\n  processingEnd: RelativeTime\n  duration: Duration\n  target?: Node\n  interactionId?: number\n  name: string\n}\n\nexport interface RumPerformanceEventTiming {\n  entryType: RumPerformanceEntryType.EVENT\n  startTime: RelativeTime\n  processingStart: RelativeTime\n  processingEnd: RelativeTime\n  duration: Duration\n  interactionId?: number\n  target?: Node\n  name: string\n}\n\nexport interface RumLayoutShiftTiming {\n  entryType: RumPerformanceEntryType.LAYOUT_SHIFT\n  startTime: RelativeTime\n  value: number\n  hadRecentInput: boolean\n  sources?: Array<{\n    node?: Node\n  }>\n}\n\nexport type RumPerformanceEntry =\n  | RumPerformanceResourceTiming\n  | RumPerformanceLongTaskTiming\n  | RumPerformancePaintTiming\n  | RumPerformanceNavigationTiming\n  | RumLargestContentfulPaintTiming\n  | RumFirstInputTiming\n  | RumPerformanceEventTiming\n  | RumLayoutShiftTiming\n\nfunction supportPerformanceObject() {\n  return window.performance !== undefined && 'getEntries' in performance\n}\n\nexport function supportPerformanceTimingEvent(entryType: RumPerformanceEntryType) {\n  return (\n    window.PerformanceObserver &&\n    PerformanceObserver.supportedEntryTypes !== undefined &&\n    PerformanceObserver.supportedEntryTypes.includes(entryType)\n  )\n}\n\nexport function startPerformanceCollection(lifeCycle: LifeCycle, configuration: RumConfiguration) {\n  const cleanupTasks: Array<() => void> = []\n  retrieveInitialDocumentResourceTiming(configuration, (timing) => {\n    handleRumPerformanceEntries(lifeCycle, configuration, [timing])\n  })\n\n  if (supportPerformanceObject()) {\n    const performanceEntries = performance.getEntries()\n    // Because the performance entry list can be quite large\n    // delay the computation to prevent the SDK from blocking the main thread on init\n    setTimeout(() => handleRumPerformanceEntries(lifeCycle, configuration, performanceEntries))\n  }\n\n  if (window.PerformanceObserver) {\n    const handlePerformanceEntryList = monitor((entries: PerformanceObserverEntryList) =>\n      handleRumPerformanceEntries(lifeCycle, configuration, entries.getEntries())\n    )\n    const mainEntries = [\n      RumPerformanceEntryType.RESOURCE,\n      RumPerformanceEntryType.NAVIGATION,\n      RumPerformanceEntryType.LONG_TASK,\n      RumPerformanceEntryType.PAINT,\n    ]\n    const experimentalEntries = [\n      RumPerformanceEntryType.LARGEST_CONTENTFUL_PAINT,\n      RumPerformanceEntryType.FIRST_INPUT,\n      RumPerformanceEntryType.LAYOUT_SHIFT,\n      RumPerformanceEntryType.EVENT,\n    ]\n\n    try {\n      // Experimental entries are not retrieved by performance.getEntries()\n      // use a single PerformanceObserver with buffered flag by type\n      // to get values that could happen before SDK init\n      experimentalEntries.forEach((type) => {\n        const observer = new (window as BrowserWindow).PerformanceObserver(handlePerformanceEntryList)\n        observer.observe({\n          type,\n          buffered: true,\n          // durationThreshold only impact PerformanceEventTiming entries used for INP computation which requires a threshold at 40 (default is 104ms)\n          // cf: https://github.com/GoogleChrome/web-vitals/blob/3806160ffbc93c3c4abf210a167b81228172b31c/src/onINP.ts#L209\n          durationThreshold: 40,\n        })\n        cleanupTasks.push(() => observer.disconnect())\n      })\n    } catch (e) {\n      // Some old browser versions (ex: chrome 67) don't support the PerformanceObserver type and buffered options\n      // In these cases, fallback to PerformanceObserver with entryTypes\n      mainEntries.push(...experimentalEntries)\n    }\n\n    const mainObserver = new PerformanceObserver(handlePerformanceEntryList)\n    mainObserver.observe({ entryTypes: mainEntries })\n    cleanupTasks.push(() => mainObserver.disconnect())\n\n    if (supportPerformanceObject() && 'addEventListener' in performance) {\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=1559377\n      const { stop: removePerformanceListener } = addEventListener(\n        configuration,\n        performance,\n        'resourcetimingbufferfull',\n        () => {\n          performance.clearResourceTimings()\n        }\n      )\n      cleanupTasks.push(removePerformanceListener)\n    }\n  }\n  if (!supportPerformanceTimingEvent(RumPerformanceEntryType.NAVIGATION)) {\n    retrieveNavigationTiming(configuration, (timing) => {\n      handleRumPerformanceEntries(lifeCycle, configuration, [timing])\n    })\n  }\n  if (!supportPerformanceTimingEvent(RumPerformanceEntryType.FIRST_INPUT)) {\n    const { stop: stopFirstInputTiming } = retrieveFirstInputTiming(configuration, (timing) => {\n      handleRumPerformanceEntries(lifeCycle, configuration, [timing])\n    })\n    cleanupTasks.push(stopFirstInputTiming)\n  }\n  return {\n    stop: () => {\n      cleanupTasks.forEach((task) => task())\n    },\n  }\n}\n\nexport function retrieveInitialDocumentResourceTiming(\n  configuration: RumConfiguration,\n  callback: (timing: RumPerformanceResourceTiming) => void\n) {\n  runOnReadyState(configuration, 'interactive', () => {\n    let timing: RumPerformanceResourceTiming\n\n    const forcedAttributes = {\n      entryType: RumPerformanceEntryType.RESOURCE as const,\n      initiatorType: FAKE_INITIAL_DOCUMENT,\n      traceId: getDocumentTraceId(document),\n      toJSON: () => assign({}, timing, { toJSON: undefined }),\n    }\n    if (\n      supportPerformanceTimingEvent(RumPerformanceEntryType.NAVIGATION) &&\n      performance.getEntriesByType(RumPerformanceEntryType.NAVIGATION).length > 0\n    ) {\n      const navigationEntry = performance.getEntriesByType(RumPerformanceEntryType.NAVIGATION)[0]\n      timing = assign(navigationEntry.toJSON() as RumPerformanceResourceTiming, forcedAttributes)\n    } else {\n      const relativePerformanceTiming = computeRelativePerformanceTiming()\n      timing = assign(\n        relativePerformanceTiming,\n        {\n          decodedBodySize: 0,\n          encodedBodySize: 0,\n          transferSize: 0,\n          renderBlockingStatus: 'non-blocking',\n          duration: relativePerformanceTiming.responseEnd,\n          name: window.location.href,\n          startTime: 0 as RelativeTime,\n        },\n        forcedAttributes\n      )\n    }\n    callback(timing)\n  })\n}\n\nfunction retrieveNavigationTiming(\n  configuration: RumConfiguration,\n  callback: (timing: RumPerformanceNavigationTiming) => void\n) {\n  function sendFakeTiming() {\n    callback(\n      assign(computeRelativePerformanceTiming(), {\n        entryType: RumPerformanceEntryType.NAVIGATION as const,\n      })\n    )\n  }\n\n  runOnReadyState(configuration, 'complete', () => {\n    // Send it a bit after the actual load event, so the \"loadEventEnd\" timing is accurate\n    setTimeout(sendFakeTiming)\n  })\n}\n\n/**\n * first-input timing entry polyfill based on\n * https://github.com/GoogleChrome/web-vitals/blob/master/src/lib/polyfills/firstInputPolyfill.ts\n */\nfunction retrieveFirstInputTiming(configuration: RumConfiguration, callback: (timing: RumFirstInputTiming) => void) {\n  const startTimeStamp = dateNow()\n  let timingSent = false\n\n  const { stop: removeEventListeners } = addEventListeners(\n    configuration,\n    window,\n    [DOM_EVENT.CLICK, DOM_EVENT.MOUSE_DOWN, DOM_EVENT.KEY_DOWN, DOM_EVENT.TOUCH_START, DOM_EVENT.POINTER_DOWN],\n    (evt) => {\n      // Only count cancelable events, which should trigger behavior important to the user.\n      if (!evt.cancelable) {\n        return\n      }\n\n      // This timing will be used to compute the \"first Input delay\", which is the delta between\n      // when the system received the event (e.g. evt.timeStamp) and when it could run the callback\n      // (e.g. performance.now()).\n      const timing: RumFirstInputTiming = {\n        entryType: RumPerformanceEntryType.FIRST_INPUT,\n        processingStart: relativeNow(),\n        processingEnd: relativeNow(),\n        startTime: evt.timeStamp as RelativeTime,\n        duration: 0 as Duration, // arbitrary value to avoid nullable duration and simplify INP logic\n        name: '',\n      }\n\n      if (evt.type === DOM_EVENT.POINTER_DOWN) {\n        sendTimingIfPointerIsNotCancelled(configuration, timing)\n      } else {\n        sendTiming(timing)\n      }\n    },\n    { passive: true, capture: true }\n  )\n\n  return { stop: removeEventListeners }\n\n  /**\n   * Pointer events are a special case, because they can trigger main or compositor thread behavior.\n   * We differentiate these cases based on whether or not we see a pointercancel event, which are\n   * fired when we scroll. If we're scrolling we don't need to report input delay since FID excludes\n   * scrolling and pinch/zooming.\n   */\n  function sendTimingIfPointerIsNotCancelled(configuration: RumConfiguration, timing: RumFirstInputTiming) {\n    addEventListeners(\n      configuration,\n      window,\n      [DOM_EVENT.POINTER_UP, DOM_EVENT.POINTER_CANCEL],\n      (event) => {\n        if (event.type === DOM_EVENT.POINTER_UP) {\n          sendTiming(timing)\n        }\n      },\n      { once: true }\n    )\n  }\n\n  function sendTiming(timing: RumFirstInputTiming) {\n    if (!timingSent) {\n      timingSent = true\n      removeEventListeners()\n      // In some cases the recorded delay is clearly wrong, e.g. it's negative or it's larger than\n      // the time between now and when the page was loaded.\n      // - https://github.com/GoogleChromeLabs/first-input-delay/issues/4\n      // - https://github.com/GoogleChromeLabs/first-input-delay/issues/6\n      // - https://github.com/GoogleChromeLabs/first-input-delay/issues/7\n      const delay = timing.processingStart - timing.startTime\n      if (delay >= 0 && delay < dateNow() - startTimeStamp) {\n        callback(timing)\n      }\n    }\n  }\n}\n\nexport type RelativePerformanceTiming = {\n  -readonly [key in keyof Omit<PerformanceTiming, 'toJSON'>]: RelativeTime\n}\n\nfunction computeRelativePerformanceTiming() {\n  const result: Partial<RelativePerformanceTiming> = {}\n  const timing = performance.timing\n  for (const key in timing) {\n    if (isNumber(timing[key as keyof PerformanceTiming])) {\n      const numberKey = key as keyof RelativePerformanceTiming\n      const timingElement = timing[numberKey] as TimeStamp\n      result[numberKey] = timingElement === 0 ? (0 as RelativeTime) : getRelativeTime(timingElement)\n    }\n  }\n  return result as RelativePerformanceTiming\n}\n\nfunction handleRumPerformanceEntries(\n  lifeCycle: LifeCycle,\n  configuration: RumConfiguration,\n  entries: Array<PerformanceEntry | RumPerformanceEntry>\n) {\n  const rumPerformanceEntries = entries.filter((entry): entry is RumPerformanceEntry =>\n    objectHasValue(RumPerformanceEntryType, entry.entryType)\n  )\n\n  const rumAllowedPerformanceEntries = rumPerformanceEntries.filter(\n    (entry) => !isIncompleteNavigation(entry) && !isForbiddenResource(configuration, entry)\n  )\n\n  if (rumAllowedPerformanceEntries.length) {\n    lifeCycle.notify(LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED, rumAllowedPerformanceEntries)\n  }\n}\n\nfunction isIncompleteNavigation(entry: RumPerformanceEntry) {\n  return entry.entryType === RumPerformanceEntryType.NAVIGATION && entry.loadEventEnd <= 0\n}\n\nfunction isForbiddenResource(configuration: RumConfiguration, entry: RumPerformanceEntry) {\n  return entry.entryType === RumPerformanceEntryType.RESOURCE && !isAllowedRequestUrl(configuration, entry.name)\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}