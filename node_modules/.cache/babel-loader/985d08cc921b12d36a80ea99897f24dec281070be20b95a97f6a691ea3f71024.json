{"ast":null,"code":"import { monitor, noop, Observable, getZoneJsOriginalValue } from '@datadog/browser-core';\nexport function createDOMMutationObservable() {\n  var MutationObserver = getMutationObserverConstructor();\n  return new Observable(function (observable) {\n    if (!MutationObserver) {\n      return;\n    }\n    var observer = new MutationObserver(monitor(function () {\n      return observable.notify();\n    }));\n    observer.observe(document, {\n      attributes: true,\n      characterData: true,\n      childList: true,\n      subtree: true\n    });\n    return function () {\n      return observer.disconnect();\n    };\n  });\n}\nexport function getMutationObserverConstructor() {\n  var constructor;\n  var browserWindow = window;\n  // Angular uses Zone.js to provide a context persisting across async tasks.  Zone.js replaces the\n  // global MutationObserver constructor with a patched version to support the context propagation.\n  // There is an ongoing issue[1][2] with this setup when using a MutationObserver within a Angular\n  // component: on some occasions, the callback is being called in an infinite loop, causing the\n  // page to freeze (even if the callback is completely empty).\n  //\n  // To work around this issue, we try to get the original MutationObserver constructor stored by\n  // Zone.js.\n  //\n  // [1] https://github.com/angular/angular/issues/26948\n  // [2] https://github.com/angular/angular/issues/31712\n  if (browserWindow.Zone) {\n    // Zone.js 0.8.6+ is storing original class constructors into the browser 'window' object[3].\n    //\n    // [3] https://github.com/angular/angular/blob/6375fa79875c0fe7b815efc45940a6e6f5c9c9eb/packages/zone.js/lib/common/utils.ts#L288\n    constructor = getZoneJsOriginalValue(browserWindow, 'MutationObserver');\n    if (browserWindow.MutationObserver && constructor === browserWindow.MutationObserver) {\n      // Anterior Zone.js versions (used in Angular 2) does not expose the original MutationObserver\n      // in the 'window' object. Luckily, the patched MutationObserver class is storing an original\n      // instance in its properties[4]. Let's get the original MutationObserver constructor from\n      // there.\n      //\n      // [4] https://github.com/angular/zone.js/blob/v0.8.5/lib/common/utils.ts#L412\n      var patchedInstance = new browserWindow.MutationObserver(noop);\n      var originalInstance = getZoneJsOriginalValue(patchedInstance, 'originalInstance');\n      constructor = originalInstance && originalInstance.constructor;\n    }\n  }\n  if (!constructor) {\n    constructor = browserWindow.MutationObserver;\n  }\n  return constructor;\n}","map":{"version":3,"names":["monitor","noop","Observable","getZoneJsOriginalValue","createDOMMutationObservable","MutationObserver","getMutationObserverConstructor","observable","observer","notify","observe","document","attributes","characterData","childList","subtree","disconnect","constructor","browserWindow","window","Zone","patchedInstance","originalInstance"],"sources":["D:\\edu'\\Spritle\\Spritle\\node_modules\\@datadog\\browser-rum-core\\src\\browser\\domMutationObservable.ts"],"sourcesContent":["import { monitor, noop, Observable, getZoneJsOriginalValue } from '@datadog/browser-core'\n\nexport function createDOMMutationObservable() {\n  const MutationObserver = getMutationObserverConstructor()\n\n  return new Observable<void>((observable) => {\n    if (!MutationObserver) {\n      return\n    }\n    const observer = new MutationObserver(monitor(() => observable.notify()))\n    observer.observe(document, {\n      attributes: true,\n      characterData: true,\n      childList: true,\n      subtree: true,\n    })\n    return () => observer.disconnect()\n  })\n}\n\ntype MutationObserverConstructor = new (callback: MutationCallback) => MutationObserver\n\nexport interface BrowserWindow extends Window {\n  MutationObserver?: MutationObserverConstructor\n  Zone?: unknown\n}\n\nexport function getMutationObserverConstructor(): MutationObserverConstructor | undefined {\n  let constructor: MutationObserverConstructor | undefined\n  const browserWindow: BrowserWindow = window\n\n  // Angular uses Zone.js to provide a context persisting across async tasks.  Zone.js replaces the\n  // global MutationObserver constructor with a patched version to support the context propagation.\n  // There is an ongoing issue[1][2] with this setup when using a MutationObserver within a Angular\n  // component: on some occasions, the callback is being called in an infinite loop, causing the\n  // page to freeze (even if the callback is completely empty).\n  //\n  // To work around this issue, we try to get the original MutationObserver constructor stored by\n  // Zone.js.\n  //\n  // [1] https://github.com/angular/angular/issues/26948\n  // [2] https://github.com/angular/angular/issues/31712\n  if (browserWindow.Zone) {\n    // Zone.js 0.8.6+ is storing original class constructors into the browser 'window' object[3].\n    //\n    // [3] https://github.com/angular/angular/blob/6375fa79875c0fe7b815efc45940a6e6f5c9c9eb/packages/zone.js/lib/common/utils.ts#L288\n    constructor = getZoneJsOriginalValue(browserWindow, 'MutationObserver')\n\n    if (browserWindow.MutationObserver && constructor === browserWindow.MutationObserver) {\n      // Anterior Zone.js versions (used in Angular 2) does not expose the original MutationObserver\n      // in the 'window' object. Luckily, the patched MutationObserver class is storing an original\n      // instance in its properties[4]. Let's get the original MutationObserver constructor from\n      // there.\n      //\n      // [4] https://github.com/angular/zone.js/blob/v0.8.5/lib/common/utils.ts#L412\n\n      const patchedInstance = new browserWindow.MutationObserver(noop) as {\n        originalInstance?: { constructor: MutationObserverConstructor }\n      }\n\n      const originalInstance = getZoneJsOriginalValue(patchedInstance, 'originalInstance')\n      constructor = originalInstance && originalInstance.constructor\n    }\n  }\n\n  if (!constructor) {\n    constructor = browserWindow.MutationObserver\n  }\n\n  return constructor\n}\n"],"mappings":"AAAA,SAASA,OAAO,EAAEC,IAAI,EAAEC,UAAU,EAAEC,sBAAsB,QAAQ,uBAAuB;AAEzF,OAAM,SAAUC,2BAA2BA,CAAA;EACzC,IAAMC,gBAAgB,GAAGC,8BAA8B,EAAE;EAEzD,OAAO,IAAIJ,UAAU,CAAO,UAACK,UAAU;IACrC,IAAI,CAACF,gBAAgB,EAAE;MACrB;IACF;IACA,IAAMG,QAAQ,GAAG,IAAIH,gBAAgB,CAACL,OAAO,CAAC;MAAM,OAAAO,UAAU,CAACE,MAAM,EAAE;IAAnB,CAAmB,CAAC,CAAC;IACzED,QAAQ,CAACE,OAAO,CAACC,QAAQ,EAAE;MACzBC,UAAU,EAAE,IAAI;MAChBC,aAAa,EAAE,IAAI;MACnBC,SAAS,EAAE,IAAI;MACfC,OAAO,EAAE;KACV,CAAC;IACF,OAAO;MAAM,OAAAP,QAAQ,CAACQ,UAAU,EAAE;IAArB,CAAqB;EACpC,CAAC,CAAC;AACJ;AASA,OAAM,SAAUV,8BAA8BA,CAAA;EAC5C,IAAIW,WAAoD;EACxD,IAAMC,aAAa,GAAkBC,MAAM;EAE3C;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,IAAID,aAAa,CAACE,IAAI,EAAE;IACtB;IACA;IACA;IACAH,WAAW,GAAGd,sBAAsB,CAACe,aAAa,EAAE,kBAAkB,CAAC;IAEvE,IAAIA,aAAa,CAACb,gBAAgB,IAAIY,WAAW,KAAKC,aAAa,CAACb,gBAAgB,EAAE;MACpF;MACA;MACA;MACA;MACA;MACA;MAEA,IAAMgB,eAAe,GAAG,IAAIH,aAAa,CAACb,gBAAgB,CAACJ,IAAI,CAE9D;MAED,IAAMqB,gBAAgB,GAAGnB,sBAAsB,CAACkB,eAAe,EAAE,kBAAkB,CAAC;MACpFJ,WAAW,GAAGK,gBAAgB,IAAIA,gBAAgB,CAACL,WAAW;IAChE;EACF;EAEA,IAAI,CAACA,WAAW,EAAE;IAChBA,WAAW,GAAGC,aAAa,CAACb,gBAAgB;EAC9C;EAEA,OAAOY,WAAW;AACpB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}