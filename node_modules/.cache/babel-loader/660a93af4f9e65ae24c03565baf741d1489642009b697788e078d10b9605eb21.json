{"ast":null,"code":"import { objectEntries, shallowClone, performDraw, isNumber, assign, find, getType, isMatchOption, matchList, TraceContextInjection } from '@datadog/browser-core';\nexport function isTracingOption(item) {\n  var expectedItem = item;\n  return getType(expectedItem) === 'object' && isMatchOption(expectedItem.match) && Array.isArray(expectedItem.propagatorTypes);\n}\n/**\n * Clear tracing information to avoid incomplete traces. Ideally, we should do it when the\n * request did not reach the server, but the browser does not expose this. So, we clear tracing\n * information if the request ended with status 0 without being aborted by the application.\n *\n * Reasoning:\n *\n * * Applications are usually aborting requests after a bit of time, for example when the user is\n * typing (autocompletion) or navigating away (in a SPA). With a performant device and good\n * network conditions, the request is likely to reach the server before being canceled.\n *\n * * Requests aborted otherwise (ex: lack of internet, CORS issue, blocked by a privacy extension)\n * are likely to finish quickly and without reaching the server.\n *\n * Of course, it might not be the case every time, but it should limit having incomplete traces a\n * bit.\n * */\nexport function clearTracingIfNeeded(context) {\n  if (context.status === 0 && !context.isAborted) {\n    context.traceId = undefined;\n    context.spanId = undefined;\n    context.traceSampled = undefined;\n  }\n}\nexport function startTracer(configuration, sessionManager) {\n  return {\n    clearTracingIfNeeded: clearTracingIfNeeded,\n    traceFetch: function (context) {\n      return injectHeadersIfTracingAllowed(configuration, context, sessionManager, function (tracingHeaders) {\n        var _a;\n        if (context.input instanceof Request && !((_a = context.init) === null || _a === void 0 ? void 0 : _a.headers)) {\n          context.input = new Request(context.input);\n          Object.keys(tracingHeaders).forEach(function (key) {\n            ;\n            context.input.headers.append(key, tracingHeaders[key]);\n          });\n        } else {\n          context.init = shallowClone(context.init);\n          var headers_1 = [];\n          if (context.init.headers instanceof Headers) {\n            context.init.headers.forEach(function (value, key) {\n              headers_1.push([key, value]);\n            });\n          } else if (Array.isArray(context.init.headers)) {\n            context.init.headers.forEach(function (header) {\n              headers_1.push(header);\n            });\n          } else if (context.init.headers) {\n            Object.keys(context.init.headers).forEach(function (key) {\n              headers_1.push([key, context.init.headers[key]]);\n            });\n          }\n          context.init.headers = headers_1.concat(objectEntries(tracingHeaders));\n        }\n      });\n    },\n    traceXhr: function (context, xhr) {\n      return injectHeadersIfTracingAllowed(configuration, context, sessionManager, function (tracingHeaders) {\n        Object.keys(tracingHeaders).forEach(function (name) {\n          xhr.setRequestHeader(name, tracingHeaders[name]);\n        });\n      });\n    }\n  };\n}\nfunction injectHeadersIfTracingAllowed(configuration, context, sessionManager, inject) {\n  if (!isTracingSupported() || !sessionManager.findTrackedSession()) {\n    return;\n  }\n  var tracingOption = find(configuration.allowedTracingUrls, function (tracingOption) {\n    return matchList([tracingOption.match], context.url, true);\n  });\n  if (!tracingOption) {\n    return;\n  }\n  context.traceSampled = !isNumber(configuration.traceSampleRate) || performDraw(configuration.traceSampleRate);\n  if (!context.traceSampled && configuration.traceContextInjection !== TraceContextInjection.ALL) {\n    return;\n  }\n  context.traceId = new TraceIdentifier();\n  context.spanId = new TraceIdentifier();\n  inject(makeTracingHeaders(context.traceId, context.spanId, context.traceSampled, tracingOption.propagatorTypes));\n}\nexport function isTracingSupported() {\n  return getCrypto() !== undefined;\n}\nfunction getCrypto() {\n  return window.crypto || window.msCrypto;\n}\n/**\n * When trace is not sampled, set priority to '0' instead of not adding the tracing headers\n * to prepare the implementation for sampling delegation.\n */\nfunction makeTracingHeaders(traceId, spanId, traceSampled, propagatorTypes) {\n  var tracingHeaders = {};\n  propagatorTypes.forEach(function (propagatorType) {\n    switch (propagatorType) {\n      case 'datadog':\n        {\n          assign(tracingHeaders, {\n            'x-datadog-origin': 'rum',\n            'x-datadog-parent-id': spanId.toDecimalString(),\n            'x-datadog-sampling-priority': traceSampled ? '1' : '0',\n            'x-datadog-trace-id': traceId.toDecimalString()\n          });\n          break;\n        }\n      // https://www.w3.org/TR/trace-context/\n      case 'tracecontext':\n        {\n          assign(tracingHeaders, {\n            traceparent: \"00-0000000000000000\".concat(traceId.toPaddedHexadecimalString(), \"-\").concat(spanId.toPaddedHexadecimalString(), \"-0\").concat(traceSampled ? '1' : '0')\n          });\n          break;\n        }\n      // https://github.com/openzipkin/b3-propagation\n      case 'b3':\n        {\n          assign(tracingHeaders, {\n            b3: \"\".concat(traceId.toPaddedHexadecimalString(), \"-\").concat(spanId.toPaddedHexadecimalString(), \"-\").concat(traceSampled ? '1' : '0')\n          });\n          break;\n        }\n      case 'b3multi':\n        {\n          assign(tracingHeaders, {\n            'X-B3-TraceId': traceId.toPaddedHexadecimalString(),\n            'X-B3-SpanId': spanId.toPaddedHexadecimalString(),\n            'X-B3-Sampled': traceSampled ? '1' : '0'\n          });\n          break;\n        }\n    }\n  });\n  return tracingHeaders;\n}\n/* eslint-disable no-bitwise */\nvar TraceIdentifier = /** @class */function () {\n  function TraceIdentifier() {\n    this.buffer = new Uint8Array(8);\n    getCrypto().getRandomValues(this.buffer);\n    this.buffer[0] = this.buffer[0] & 0x7f; // force 63-bit\n  }\n  TraceIdentifier.prototype.toString = function (radix) {\n    var high = this.readInt32(0);\n    var low = this.readInt32(4);\n    var str = '';\n    do {\n      var mod = high % radix * 4294967296 + low;\n      high = Math.floor(high / radix);\n      low = Math.floor(mod / radix);\n      str = (mod % radix).toString(radix) + str;\n    } while (high || low);\n    return str;\n  };\n  /**\n   * Format used everywhere except the trace intake\n   */\n  TraceIdentifier.prototype.toDecimalString = function () {\n    return this.toString(10);\n  };\n  /**\n   * Format used by OTel headers\n   */\n  TraceIdentifier.prototype.toPaddedHexadecimalString = function () {\n    var traceId = this.toString(16);\n    return Array(17 - traceId.length).join('0') + traceId;\n  };\n  TraceIdentifier.prototype.readInt32 = function (offset) {\n    return this.buffer[offset] * 16777216 + (this.buffer[offset + 1] << 16) + (this.buffer[offset + 2] << 8) + this.buffer[offset + 3];\n  };\n  return TraceIdentifier;\n}();\nexport { TraceIdentifier };\n/* eslint-enable no-bitwise */","map":{"version":3,"names":["objectEntries","shallowClone","performDraw","isNumber","assign","find","getType","isMatchOption","matchList","TraceContextInjection","isTracingOption","item","expectedItem","match","Array","isArray","propagatorTypes","clearTracingIfNeeded","context","status","isAborted","traceId","undefined","spanId","traceSampled","startTracer","configuration","sessionManager","traceFetch","injectHeadersIfTracingAllowed","tracingHeaders","input","Request","_a","init","headers","Object","keys","forEach","key","append","headers_1","Headers","value","push","header","concat","traceXhr","xhr","name","setRequestHeader","inject","isTracingSupported","findTrackedSession","tracingOption","allowedTracingUrls","url","traceSampleRate","traceContextInjection","ALL","TraceIdentifier","makeTracingHeaders","getCrypto","window","crypto","msCrypto","propagatorType","toDecimalString","traceparent","toPaddedHexadecimalString","b3","buffer","Uint8Array","getRandomValues","prototype","toString","radix","high","readInt32","low","str","mod","Math","floor","length","join","offset"],"sources":["D:\\edu'\\Spritle\\Spritle\\node_modules\\@datadog\\browser-rum-core\\src\\domain\\tracing\\tracer.ts"],"sourcesContent":["import {\n  objectEntries,\n  shallowClone,\n  performDraw,\n  isNumber,\n  assign,\n  find,\n  getType,\n  isMatchOption,\n  matchList,\n  TraceContextInjection,\n} from '@datadog/browser-core'\nimport type { RumConfiguration } from '../configuration'\nimport type {\n  RumFetchResolveContext,\n  RumFetchStartContext,\n  RumXhrCompleteContext,\n  RumXhrStartContext,\n} from '../requestCollection'\nimport type { RumSessionManager } from '../rumSessionManager'\nimport type { PropagatorType, TracingOption } from './tracer.types'\n\nexport interface Tracer {\n  traceFetch: (context: Partial<RumFetchStartContext>) => void\n  traceXhr: (context: Partial<RumXhrStartContext>, xhr: XMLHttpRequest) => void\n  clearTracingIfNeeded: (context: RumFetchResolveContext | RumXhrCompleteContext) => void\n}\n\ninterface TracingHeaders {\n  [key: string]: string\n}\n\nexport function isTracingOption(item: unknown): item is TracingOption {\n  const expectedItem = item as TracingOption\n  return (\n    getType(expectedItem) === 'object' &&\n    isMatchOption(expectedItem.match) &&\n    Array.isArray(expectedItem.propagatorTypes)\n  )\n}\n\n/**\n * Clear tracing information to avoid incomplete traces. Ideally, we should do it when the\n * request did not reach the server, but the browser does not expose this. So, we clear tracing\n * information if the request ended with status 0 without being aborted by the application.\n *\n * Reasoning:\n *\n * * Applications are usually aborting requests after a bit of time, for example when the user is\n * typing (autocompletion) or navigating away (in a SPA). With a performant device and good\n * network conditions, the request is likely to reach the server before being canceled.\n *\n * * Requests aborted otherwise (ex: lack of internet, CORS issue, blocked by a privacy extension)\n * are likely to finish quickly and without reaching the server.\n *\n * Of course, it might not be the case every time, but it should limit having incomplete traces a\n * bit.\n * */\nexport function clearTracingIfNeeded(context: RumFetchResolveContext | RumXhrCompleteContext) {\n  if (context.status === 0 && !context.isAborted) {\n    context.traceId = undefined\n    context.spanId = undefined\n    context.traceSampled = undefined\n  }\n}\n\nexport function startTracer(configuration: RumConfiguration, sessionManager: RumSessionManager): Tracer {\n  return {\n    clearTracingIfNeeded,\n    traceFetch: (context) =>\n      injectHeadersIfTracingAllowed(configuration, context, sessionManager, (tracingHeaders: TracingHeaders) => {\n        if (context.input instanceof Request && !context.init?.headers) {\n          context.input = new Request(context.input)\n          Object.keys(tracingHeaders).forEach((key) => {\n            ;(context.input as Request).headers.append(key, tracingHeaders[key])\n          })\n        } else {\n          context.init = shallowClone(context.init)\n          const headers: Array<[string, string]> = []\n          if (context.init.headers instanceof Headers) {\n            context.init.headers.forEach((value, key) => {\n              headers.push([key, value])\n            })\n          } else if (Array.isArray(context.init.headers)) {\n            context.init.headers.forEach((header) => {\n              headers.push(header)\n            })\n          } else if (context.init.headers) {\n            Object.keys(context.init.headers).forEach((key) => {\n              headers.push([key, (context.init!.headers as Record<string, string>)[key]])\n            })\n          }\n          context.init.headers = headers.concat(objectEntries(tracingHeaders))\n        }\n      }),\n    traceXhr: (context, xhr) =>\n      injectHeadersIfTracingAllowed(configuration, context, sessionManager, (tracingHeaders: TracingHeaders) => {\n        Object.keys(tracingHeaders).forEach((name) => {\n          xhr.setRequestHeader(name, tracingHeaders[name])\n        })\n      }),\n  }\n}\n\nfunction injectHeadersIfTracingAllowed(\n  configuration: RumConfiguration,\n  context: Partial<RumFetchStartContext | RumXhrStartContext>,\n  sessionManager: RumSessionManager,\n  inject: (tracingHeaders: TracingHeaders) => void\n) {\n  if (!isTracingSupported() || !sessionManager.findTrackedSession()) {\n    return\n  }\n\n  const tracingOption = find(configuration.allowedTracingUrls, (tracingOption: TracingOption) =>\n    matchList([tracingOption.match], context.url!, true)\n  )\n  if (!tracingOption) {\n    return\n  }\n  context.traceSampled = !isNumber(configuration.traceSampleRate) || performDraw(configuration.traceSampleRate)\n\n  if (!context.traceSampled && configuration.traceContextInjection !== TraceContextInjection.ALL) {\n    return\n  }\n\n  context.traceId = new TraceIdentifier()\n  context.spanId = new TraceIdentifier()\n\n  inject(makeTracingHeaders(context.traceId, context.spanId, context.traceSampled, tracingOption.propagatorTypes))\n}\n\nexport function isTracingSupported() {\n  return getCrypto() !== undefined\n}\n\nfunction getCrypto() {\n  return window.crypto || (window as any).msCrypto\n}\n\n/**\n * When trace is not sampled, set priority to '0' instead of not adding the tracing headers\n * to prepare the implementation for sampling delegation.\n */\nfunction makeTracingHeaders(\n  traceId: TraceIdentifier,\n  spanId: TraceIdentifier,\n  traceSampled: boolean,\n  propagatorTypes: PropagatorType[]\n): TracingHeaders {\n  const tracingHeaders: TracingHeaders = {}\n\n  propagatorTypes.forEach((propagatorType) => {\n    switch (propagatorType) {\n      case 'datadog': {\n        assign(tracingHeaders, {\n          'x-datadog-origin': 'rum',\n          'x-datadog-parent-id': spanId.toDecimalString(),\n          'x-datadog-sampling-priority': traceSampled ? '1' : '0',\n          'x-datadog-trace-id': traceId.toDecimalString(),\n        })\n        break\n      }\n      // https://www.w3.org/TR/trace-context/\n      case 'tracecontext': {\n        assign(tracingHeaders, {\n          traceparent: `00-0000000000000000${traceId.toPaddedHexadecimalString()}-${spanId.toPaddedHexadecimalString()}-0${\n            traceSampled ? '1' : '0'\n          }`,\n        })\n        break\n      }\n      // https://github.com/openzipkin/b3-propagation\n      case 'b3': {\n        assign(tracingHeaders, {\n          b3: `${traceId.toPaddedHexadecimalString()}-${spanId.toPaddedHexadecimalString()}-${\n            traceSampled ? '1' : '0'\n          }`,\n        })\n        break\n      }\n      case 'b3multi': {\n        assign(tracingHeaders, {\n          'X-B3-TraceId': traceId.toPaddedHexadecimalString(),\n          'X-B3-SpanId': spanId.toPaddedHexadecimalString(),\n          'X-B3-Sampled': traceSampled ? '1' : '0',\n        })\n        break\n      }\n    }\n  })\n  return tracingHeaders\n}\n\n/* eslint-disable no-bitwise */\nexport class TraceIdentifier {\n  private buffer: Uint8Array = new Uint8Array(8)\n\n  constructor() {\n    getCrypto().getRandomValues(this.buffer)\n    this.buffer[0] = this.buffer[0] & 0x7f // force 63-bit\n  }\n\n  toString(radix: number) {\n    let high = this.readInt32(0)\n    let low = this.readInt32(4)\n    let str = ''\n\n    do {\n      const mod = (high % radix) * 4294967296 + low\n      high = Math.floor(high / radix)\n      low = Math.floor(mod / radix)\n      str = (mod % radix).toString(radix) + str\n    } while (high || low)\n\n    return str\n  }\n\n  /**\n   * Format used everywhere except the trace intake\n   */\n  toDecimalString() {\n    return this.toString(10)\n  }\n\n  /**\n   * Format used by OTel headers\n   */\n  toPaddedHexadecimalString() {\n    const traceId = this.toString(16)\n    return Array(17 - traceId.length).join('0') + traceId\n  }\n\n  private readInt32(offset: number) {\n    return (\n      this.buffer[offset] * 16777216 +\n      (this.buffer[offset + 1] << 16) +\n      (this.buffer[offset + 2] << 8) +\n      this.buffer[offset + 3]\n    )\n  }\n}\n/* eslint-enable no-bitwise */\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}