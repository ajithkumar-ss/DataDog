{"ast":null,"code":"import { display } from '../display';\nimport { ONE_KIBI_BYTE } from '../utils/byteUtils';\nimport { detachToJsonMethod } from './jsonStringify';\n// The maximum size of a single event is 256KiB. By default, we ensure that user-provided data\n// going through sanitize fits inside our events, while leaving room for other contexts, metadata, ...\nvar SANITIZE_DEFAULT_MAX_CHARACTER_COUNT = 220 * ONE_KIBI_BYTE;\n// Symbol for the root element of the JSONPath used for visited objects\nvar JSON_PATH_ROOT_ELEMENT = '$';\n// When serializing (using JSON.stringify) a key of an object, { key: 42 } gets wrapped in quotes as \"key\".\n// With the separator (:), we need to add 3 characters to the count.\nvar KEY_DECORATION_LENGTH = 3;\nexport function sanitize(source, maxCharacterCount) {\n  var _a;\n  if (maxCharacterCount === void 0) {\n    maxCharacterCount = SANITIZE_DEFAULT_MAX_CHARACTER_COUNT;\n  }\n  // Unbind any toJSON function we may have on [] or {} prototypes\n  var restoreObjectPrototypeToJson = detachToJsonMethod(Object.prototype);\n  var restoreArrayPrototypeToJson = detachToJsonMethod(Array.prototype);\n  // Initial call to sanitizeProcessor - will populate containerQueue if source is an Array or a plain Object\n  var containerQueue = [];\n  var visitedObjectsWithPath = new WeakMap();\n  var sanitizedData = sanitizeProcessor(source, JSON_PATH_ROOT_ELEMENT, undefined, containerQueue, visitedObjectsWithPath);\n  var accumulatedCharacterCount = ((_a = JSON.stringify(sanitizedData)) === null || _a === void 0 ? void 0 : _a.length) || 0;\n  if (accumulatedCharacterCount > maxCharacterCount) {\n    warnOverCharacterLimit(maxCharacterCount, 'discarded', source);\n    return undefined;\n  }\n  while (containerQueue.length > 0 && accumulatedCharacterCount < maxCharacterCount) {\n    var containerToProcess = containerQueue.shift();\n    var separatorLength = 0; // 0 for the first element, 1 for subsequent elements\n    // Arrays and Objects have to be handled distinctly to ensure\n    // we do not pick up non-numerical properties from Arrays\n    if (Array.isArray(containerToProcess.source)) {\n      for (var key = 0; key < containerToProcess.source.length; key++) {\n        var targetData = sanitizeProcessor(containerToProcess.source[key], containerToProcess.path, key, containerQueue, visitedObjectsWithPath);\n        if (targetData !== undefined) {\n          accumulatedCharacterCount += JSON.stringify(targetData).length;\n        } else {\n          // When an element of an Array (targetData) is undefined, it is serialized as null:\n          // JSON.stringify([undefined]) => '[null]' - This accounts for 4 characters\n          accumulatedCharacterCount += 4;\n        }\n        accumulatedCharacterCount += separatorLength;\n        separatorLength = 1;\n        if (accumulatedCharacterCount > maxCharacterCount) {\n          warnOverCharacterLimit(maxCharacterCount, 'truncated', source);\n          break;\n        }\n        ;\n        containerToProcess.target[key] = targetData;\n      }\n    } else {\n      for (var key in containerToProcess.source) {\n        if (Object.prototype.hasOwnProperty.call(containerToProcess.source, key)) {\n          var targetData = sanitizeProcessor(containerToProcess.source[key], containerToProcess.path, key, containerQueue, visitedObjectsWithPath);\n          // When a property of an object has an undefined value, it will be dropped during serialization:\n          // JSON.stringify({a:undefined}) => '{}'\n          if (targetData !== undefined) {\n            accumulatedCharacterCount += JSON.stringify(targetData).length + separatorLength + key.length + KEY_DECORATION_LENGTH;\n            separatorLength = 1;\n          }\n          if (accumulatedCharacterCount > maxCharacterCount) {\n            warnOverCharacterLimit(maxCharacterCount, 'truncated', source);\n            break;\n          }\n          ;\n          containerToProcess.target[key] = targetData;\n        }\n      }\n    }\n  }\n  // Rebind detached toJSON functions\n  restoreObjectPrototypeToJson();\n  restoreArrayPrototypeToJson();\n  return sanitizedData;\n}\n/**\n * Internal function to factorize the process common to the\n * initial call to sanitize, and iterations for Arrays and Objects\n *\n */\nfunction sanitizeProcessor(source, parentPath, key, queue, visitedObjectsWithPath) {\n  // Start by handling toJSON, as we want to sanitize its output\n  var sourceToSanitize = tryToApplyToJSON(source);\n  if (!sourceToSanitize || typeof sourceToSanitize !== 'object') {\n    return sanitizePrimitivesAndFunctions(sourceToSanitize);\n  }\n  var sanitizedSource = sanitizeObjects(sourceToSanitize);\n  if (sanitizedSource !== '[Object]' && sanitizedSource !== '[Array]' && sanitizedSource !== '[Error]') {\n    return sanitizedSource;\n  }\n  // Handle potential cyclic references\n  // We need to use source as sourceToSanitize could be a reference to a new object\n  // At this stage, we know the source is an object type\n  var sourceAsObject = source;\n  if (visitedObjectsWithPath.has(sourceAsObject)) {\n    return \"[Reference seen at \".concat(visitedObjectsWithPath.get(sourceAsObject), \"]\");\n  }\n  // Add processed source to queue\n  var currentPath = key !== undefined ? \"\".concat(parentPath, \".\").concat(key) : parentPath;\n  var target = Array.isArray(sourceToSanitize) ? [] : {};\n  visitedObjectsWithPath.set(sourceAsObject, currentPath);\n  queue.push({\n    source: sourceToSanitize,\n    target: target,\n    path: currentPath\n  });\n  return target;\n}\n/**\n * Handles sanitization of simple, non-object types\n *\n */\nfunction sanitizePrimitivesAndFunctions(value) {\n  // BigInt cannot be serialized by JSON.stringify(), convert it to a string representation\n  if (typeof value === 'bigint') {\n    return \"[BigInt] \".concat(value.toString());\n  }\n  // Functions cannot be serialized by JSON.stringify(). Moreover, if a faulty toJSON is present, it needs to be converted\n  // so it won't prevent stringify from serializing later\n  if (typeof value === 'function') {\n    return \"[Function] \".concat(value.name || 'unknown');\n  }\n  // JSON.stringify() does not serialize symbols.\n  if (typeof value === 'symbol') {\n    return \"[Symbol] \".concat(value.description || value.toString());\n  }\n  return value;\n}\n/**\n * Handles sanitization of object types\n *\n * LIMITATIONS\n * - If a class defines a toStringTag Symbol, it will fall in the catch-all method and prevent enumeration of properties.\n * To avoid this, a toJSON method can be defined.\n * - IE11 does not return a distinct type for objects such as Map, WeakMap, ... These objects will pass through and their\n * properties enumerated if any.\n *\n */\nfunction sanitizeObjects(value) {\n  try {\n    // Handle events - Keep a simple implementation to avoid breaking changes\n    if (value instanceof Event) {\n      return {\n        isTrusted: value.isTrusted\n      };\n    }\n    // Handle all remaining object types in a generic way\n    var result = Object.prototype.toString.call(value);\n    var match = result.match(/\\[object (.*)\\]/);\n    if (match && match[1]) {\n      return \"[\".concat(match[1], \"]\");\n    }\n  } catch (_a) {\n    // If the previous serialization attempts failed, and we cannot convert using\n    // Object.prototype.toString, declare the value unserializable\n  }\n  return '[Unserializable]';\n}\n/**\n * Checks if a toJSON function exists and tries to execute it\n *\n */\nfunction tryToApplyToJSON(value) {\n  var object = value;\n  if (object && typeof object.toJSON === 'function') {\n    try {\n      return object.toJSON();\n    } catch (_a) {\n      // If toJSON fails, we continue by trying to serialize the value manually\n    }\n  }\n  return value;\n}\n/**\n * Helper function to display the warning when the accumulated character count is over the limit\n */\nfunction warnOverCharacterLimit(maxCharacterCount, changeType, source) {\n  display.warn(\"The data provided has been \".concat(changeType, \" as it is over the limit of \").concat(maxCharacterCount, \" characters:\"), source);\n}","map":{"version":3,"names":["display","ONE_KIBI_BYTE","detachToJsonMethod","SANITIZE_DEFAULT_MAX_CHARACTER_COUNT","JSON_PATH_ROOT_ELEMENT","KEY_DECORATION_LENGTH","sanitize","source","maxCharacterCount","restoreObjectPrototypeToJson","Object","prototype","restoreArrayPrototypeToJson","Array","containerQueue","visitedObjectsWithPath","WeakMap","sanitizedData","sanitizeProcessor","undefined","accumulatedCharacterCount","_a","JSON","stringify","length","warnOverCharacterLimit","containerToProcess","shift","separatorLength","isArray","key","targetData","path","target","hasOwnProperty","call","parentPath","queue","sourceToSanitize","tryToApplyToJSON","sanitizePrimitivesAndFunctions","sanitizedSource","sanitizeObjects","sourceAsObject","has","concat","get","currentPath","set","push","value","toString","name","description","Event","isTrusted","result","match","object","toJSON","changeType","warn"],"sources":["D:\\edu'\\Spritle\\spritle\\node_modules\\@datadog\\browser-core\\src\\tools\\serialisation\\sanitize.ts"],"sourcesContent":["import { display } from '../display'\nimport { ONE_KIBI_BYTE } from '../utils/byteUtils'\nimport type { Context, ContextArray, ContextValue } from './context'\nimport type { ObjectWithToJsonMethod } from './jsonStringify'\nimport { detachToJsonMethod } from './jsonStringify'\n\n// eslint-disable-next-line @typescript-eslint/ban-types\ntype PrimitivesAndFunctions = string | number | boolean | undefined | null | symbol | bigint | Function\ntype ExtendedContextValue = PrimitivesAndFunctions | object | ExtendedContext | ExtendedContextArray\ntype ExtendedContext = { [key: string]: ExtendedContextValue }\ntype ExtendedContextArray = ExtendedContextValue[]\n\ntype ContainerElementToProcess = {\n  source: ExtendedContextArray | ExtendedContext\n  target: ContextArray | Context\n  path: string\n}\n\n// The maximum size of a single event is 256KiB. By default, we ensure that user-provided data\n// going through sanitize fits inside our events, while leaving room for other contexts, metadata, ...\nconst SANITIZE_DEFAULT_MAX_CHARACTER_COUNT = 220 * ONE_KIBI_BYTE\n\n// Symbol for the root element of the JSONPath used for visited objects\nconst JSON_PATH_ROOT_ELEMENT = '$'\n\n// When serializing (using JSON.stringify) a key of an object, { key: 42 } gets wrapped in quotes as \"key\".\n// With the separator (:), we need to add 3 characters to the count.\nconst KEY_DECORATION_LENGTH = 3\n\n/**\n * Ensures user-provided data is 'safe' for the SDK\n * - Deep clones data\n * - Removes cyclic references\n * - Transforms unserializable types to a string representation\n *\n * LIMITATIONS:\n * - Size is in characters, not byte count (may differ according to character encoding)\n * - Size does not take into account indentation that can be applied to JSON.stringify\n * - Non-numerical properties of Arrays are ignored. Same behavior as JSON.stringify\n *\n * @param source              User-provided data meant to be serialized using JSON.stringify\n * @param maxCharacterCount   Maximum number of characters allowed in serialized form\n */\nexport function sanitize(source: string, maxCharacterCount?: number): string | undefined\nexport function sanitize(source: Context, maxCharacterCount?: number): Context\nexport function sanitize(source: unknown, maxCharacterCount?: number): ContextValue\nexport function sanitize(source: unknown, maxCharacterCount = SANITIZE_DEFAULT_MAX_CHARACTER_COUNT) {\n  // Unbind any toJSON function we may have on [] or {} prototypes\n  const restoreObjectPrototypeToJson = detachToJsonMethod(Object.prototype)\n  const restoreArrayPrototypeToJson = detachToJsonMethod(Array.prototype)\n\n  // Initial call to sanitizeProcessor - will populate containerQueue if source is an Array or a plain Object\n  const containerQueue: ContainerElementToProcess[] = []\n  const visitedObjectsWithPath = new WeakMap<object, string>()\n  const sanitizedData = sanitizeProcessor(\n    source as ExtendedContextValue,\n    JSON_PATH_ROOT_ELEMENT,\n    undefined,\n    containerQueue,\n    visitedObjectsWithPath\n  )\n  let accumulatedCharacterCount = JSON.stringify(sanitizedData)?.length || 0\n  if (accumulatedCharacterCount > maxCharacterCount) {\n    warnOverCharacterLimit(maxCharacterCount, 'discarded', source)\n    return undefined\n  }\n\n  while (containerQueue.length > 0 && accumulatedCharacterCount < maxCharacterCount) {\n    const containerToProcess = containerQueue.shift()!\n    let separatorLength = 0 // 0 for the first element, 1 for subsequent elements\n\n    // Arrays and Objects have to be handled distinctly to ensure\n    // we do not pick up non-numerical properties from Arrays\n    if (Array.isArray(containerToProcess.source)) {\n      for (let key = 0; key < containerToProcess.source.length; key++) {\n        const targetData = sanitizeProcessor(\n          containerToProcess.source[key],\n          containerToProcess.path,\n          key,\n          containerQueue,\n          visitedObjectsWithPath\n        )\n\n        if (targetData !== undefined) {\n          accumulatedCharacterCount += JSON.stringify(targetData).length\n        } else {\n          // When an element of an Array (targetData) is undefined, it is serialized as null:\n          // JSON.stringify([undefined]) => '[null]' - This accounts for 4 characters\n          accumulatedCharacterCount += 4\n        }\n        accumulatedCharacterCount += separatorLength\n        separatorLength = 1\n        if (accumulatedCharacterCount > maxCharacterCount) {\n          warnOverCharacterLimit(maxCharacterCount, 'truncated', source)\n          break\n        }\n        ;(containerToProcess.target as ContextArray)[key] = targetData\n      }\n    } else {\n      for (const key in containerToProcess.source) {\n        if (Object.prototype.hasOwnProperty.call(containerToProcess.source, key)) {\n          const targetData = sanitizeProcessor(\n            containerToProcess.source[key],\n            containerToProcess.path,\n            key,\n            containerQueue,\n            visitedObjectsWithPath\n          )\n          // When a property of an object has an undefined value, it will be dropped during serialization:\n          // JSON.stringify({a:undefined}) => '{}'\n          if (targetData !== undefined) {\n            accumulatedCharacterCount +=\n              JSON.stringify(targetData).length + separatorLength + key.length + KEY_DECORATION_LENGTH\n            separatorLength = 1\n          }\n          if (accumulatedCharacterCount > maxCharacterCount) {\n            warnOverCharacterLimit(maxCharacterCount, 'truncated', source)\n            break\n          }\n          ;(containerToProcess.target as Context)[key] = targetData\n        }\n      }\n    }\n  }\n\n  // Rebind detached toJSON functions\n  restoreObjectPrototypeToJson()\n  restoreArrayPrototypeToJson()\n\n  return sanitizedData\n}\n\n/**\n * Internal function to factorize the process common to the\n * initial call to sanitize, and iterations for Arrays and Objects\n *\n */\nfunction sanitizeProcessor(\n  source: ExtendedContextValue,\n  parentPath: string,\n  key: string | number | undefined,\n  queue: ContainerElementToProcess[],\n  visitedObjectsWithPath: WeakMap<object, string>\n) {\n  // Start by handling toJSON, as we want to sanitize its output\n  const sourceToSanitize = tryToApplyToJSON(source)\n\n  if (!sourceToSanitize || typeof sourceToSanitize !== 'object') {\n    return sanitizePrimitivesAndFunctions(sourceToSanitize)\n  }\n\n  const sanitizedSource = sanitizeObjects(sourceToSanitize)\n  if (sanitizedSource !== '[Object]' && sanitizedSource !== '[Array]' && sanitizedSource !== '[Error]') {\n    return sanitizedSource\n  }\n\n  // Handle potential cyclic references\n  // We need to use source as sourceToSanitize could be a reference to a new object\n  // At this stage, we know the source is an object type\n  const sourceAsObject = source as object\n  if (visitedObjectsWithPath.has(sourceAsObject)) {\n    return `[Reference seen at ${visitedObjectsWithPath.get(sourceAsObject)!}]`\n  }\n\n  // Add processed source to queue\n  const currentPath = key !== undefined ? `${parentPath}.${key}` : parentPath\n  const target = Array.isArray(sourceToSanitize) ? ([] as ContextArray) : ({} as Context)\n  visitedObjectsWithPath.set(sourceAsObject, currentPath)\n  queue.push({ source: sourceToSanitize as ExtendedContext | ExtendedContextArray, target, path: currentPath })\n\n  return target\n}\n\n/**\n * Handles sanitization of simple, non-object types\n *\n */\nfunction sanitizePrimitivesAndFunctions(value: PrimitivesAndFunctions) {\n  // BigInt cannot be serialized by JSON.stringify(), convert it to a string representation\n  if (typeof value === 'bigint') {\n    return `[BigInt] ${value.toString()}`\n  }\n  // Functions cannot be serialized by JSON.stringify(). Moreover, if a faulty toJSON is present, it needs to be converted\n  // so it won't prevent stringify from serializing later\n  if (typeof value === 'function') {\n    return `[Function] ${value.name || 'unknown'}`\n  }\n  // JSON.stringify() does not serialize symbols.\n  if (typeof value === 'symbol') {\n    // symbol.description is part of ES2019+\n    type symbolWithDescription = symbol & { description: string }\n    return `[Symbol] ${(value as symbolWithDescription).description || value.toString()}`\n  }\n\n  return value\n}\n\n/**\n * Handles sanitization of object types\n *\n * LIMITATIONS\n * - If a class defines a toStringTag Symbol, it will fall in the catch-all method and prevent enumeration of properties.\n * To avoid this, a toJSON method can be defined.\n * - IE11 does not return a distinct type for objects such as Map, WeakMap, ... These objects will pass through and their\n * properties enumerated if any.\n *\n */\nfunction sanitizeObjects(value: object) {\n  try {\n    // Handle events - Keep a simple implementation to avoid breaking changes\n    if (value instanceof Event) {\n      return {\n        isTrusted: value.isTrusted,\n      }\n    }\n\n    // Handle all remaining object types in a generic way\n    const result = Object.prototype.toString.call(value)\n    const match = result.match(/\\[object (.*)\\]/)\n    if (match && match[1]) {\n      return `[${match[1]}]`\n    }\n  } catch {\n    // If the previous serialization attempts failed, and we cannot convert using\n    // Object.prototype.toString, declare the value unserializable\n  }\n  return '[Unserializable]'\n}\n\n/**\n * Checks if a toJSON function exists and tries to execute it\n *\n */\nfunction tryToApplyToJSON(value: ExtendedContextValue) {\n  const object = value as ObjectWithToJsonMethod\n  if (object && typeof object.toJSON === 'function') {\n    try {\n      return object.toJSON() as ExtendedContextValue\n    } catch {\n      // If toJSON fails, we continue by trying to serialize the value manually\n    }\n  }\n\n  return value\n}\n\n/**\n * Helper function to display the warning when the accumulated character count is over the limit\n */\nfunction warnOverCharacterLimit(maxCharacterCount: number, changeType: 'discarded' | 'truncated', source: unknown) {\n  display.warn(\n    `The data provided has been ${changeType} as it is over the limit of ${maxCharacterCount} characters:`,\n    source\n  )\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}