{"ast":null,"code":"import { isNodeShadowRoot, hasChildNodes, forEachChildNodes } from '@datadog/browser-rum-core';\nimport { assign } from '@datadog/browser-core';\nimport { NodeType } from '../../../types';\nimport { NodePrivacyLevel, PRIVACY_ATTR_NAME, PRIVACY_ATTR_VALUE_HIDDEN } from '../../../constants';\nimport { reducePrivacyLevel, getNodeSelfPrivacyLevel, getTextContent } from '../privacy';\nimport { getSerializedNodeId, getValidTagName, setSerializedNodeId } from './serializationUtils';\nimport { serializeStyleSheets } from './serializeStyleSheets';\nimport { serializeAttributes } from './serializeAttributes';\nexport function serializeNodeWithId(node, options) {\n  var serializedNode = serializeNode(node, options);\n  if (!serializedNode) {\n    return null;\n  }\n  // Try to reuse the previous id\n  var id = getSerializedNodeId(node) || generateNextId();\n  var serializedNodeWithId = serializedNode;\n  serializedNodeWithId.id = id;\n  setSerializedNodeId(node, id);\n  if (options.serializedNodeIds) {\n    options.serializedNodeIds.add(id);\n  }\n  return serializedNodeWithId;\n}\nvar _nextId = 1;\nexport function generateNextId() {\n  return _nextId++;\n}\nexport function serializeChildNodes(node, options) {\n  var result = [];\n  forEachChildNodes(node, function (childNode) {\n    var serializedChildNode = serializeNodeWithId(childNode, options);\n    if (serializedChildNode) {\n      result.push(serializedChildNode);\n    }\n  });\n  return result;\n}\nfunction serializeNode(node, options) {\n  switch (node.nodeType) {\n    case node.DOCUMENT_NODE:\n      return serializeDocumentNode(node, options);\n    case node.DOCUMENT_FRAGMENT_NODE:\n      return serializeDocumentFragmentNode(node, options);\n    case node.DOCUMENT_TYPE_NODE:\n      return serializeDocumentTypeNode(node);\n    case node.ELEMENT_NODE:\n      return serializeElementNode(node, options);\n    case node.TEXT_NODE:\n      return serializeTextNode(node, options);\n    case node.CDATA_SECTION_NODE:\n      return serializeCDataNode();\n  }\n}\nexport function serializeDocumentNode(document, options) {\n  return {\n    type: NodeType.Document,\n    childNodes: serializeChildNodes(document, options),\n    adoptedStyleSheets: serializeStyleSheets(document.adoptedStyleSheets)\n  };\n}\nfunction serializeDocumentFragmentNode(element, options) {\n  var isShadowRoot = isNodeShadowRoot(element);\n  if (isShadowRoot) {\n    options.serializationContext.shadowRootsController.addShadowRoot(element);\n  }\n  return {\n    type: NodeType.DocumentFragment,\n    childNodes: serializeChildNodes(element, options),\n    isShadowRoot: isShadowRoot,\n    adoptedStyleSheets: isShadowRoot ? serializeStyleSheets(element.adoptedStyleSheets) : undefined\n  };\n}\nfunction serializeDocumentTypeNode(documentType) {\n  return {\n    type: NodeType.DocumentType,\n    name: documentType.name,\n    publicId: documentType.publicId,\n    systemId: documentType.systemId\n  };\n}\n/**\n * Serializing Element nodes involves capturing:\n * 1. HTML ATTRIBUTES:\n * 2. JS STATE:\n * - scroll offsets\n * - Form fields (input value, checkbox checked, option selection, range)\n * - Canvas state,\n * - Media (video/audio) play mode + currentTime\n * - iframe contents\n * - webcomponents\n * 3. CUSTOM PROPERTIES:\n * - height+width for when `hidden` to cover the element\n * 4. EXCLUDED INTERACTION STATE:\n * - focus (possible, but not worth perf impact)\n * - hover (tracked only via mouse activity)\n * - fullscreen mode\n */\nfunction serializeElementNode(element, options) {\n  var _a;\n  var tagName = getValidTagName(element.tagName);\n  var isSVG = isSVGElement(element) || undefined;\n  // For performance reason, we don't use getNodePrivacyLevel directly: we leverage the\n  // parentNodePrivacyLevel option to avoid iterating over all parents\n  var nodePrivacyLevel = reducePrivacyLevel(getNodeSelfPrivacyLevel(element), options.parentNodePrivacyLevel);\n  if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n    var _b = element.getBoundingClientRect(),\n      width = _b.width,\n      height = _b.height;\n    return {\n      type: NodeType.Element,\n      tagName: tagName,\n      attributes: (_a = {\n        rr_width: \"\".concat(width, \"px\"),\n        rr_height: \"\".concat(height, \"px\")\n      }, _a[PRIVACY_ATTR_NAME] = PRIVACY_ATTR_VALUE_HIDDEN, _a),\n      childNodes: [],\n      isSVG: isSVG\n    };\n  }\n  // Ignore Elements like Script and some Link, Metas\n  if (nodePrivacyLevel === NodePrivacyLevel.IGNORE) {\n    return;\n  }\n  var attributes = serializeAttributes(element, nodePrivacyLevel, options);\n  var childNodes = [];\n  if (hasChildNodes(element) &&\n  // Do not serialize style children as the css rules are already in the _cssText attribute\n  tagName !== 'style') {\n    // OBJECT POOLING OPTIMIZATION:\n    // We should not create a new object systematically as it could impact performances. Try to reuse\n    // the same object as much as possible, and clone it only if we need to.\n    var childNodesSerializationOptions = void 0;\n    if (options.parentNodePrivacyLevel === nodePrivacyLevel && options.ignoreWhiteSpace === (tagName === 'head')) {\n      childNodesSerializationOptions = options;\n    } else {\n      childNodesSerializationOptions = assign({}, options, {\n        parentNodePrivacyLevel: nodePrivacyLevel,\n        ignoreWhiteSpace: tagName === 'head'\n      });\n    }\n    childNodes = serializeChildNodes(element, childNodesSerializationOptions);\n  }\n  return {\n    type: NodeType.Element,\n    tagName: tagName,\n    attributes: attributes,\n    childNodes: childNodes,\n    isSVG: isSVG\n  };\n}\nfunction isSVGElement(el) {\n  return el.tagName === 'svg' || el instanceof SVGElement;\n}\n/**\n * Text Nodes are dependant on Element nodes\n * Privacy levels are set on elements so we check the parentElement of a text node\n * for privacy level.\n */\nfunction serializeTextNode(textNode, options) {\n  var textContent = getTextContent(textNode, options.ignoreWhiteSpace || false, options.parentNodePrivacyLevel);\n  if (textContent === undefined) {\n    return;\n  }\n  return {\n    type: NodeType.Text,\n    textContent: textContent\n  };\n}\nfunction serializeCDataNode() {\n  return {\n    type: NodeType.CDATA,\n    textContent: ''\n  };\n}","map":{"version":3,"names":["isNodeShadowRoot","hasChildNodes","forEachChildNodes","assign","NodeType","NodePrivacyLevel","PRIVACY_ATTR_NAME","PRIVACY_ATTR_VALUE_HIDDEN","reducePrivacyLevel","getNodeSelfPrivacyLevel","getTextContent","getSerializedNodeId","getValidTagName","setSerializedNodeId","serializeStyleSheets","serializeAttributes","serializeNodeWithId","node","options","serializedNode","serializeNode","id","generateNextId","serializedNodeWithId","serializedNodeIds","add","_nextId","serializeChildNodes","result","childNode","serializedChildNode","push","nodeType","DOCUMENT_NODE","serializeDocumentNode","DOCUMENT_FRAGMENT_NODE","serializeDocumentFragmentNode","DOCUMENT_TYPE_NODE","serializeDocumentTypeNode","ELEMENT_NODE","serializeElementNode","TEXT_NODE","serializeTextNode","CDATA_SECTION_NODE","serializeCDataNode","document","type","Document","childNodes","adoptedStyleSheets","element","isShadowRoot","serializationContext","shadowRootsController","addShadowRoot","DocumentFragment","undefined","documentType","DocumentType","name","publicId","systemId","tagName","isSVG","isSVGElement","nodePrivacyLevel","parentNodePrivacyLevel","HIDDEN","_b","getBoundingClientRect","width","height","Element","attributes","_a","rr_width","concat","rr_height","IGNORE","childNodesSerializationOptions","ignoreWhiteSpace","el","SVGElement","textNode","textContent","Text","CDATA"],"sources":["D:\\edu'\\Spritle\\spritle\\node_modules\\@datadog\\browser-rum\\src\\domain\\record\\serialization\\serializeNode.ts"],"sourcesContent":["import { isNodeShadowRoot, hasChildNodes, forEachChildNodes } from '@datadog/browser-rum-core'\nimport { assign } from '@datadog/browser-core'\nimport type {\n  DocumentFragmentNode,\n  DocumentNode,\n  SerializedNode,\n  SerializedNodeWithId,\n  CDataNode,\n  DocumentTypeNode,\n  ElementNode,\n  TextNode,\n} from '../../../types'\nimport { NodeType } from '../../../types'\nimport { NodePrivacyLevel, PRIVACY_ATTR_NAME, PRIVACY_ATTR_VALUE_HIDDEN } from '../../../constants'\nimport { reducePrivacyLevel, getNodeSelfPrivacyLevel, getTextContent } from '../privacy'\nimport { getSerializedNodeId, getValidTagName, setSerializedNodeId } from './serializationUtils'\nimport type { SerializeOptions } from './serialization.types'\nimport { serializeStyleSheets } from './serializeStyleSheets'\nimport { serializeAttributes } from './serializeAttributes'\n\nexport function serializeNodeWithId(node: Node, options: SerializeOptions): SerializedNodeWithId | null {\n  const serializedNode = serializeNode(node, options)\n  if (!serializedNode) {\n    return null\n  }\n\n  // Try to reuse the previous id\n  const id = getSerializedNodeId(node) || generateNextId()\n  const serializedNodeWithId = serializedNode as SerializedNodeWithId\n  serializedNodeWithId.id = id\n  setSerializedNodeId(node, id)\n  if (options.serializedNodeIds) {\n    options.serializedNodeIds.add(id)\n  }\n  return serializedNodeWithId\n}\n\nlet _nextId = 1\nexport function generateNextId(): number {\n  return _nextId++\n}\n\nexport function serializeChildNodes(node: Node, options: SerializeOptions): SerializedNodeWithId[] {\n  const result: SerializedNodeWithId[] = []\n  forEachChildNodes(node, (childNode) => {\n    const serializedChildNode = serializeNodeWithId(childNode, options)\n    if (serializedChildNode) {\n      result.push(serializedChildNode)\n    }\n  })\n  return result\n}\n\nfunction serializeNode(node: Node, options: SerializeOptions): SerializedNode | undefined {\n  switch (node.nodeType) {\n    case node.DOCUMENT_NODE:\n      return serializeDocumentNode(node as Document, options)\n    case node.DOCUMENT_FRAGMENT_NODE:\n      return serializeDocumentFragmentNode(node as DocumentFragment, options)\n    case node.DOCUMENT_TYPE_NODE:\n      return serializeDocumentTypeNode(node as DocumentType)\n    case node.ELEMENT_NODE:\n      return serializeElementNode(node as Element, options)\n    case node.TEXT_NODE:\n      return serializeTextNode(node as Text, options)\n    case node.CDATA_SECTION_NODE:\n      return serializeCDataNode()\n  }\n}\n\nexport function serializeDocumentNode(document: Document, options: SerializeOptions): DocumentNode {\n  return {\n    type: NodeType.Document,\n    childNodes: serializeChildNodes(document, options),\n    adoptedStyleSheets: serializeStyleSheets(document.adoptedStyleSheets),\n  }\n}\n\nfunction serializeDocumentFragmentNode(\n  element: DocumentFragment,\n  options: SerializeOptions\n): DocumentFragmentNode | undefined {\n  const isShadowRoot = isNodeShadowRoot(element)\n  if (isShadowRoot) {\n    options.serializationContext.shadowRootsController.addShadowRoot(element)\n  }\n\n  return {\n    type: NodeType.DocumentFragment,\n    childNodes: serializeChildNodes(element, options),\n    isShadowRoot,\n    adoptedStyleSheets: isShadowRoot ? serializeStyleSheets(element.adoptedStyleSheets) : undefined,\n  }\n}\n\nfunction serializeDocumentTypeNode(documentType: DocumentType): DocumentTypeNode {\n  return {\n    type: NodeType.DocumentType,\n    name: documentType.name,\n    publicId: documentType.publicId,\n    systemId: documentType.systemId,\n  }\n}\n\n/**\n * Serializing Element nodes involves capturing:\n * 1. HTML ATTRIBUTES:\n * 2. JS STATE:\n * - scroll offsets\n * - Form fields (input value, checkbox checked, option selection, range)\n * - Canvas state,\n * - Media (video/audio) play mode + currentTime\n * - iframe contents\n * - webcomponents\n * 3. CUSTOM PROPERTIES:\n * - height+width for when `hidden` to cover the element\n * 4. EXCLUDED INTERACTION STATE:\n * - focus (possible, but not worth perf impact)\n * - hover (tracked only via mouse activity)\n * - fullscreen mode\n */\n\nfunction serializeElementNode(element: Element, options: SerializeOptions): ElementNode | undefined {\n  const tagName = getValidTagName(element.tagName)\n  const isSVG = isSVGElement(element) || undefined\n\n  // For performance reason, we don't use getNodePrivacyLevel directly: we leverage the\n  // parentNodePrivacyLevel option to avoid iterating over all parents\n  const nodePrivacyLevel = reducePrivacyLevel(getNodeSelfPrivacyLevel(element), options.parentNodePrivacyLevel)\n\n  if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n    const { width, height } = element.getBoundingClientRect()\n    return {\n      type: NodeType.Element,\n      tagName,\n      attributes: {\n        rr_width: `${width}px`,\n        rr_height: `${height}px`,\n        [PRIVACY_ATTR_NAME]: PRIVACY_ATTR_VALUE_HIDDEN,\n      },\n      childNodes: [],\n      isSVG,\n    }\n  }\n\n  // Ignore Elements like Script and some Link, Metas\n  if (nodePrivacyLevel === NodePrivacyLevel.IGNORE) {\n    return\n  }\n\n  const attributes = serializeAttributes(element, nodePrivacyLevel, options)\n\n  let childNodes: SerializedNodeWithId[] = []\n  if (\n    hasChildNodes(element) &&\n    // Do not serialize style children as the css rules are already in the _cssText attribute\n    tagName !== 'style'\n  ) {\n    // OBJECT POOLING OPTIMIZATION:\n    // We should not create a new object systematically as it could impact performances. Try to reuse\n    // the same object as much as possible, and clone it only if we need to.\n    let childNodesSerializationOptions\n    if (options.parentNodePrivacyLevel === nodePrivacyLevel && options.ignoreWhiteSpace === (tagName === 'head')) {\n      childNodesSerializationOptions = options\n    } else {\n      childNodesSerializationOptions = assign({}, options, {\n        parentNodePrivacyLevel: nodePrivacyLevel,\n        ignoreWhiteSpace: tagName === 'head',\n      })\n    }\n    childNodes = serializeChildNodes(element, childNodesSerializationOptions)\n  }\n\n  return {\n    type: NodeType.Element,\n    tagName,\n    attributes,\n    childNodes,\n    isSVG,\n  }\n}\n\nfunction isSVGElement(el: Element): boolean {\n  return el.tagName === 'svg' || el instanceof SVGElement\n}\n\n/**\n * Text Nodes are dependant on Element nodes\n * Privacy levels are set on elements so we check the parentElement of a text node\n * for privacy level.\n */\n\nfunction serializeTextNode(textNode: Text, options: SerializeOptions): TextNode | undefined {\n  const textContent = getTextContent(textNode, options.ignoreWhiteSpace || false, options.parentNodePrivacyLevel)\n  if (textContent === undefined) {\n    return\n  }\n  return {\n    type: NodeType.Text,\n    textContent,\n  }\n}\n\nfunction serializeCDataNode(): CDataNode {\n  return {\n    type: NodeType.CDATA,\n    textContent: '',\n  }\n}\n"],"mappings":"AAAA,SAASA,gBAAgB,EAAEC,aAAa,EAAEC,iBAAiB,QAAQ,2BAA2B;AAC9F,SAASC,MAAM,QAAQ,uBAAuB;AAW9C,SAASC,QAAQ,QAAQ,gBAAgB;AACzC,SAASC,gBAAgB,EAAEC,iBAAiB,EAAEC,yBAAyB,QAAQ,oBAAoB;AACnG,SAASC,kBAAkB,EAAEC,uBAAuB,EAAEC,cAAc,QAAQ,YAAY;AACxF,SAASC,mBAAmB,EAAEC,eAAe,EAAEC,mBAAmB,QAAQ,sBAAsB;AAEhG,SAASC,oBAAoB,QAAQ,wBAAwB;AAC7D,SAASC,mBAAmB,QAAQ,uBAAuB;AAE3D,OAAM,SAAUC,mBAAmBA,CAACC,IAAU,EAAEC,OAAyB;EACvE,IAAMC,cAAc,GAAGC,aAAa,CAACH,IAAI,EAAEC,OAAO,CAAC;EACnD,IAAI,CAACC,cAAc,EAAE;IACnB,OAAO,IAAI;EACb;EAEA;EACA,IAAME,EAAE,GAAGV,mBAAmB,CAACM,IAAI,CAAC,IAAIK,cAAc,EAAE;EACxD,IAAMC,oBAAoB,GAAGJ,cAAsC;EACnEI,oBAAoB,CAACF,EAAE,GAAGA,EAAE;EAC5BR,mBAAmB,CAACI,IAAI,EAAEI,EAAE,CAAC;EAC7B,IAAIH,OAAO,CAACM,iBAAiB,EAAE;IAC7BN,OAAO,CAACM,iBAAiB,CAACC,GAAG,CAACJ,EAAE,CAAC;EACnC;EACA,OAAOE,oBAAoB;AAC7B;AAEA,IAAIG,OAAO,GAAG,CAAC;AACf,OAAM,SAAUJ,cAAcA,CAAA;EAC5B,OAAOI,OAAO,EAAE;AAClB;AAEA,OAAM,SAAUC,mBAAmBA,CAACV,IAAU,EAAEC,OAAyB;EACvE,IAAMU,MAAM,GAA2B,EAAE;EACzC1B,iBAAiB,CAACe,IAAI,EAAE,UAACY,SAAS;IAChC,IAAMC,mBAAmB,GAAGd,mBAAmB,CAACa,SAAS,EAAEX,OAAO,CAAC;IACnE,IAAIY,mBAAmB,EAAE;MACvBF,MAAM,CAACG,IAAI,CAACD,mBAAmB,CAAC;IAClC;EACF,CAAC,CAAC;EACF,OAAOF,MAAM;AACf;AAEA,SAASR,aAAaA,CAACH,IAAU,EAAEC,OAAyB;EAC1D,QAAQD,IAAI,CAACe,QAAQ;IACnB,KAAKf,IAAI,CAACgB,aAAa;MACrB,OAAOC,qBAAqB,CAACjB,IAAgB,EAAEC,OAAO,CAAC;IACzD,KAAKD,IAAI,CAACkB,sBAAsB;MAC9B,OAAOC,6BAA6B,CAACnB,IAAwB,EAAEC,OAAO,CAAC;IACzE,KAAKD,IAAI,CAACoB,kBAAkB;MAC1B,OAAOC,yBAAyB,CAACrB,IAAoB,CAAC;IACxD,KAAKA,IAAI,CAACsB,YAAY;MACpB,OAAOC,oBAAoB,CAACvB,IAAe,EAAEC,OAAO,CAAC;IACvD,KAAKD,IAAI,CAACwB,SAAS;MACjB,OAAOC,iBAAiB,CAACzB,IAAY,EAAEC,OAAO,CAAC;IACjD,KAAKD,IAAI,CAAC0B,kBAAkB;MAC1B,OAAOC,kBAAkB,EAAE;EAC/B;AACF;AAEA,OAAM,SAAUV,qBAAqBA,CAACW,QAAkB,EAAE3B,OAAyB;EACjF,OAAO;IACL4B,IAAI,EAAE1C,QAAQ,CAAC2C,QAAQ;IACvBC,UAAU,EAAErB,mBAAmB,CAACkB,QAAQ,EAAE3B,OAAO,CAAC;IAClD+B,kBAAkB,EAAEnC,oBAAoB,CAAC+B,QAAQ,CAACI,kBAAkB;GACrE;AACH;AAEA,SAASb,6BAA6BA,CACpCc,OAAyB,EACzBhC,OAAyB;EAEzB,IAAMiC,YAAY,GAAGnD,gBAAgB,CAACkD,OAAO,CAAC;EAC9C,IAAIC,YAAY,EAAE;IAChBjC,OAAO,CAACkC,oBAAoB,CAACC,qBAAqB,CAACC,aAAa,CAACJ,OAAO,CAAC;EAC3E;EAEA,OAAO;IACLJ,IAAI,EAAE1C,QAAQ,CAACmD,gBAAgB;IAC/BP,UAAU,EAAErB,mBAAmB,CAACuB,OAAO,EAAEhC,OAAO,CAAC;IACjDiC,YAAY,EAAAA,YAAA;IACZF,kBAAkB,EAAEE,YAAY,GAAGrC,oBAAoB,CAACoC,OAAO,CAACD,kBAAkB,CAAC,GAAGO;GACvF;AACH;AAEA,SAASlB,yBAAyBA,CAACmB,YAA0B;EAC3D,OAAO;IACLX,IAAI,EAAE1C,QAAQ,CAACsD,YAAY;IAC3BC,IAAI,EAAEF,YAAY,CAACE,IAAI;IACvBC,QAAQ,EAAEH,YAAY,CAACG,QAAQ;IAC/BC,QAAQ,EAAEJ,YAAY,CAACI;GACxB;AACH;AAEA;;;;;;;;;;;;;;;;;AAkBA,SAASrB,oBAAoBA,CAACU,OAAgB,EAAEhC,OAAyB;;EACvE,IAAM4C,OAAO,GAAGlD,eAAe,CAACsC,OAAO,CAACY,OAAO,CAAC;EAChD,IAAMC,KAAK,GAAGC,YAAY,CAACd,OAAO,CAAC,IAAIM,SAAS;EAEhD;EACA;EACA,IAAMS,gBAAgB,GAAGzD,kBAAkB,CAACC,uBAAuB,CAACyC,OAAO,CAAC,EAAEhC,OAAO,CAACgD,sBAAsB,CAAC;EAE7G,IAAID,gBAAgB,KAAK5D,gBAAgB,CAAC8D,MAAM,EAAE;IAC1C,IAAAC,EAAA,GAAoBlB,OAAO,CAACmB,qBAAqB,EAAE;MAAjDC,KAAK,GAAAF,EAAA,CAAAE,KAAA;MAAEC,MAAM,GAAAH,EAAA,CAAAG,MAAoC;IACzD,OAAO;MACLzB,IAAI,EAAE1C,QAAQ,CAACoE,OAAO;MACtBV,OAAO,EAAAA,OAAA;MACPW,UAAU,GAAAC,EAAA;QACRC,QAAQ,EAAE,GAAAC,MAAA,CAAGN,KAAK,OAAI;QACtBO,SAAS,EAAE,GAAAD,MAAA,CAAGL,MAAM;SACpBG,EAAA,CAACpE,iBAAiB,IAAGC,yBAAyB,E,GAC/C;MACDyC,UAAU,EAAE,EAAE;MACde,KAAK,EAAAA;KACN;EACH;EAEA;EACA,IAAIE,gBAAgB,KAAK5D,gBAAgB,CAACyE,MAAM,EAAE;IAChD;EACF;EAEA,IAAML,UAAU,GAAG1D,mBAAmB,CAACmC,OAAO,EAAEe,gBAAgB,EAAE/C,OAAO,CAAC;EAE1E,IAAI8B,UAAU,GAA2B,EAAE;EAC3C,IACE/C,aAAa,CAACiD,OAAO,CAAC;EACtB;EACAY,OAAO,KAAK,OAAO,EACnB;IACA;IACA;IACA;IACA,IAAIiB,8BAA8B;IAClC,IAAI7D,OAAO,CAACgD,sBAAsB,KAAKD,gBAAgB,IAAI/C,OAAO,CAAC8D,gBAAgB,MAAMlB,OAAO,KAAK,MAAM,CAAC,EAAE;MAC5GiB,8BAA8B,GAAG7D,OAAO;IAC1C,CAAC,MAAM;MACL6D,8BAA8B,GAAG5E,MAAM,CAAC,EAAE,EAAEe,OAAO,EAAE;QACnDgD,sBAAsB,EAAED,gBAAgB;QACxCe,gBAAgB,EAAElB,OAAO,KAAK;OAC/B,CAAC;IACJ;IACAd,UAAU,GAAGrB,mBAAmB,CAACuB,OAAO,EAAE6B,8BAA8B,CAAC;EAC3E;EAEA,OAAO;IACLjC,IAAI,EAAE1C,QAAQ,CAACoE,OAAO;IACtBV,OAAO,EAAAA,OAAA;IACPW,UAAU,EAAAA,UAAA;IACVzB,UAAU,EAAAA,UAAA;IACVe,KAAK,EAAAA;GACN;AACH;AAEA,SAASC,YAAYA,CAACiB,EAAW;EAC/B,OAAOA,EAAE,CAACnB,OAAO,KAAK,KAAK,IAAImB,EAAE,YAAYC,UAAU;AACzD;AAEA;;;;;AAMA,SAASxC,iBAAiBA,CAACyC,QAAc,EAAEjE,OAAyB;EAClE,IAAMkE,WAAW,GAAG1E,cAAc,CAACyE,QAAQ,EAAEjE,OAAO,CAAC8D,gBAAgB,IAAI,KAAK,EAAE9D,OAAO,CAACgD,sBAAsB,CAAC;EAC/G,IAAIkB,WAAW,KAAK5B,SAAS,EAAE;IAC7B;EACF;EACA,OAAO;IACLV,IAAI,EAAE1C,QAAQ,CAACiF,IAAI;IACnBD,WAAW,EAAAA;GACZ;AACH;AAEA,SAASxC,kBAAkBA,CAAA;EACzB,OAAO;IACLE,IAAI,EAAE1C,QAAQ,CAACkF,KAAK;IACpBF,WAAW,EAAE;GACd;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}