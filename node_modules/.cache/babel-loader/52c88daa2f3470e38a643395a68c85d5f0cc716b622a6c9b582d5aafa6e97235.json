{"ast":null,"code":"import { addDuration } from '@datadog/browser-core';\nimport { toValidEntry } from './resourceUtils';\n/**\n * Look for corresponding timing in resource timing buffer\n *\n * Observations:\n * - Timing (start, end) are nested inside the request (start, end)\n * - Some timing can be not exactly nested, being off by < 1 ms\n *\n * Strategy:\n * - from valid nested entries (with 1 ms error margin)\n * - if a single timing match, return the timing\n * - otherwise we can't decide, return undefined\n */\nexport function matchRequestTiming(request) {\n  if (!performance || !('getEntriesByName' in performance)) {\n    return;\n  }\n  var sameNameEntries = performance.getEntriesByName(request.url, 'resource');\n  if (!sameNameEntries.length || !('toJSON' in sameNameEntries[0])) {\n    return;\n  }\n  var candidates = sameNameEntries.map(function (entry) {\n    return entry.toJSON();\n  }).filter(toValidEntry).filter(function (entry) {\n    return isBetween(entry, request.startClocks.relative, endTime({\n      startTime: request.startClocks.relative,\n      duration: request.duration\n    }));\n  });\n  if (candidates.length === 1) {\n    return candidates[0];\n  }\n  return;\n}\nfunction endTime(timing) {\n  return addDuration(timing.startTime, timing.duration);\n}\nfunction isBetween(timing, start, end) {\n  var errorMargin = 1;\n  return timing.startTime >= start - errorMargin && endTime(timing) <= addDuration(end, errorMargin);\n}","map":{"version":3,"names":["addDuration","toValidEntry","matchRequestTiming","request","performance","sameNameEntries","getEntriesByName","url","length","candidates","map","entry","toJSON","filter","isBetween","startClocks","relative","endTime","startTime","duration","timing","start","end","errorMargin"],"sources":["D:\\edu'\\Spritle\\Spritle\\node_modules\\@datadog\\browser-rum-core\\src\\domain\\resource\\matchRequestTiming.ts"],"sourcesContent":["import type { Duration, RelativeTime } from '@datadog/browser-core'\nimport { addDuration } from '@datadog/browser-core'\nimport type { RumPerformanceResourceTiming } from '../../browser/performanceCollection'\nimport type { RequestCompleteEvent } from '../requestCollection'\nimport { toValidEntry } from './resourceUtils'\n\ninterface Timing {\n  startTime: RelativeTime\n  duration: Duration\n}\n\n/**\n * Look for corresponding timing in resource timing buffer\n *\n * Observations:\n * - Timing (start, end) are nested inside the request (start, end)\n * - Some timing can be not exactly nested, being off by < 1 ms\n *\n * Strategy:\n * - from valid nested entries (with 1 ms error margin)\n * - if a single timing match, return the timing\n * - otherwise we can't decide, return undefined\n */\nexport function matchRequestTiming(request: RequestCompleteEvent) {\n  if (!performance || !('getEntriesByName' in performance)) {\n    return\n  }\n  const sameNameEntries = performance.getEntriesByName(request.url, 'resource')\n\n  if (!sameNameEntries.length || !('toJSON' in sameNameEntries[0])) {\n    return\n  }\n\n  const candidates = sameNameEntries\n    .map((entry) => entry.toJSON() as RumPerformanceResourceTiming)\n    .filter(toValidEntry)\n    .filter((entry) =>\n      isBetween(\n        entry,\n        request.startClocks.relative,\n        endTime({ startTime: request.startClocks.relative, duration: request.duration })\n      )\n    )\n\n  if (candidates.length === 1) {\n    return candidates[0]\n  }\n\n  return\n}\n\nfunction endTime(timing: Timing) {\n  return addDuration(timing.startTime, timing.duration)\n}\n\nfunction isBetween(timing: Timing, start: RelativeTime, end: RelativeTime) {\n  const errorMargin = 1 as Duration\n  return timing.startTime >= start - errorMargin && endTime(timing) <= addDuration(end, errorMargin)\n}\n"],"mappings":"AACA,SAASA,WAAW,QAAQ,uBAAuB;AAGnD,SAASC,YAAY,QAAQ,iBAAiB;AAO9C;;;;;;;;;;;;AAYA,OAAM,SAAUC,kBAAkBA,CAACC,OAA6B;EAC9D,IAAI,CAACC,WAAW,IAAI,EAAE,kBAAkB,IAAIA,WAAW,CAAC,EAAE;IACxD;EACF;EACA,IAAMC,eAAe,GAAGD,WAAW,CAACE,gBAAgB,CAACH,OAAO,CAACI,GAAG,EAAE,UAAU,CAAC;EAE7E,IAAI,CAACF,eAAe,CAACG,MAAM,IAAI,EAAE,QAAQ,IAAIH,eAAe,CAAC,CAAC,CAAC,CAAC,EAAE;IAChE;EACF;EAEA,IAAMI,UAAU,GAAGJ,eAAe,CAC/BK,GAAG,CAAC,UAACC,KAAK;IAAK,OAAAA,KAAK,CAACC,MAAM,EAAkC;EAA9C,CAA8C,CAAC,CAC9DC,MAAM,CAACZ,YAAY,CAAC,CACpBY,MAAM,CAAC,UAACF,KAAK;IACZ,OAAAG,SAAS,CACPH,KAAK,EACLR,OAAO,CAACY,WAAW,CAACC,QAAQ,EAC5BC,OAAO,CAAC;MAAEC,SAAS,EAAEf,OAAO,CAACY,WAAW,CAACC,QAAQ;MAAEG,QAAQ,EAAEhB,OAAO,CAACgB;IAAQ,CAAE,CAAC,CACjF;EAJD,CAIC,CACF;EAEH,IAAIV,UAAU,CAACD,MAAM,KAAK,CAAC,EAAE;IAC3B,OAAOC,UAAU,CAAC,CAAC,CAAC;EACtB;EAEA;AACF;AAEA,SAASQ,OAAOA,CAACG,MAAc;EAC7B,OAAOpB,WAAW,CAACoB,MAAM,CAACF,SAAS,EAAEE,MAAM,CAACD,QAAQ,CAAC;AACvD;AAEA,SAASL,SAASA,CAACM,MAAc,EAAEC,KAAmB,EAAEC,GAAiB;EACvE,IAAMC,WAAW,GAAG,CAAa;EACjC,OAAOH,MAAM,CAACF,SAAS,IAAIG,KAAK,GAAGE,WAAW,IAAIN,OAAO,CAACG,MAAM,CAAC,IAAIpB,WAAW,CAACsB,GAAG,EAAEC,WAAW,CAAC;AACpG","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}