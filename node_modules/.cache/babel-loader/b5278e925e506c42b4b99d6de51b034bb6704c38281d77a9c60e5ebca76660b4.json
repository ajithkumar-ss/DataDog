{"ast":null,"code":"import { isElementNode, getParentNode, isTextNode } from '@datadog/browser-rum-core';\nimport { NodePrivacyLevel, PRIVACY_ATTR_NAME, PRIVACY_ATTR_VALUE_ALLOW, PRIVACY_ATTR_VALUE_MASK, PRIVACY_ATTR_VALUE_MASK_USER_INPUT, PRIVACY_ATTR_VALUE_HIDDEN, PRIVACY_CLASS_ALLOW, PRIVACY_CLASS_MASK, PRIVACY_CLASS_MASK_USER_INPUT, PRIVACY_CLASS_HIDDEN, FORM_PRIVATE_TAG_NAMES, CENSORED_STRING_MARK } from '../../constants';\nvar TEXT_MASKING_CHAR = 'x';\n/**\n * Get node privacy level by iterating over its ancestors. When the direct parent privacy level is\n * know, it is best to use something like:\n *\n * derivePrivacyLevelGivenParent(getNodeSelfPrivacyLevel(node), parentNodePrivacyLevel)\n */\nexport function getNodePrivacyLevel(node, defaultPrivacyLevel, cache) {\n  if (cache && cache.has(node)) {\n    return cache.get(node);\n  }\n  var parentNode = getParentNode(node);\n  var parentNodePrivacyLevel = parentNode ? getNodePrivacyLevel(parentNode, defaultPrivacyLevel, cache) : defaultPrivacyLevel;\n  var selfNodePrivacyLevel = getNodeSelfPrivacyLevel(node);\n  var nodePrivacyLevel = reducePrivacyLevel(selfNodePrivacyLevel, parentNodePrivacyLevel);\n  if (cache) {\n    cache.set(node, nodePrivacyLevel);\n  }\n  return nodePrivacyLevel;\n}\n/**\n * Reduces the next privacy level based on self + parent privacy levels\n */\nexport function reducePrivacyLevel(childPrivacyLevel, parentNodePrivacyLevel) {\n  switch (parentNodePrivacyLevel) {\n    // These values cannot be overridden\n    case NodePrivacyLevel.HIDDEN:\n    case NodePrivacyLevel.IGNORE:\n      return parentNodePrivacyLevel;\n  }\n  switch (childPrivacyLevel) {\n    case NodePrivacyLevel.ALLOW:\n    case NodePrivacyLevel.MASK:\n    case NodePrivacyLevel.MASK_USER_INPUT:\n    case NodePrivacyLevel.HIDDEN:\n    case NodePrivacyLevel.IGNORE:\n      return childPrivacyLevel;\n    default:\n      return parentNodePrivacyLevel;\n  }\n}\n/**\n * Determines the node's own privacy level without checking for ancestors.\n */\nexport function getNodeSelfPrivacyLevel(node) {\n  // Only Element types can have a privacy level set\n  if (!isElementNode(node)) {\n    return;\n  }\n  var privAttr = node.getAttribute(PRIVACY_ATTR_NAME);\n  // Overrules for replay purpose\n  if (node.tagName === 'BASE') {\n    return NodePrivacyLevel.ALLOW;\n  }\n  // Overrules to enforce end-user protection\n  if (node.tagName === 'INPUT') {\n    var inputElement = node;\n    if (inputElement.type === 'password' || inputElement.type === 'email' || inputElement.type === 'tel') {\n      return NodePrivacyLevel.MASK;\n    }\n    if (inputElement.type === 'hidden') {\n      return NodePrivacyLevel.MASK;\n    }\n    var autocomplete = inputElement.getAttribute('autocomplete');\n    // Handle input[autocomplete=cc-number/cc-csc/cc-exp/cc-exp-month/cc-exp-year]\n    if (autocomplete && autocomplete.indexOf('cc-') === 0) {\n      return NodePrivacyLevel.MASK;\n    }\n  }\n  // Check HTML privacy attributes and classes\n  if (privAttr === PRIVACY_ATTR_VALUE_HIDDEN || node.classList.contains(PRIVACY_CLASS_HIDDEN)) {\n    return NodePrivacyLevel.HIDDEN;\n  }\n  if (privAttr === PRIVACY_ATTR_VALUE_MASK || node.classList.contains(PRIVACY_CLASS_MASK)) {\n    return NodePrivacyLevel.MASK;\n  }\n  if (privAttr === PRIVACY_ATTR_VALUE_MASK_USER_INPUT || node.classList.contains(PRIVACY_CLASS_MASK_USER_INPUT)) {\n    return NodePrivacyLevel.MASK_USER_INPUT;\n  }\n  if (privAttr === PRIVACY_ATTR_VALUE_ALLOW || node.classList.contains(PRIVACY_CLASS_ALLOW)) {\n    return NodePrivacyLevel.ALLOW;\n  }\n  if (shouldIgnoreElement(node)) {\n    return NodePrivacyLevel.IGNORE;\n  }\n}\n/**\n * Helper aiming to unify `mask` and `mask-user-input` privacy levels:\n *\n * In the `mask` case, it is trivial: we should mask the element.\n *\n * In the `mask-user-input` case, we should mask the element only if it is a \"form\" element or the\n * direct parent is a form element for text nodes).\n *\n * Other `shouldMaskNode` cases are edge cases that should not matter too much (ex: should we mask a\n * node if it is ignored or hidden? it doesn't matter since it won't be serialized).\n */\nexport function shouldMaskNode(node, privacyLevel) {\n  switch (privacyLevel) {\n    case NodePrivacyLevel.MASK:\n    case NodePrivacyLevel.HIDDEN:\n    case NodePrivacyLevel.IGNORE:\n      return true;\n    case NodePrivacyLevel.MASK_USER_INPUT:\n      return isTextNode(node) ? isFormElement(node.parentNode) : isFormElement(node);\n    default:\n      return false;\n  }\n}\nfunction isFormElement(node) {\n  if (!node || node.nodeType !== node.ELEMENT_NODE) {\n    return false;\n  }\n  var element = node;\n  if (element.tagName === 'INPUT') {\n    switch (element.type) {\n      case 'button':\n      case 'color':\n      case 'reset':\n      case 'submit':\n        return false;\n    }\n  }\n  return !!FORM_PRIVATE_TAG_NAMES[element.tagName];\n}\n/**\n * Text censoring non-destructively maintains whitespace characters in order to preserve text shape\n * during replay.\n */\nexport var censorText = function (text) {\n  return text.replace(/\\S/g, TEXT_MASKING_CHAR);\n};\nexport function getTextContent(textNode, ignoreWhiteSpace, parentNodePrivacyLevel) {\n  var _a;\n  // The parent node may not be a html element which has a tagName attribute.\n  // So just let it be undefined which is ok in this use case.\n  var parentTagName = (_a = textNode.parentElement) === null || _a === void 0 ? void 0 : _a.tagName;\n  var textContent = textNode.textContent || '';\n  if (ignoreWhiteSpace && !textContent.trim()) {\n    return;\n  }\n  var nodePrivacyLevel = parentNodePrivacyLevel;\n  var isScript = parentTagName === 'SCRIPT';\n  if (isScript) {\n    // For perf reasons, we don't record script (heuristic)\n    textContent = CENSORED_STRING_MARK;\n  } else if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n    // Should never occur, but just in case, we set to CENSORED_MARK.\n    textContent = CENSORED_STRING_MARK;\n  } else if (shouldMaskNode(textNode, nodePrivacyLevel)) {\n    if (\n    // Scrambling the child list breaks text nodes for DATALIST/SELECT/OPTGROUP\n    parentTagName === 'DATALIST' || parentTagName === 'SELECT' || parentTagName === 'OPTGROUP') {\n      if (!textContent.trim()) {\n        return;\n      }\n    } else if (parentTagName === 'OPTION') {\n      // <Option> has low entropy in charset + text length, so use `CENSORED_STRING_MARK` when masked\n      textContent = CENSORED_STRING_MARK;\n    } else {\n      textContent = censorText(textContent);\n    }\n  }\n  return textContent;\n}\n/**\n * TODO: Preserve CSS element order, and record the presence of the tag, just don't render\n * We don't need this logic on the recorder side.\n * For security related meta's, customer can mask themmanually given they\n * are easy to identify in the HEAD tag.\n */\nexport function shouldIgnoreElement(element) {\n  if (element.nodeName === 'SCRIPT') {\n    return true;\n  }\n  if (element.nodeName === 'LINK') {\n    var relAttribute = getLowerCaseAttribute('rel');\n    return (\n      // Link as script - Ignore only when rel=preload, modulepreload or prefetch\n      /preload|prefetch/i.test(relAttribute) && getLowerCaseAttribute('as') === 'script' ||\n      // Favicons\n      relAttribute === 'shortcut icon' || relAttribute === 'icon'\n    );\n  }\n  if (element.nodeName === 'META') {\n    var nameAttribute = getLowerCaseAttribute('name');\n    var relAttribute = getLowerCaseAttribute('rel');\n    var propertyAttribute = getLowerCaseAttribute('property');\n    return (\n      // Favicons\n      /^msapplication-tile(image|color)$/.test(nameAttribute) || nameAttribute === 'application-name' || relAttribute === 'icon' || relAttribute === 'apple-touch-icon' || relAttribute === 'shortcut icon' ||\n      // Description\n      nameAttribute === 'keywords' || nameAttribute === 'description' ||\n      // Social\n      /^(og|twitter|fb):/.test(propertyAttribute) || /^(og|twitter):/.test(nameAttribute) || nameAttribute === 'pinterest' ||\n      // Robots\n      nameAttribute === 'robots' || nameAttribute === 'googlebot' || nameAttribute === 'bingbot' ||\n      // Http headers. Ex: X-UA-Compatible, Content-Type, Content-Language, cache-control,\n      // X-Translated-By\n      element.hasAttribute('http-equiv') ||\n      // Authorship\n      nameAttribute === 'author' || nameAttribute === 'generator' || nameAttribute === 'framework' || nameAttribute === 'publisher' || nameAttribute === 'progid' || /^article:/.test(propertyAttribute) || /^product:/.test(propertyAttribute) ||\n      // Verification\n      nameAttribute === 'google-site-verification' || nameAttribute === 'yandex-verification' || nameAttribute === 'csrf-token' || nameAttribute === 'p:domain_verify' || nameAttribute === 'verify-v1' || nameAttribute === 'verification' || nameAttribute === 'shopify-checkout-api-token'\n    );\n  }\n  function getLowerCaseAttribute(name) {\n    return (element.getAttribute(name) || '').toLowerCase();\n  }\n  return false;\n}","map":{"version":3,"names":["isElementNode","getParentNode","isTextNode","NodePrivacyLevel","PRIVACY_ATTR_NAME","PRIVACY_ATTR_VALUE_ALLOW","PRIVACY_ATTR_VALUE_MASK","PRIVACY_ATTR_VALUE_MASK_USER_INPUT","PRIVACY_ATTR_VALUE_HIDDEN","PRIVACY_CLASS_ALLOW","PRIVACY_CLASS_MASK","PRIVACY_CLASS_MASK_USER_INPUT","PRIVACY_CLASS_HIDDEN","FORM_PRIVATE_TAG_NAMES","CENSORED_STRING_MARK","TEXT_MASKING_CHAR","getNodePrivacyLevel","node","defaultPrivacyLevel","cache","has","get","parentNode","parentNodePrivacyLevel","selfNodePrivacyLevel","getNodeSelfPrivacyLevel","nodePrivacyLevel","reducePrivacyLevel","set","childPrivacyLevel","HIDDEN","IGNORE","ALLOW","MASK","MASK_USER_INPUT","privAttr","getAttribute","tagName","inputElement","type","autocomplete","indexOf","classList","contains","shouldIgnoreElement","shouldMaskNode","privacyLevel","isFormElement","nodeType","ELEMENT_NODE","element","censorText","text","replace","getTextContent","textNode","ignoreWhiteSpace","parentTagName","_a","parentElement","textContent","trim","isScript","nodeName","relAttribute","getLowerCaseAttribute","test","nameAttribute","propertyAttribute","hasAttribute","name","toLowerCase"],"sources":["D:\\edu'\\Spritle\\spritle\\node_modules\\@datadog\\browser-rum\\src\\domain\\record\\privacy.ts"],"sourcesContent":["import { isElementNode, getParentNode, isTextNode } from '@datadog/browser-rum-core'\nimport {\n  NodePrivacyLevel,\n  PRIVACY_ATTR_NAME,\n  PRIVACY_ATTR_VALUE_ALLOW,\n  PRIVACY_ATTR_VALUE_MASK,\n  PRIVACY_ATTR_VALUE_MASK_USER_INPUT,\n  PRIVACY_ATTR_VALUE_HIDDEN,\n  PRIVACY_CLASS_ALLOW,\n  PRIVACY_CLASS_MASK,\n  PRIVACY_CLASS_MASK_USER_INPUT,\n  PRIVACY_CLASS_HIDDEN,\n  FORM_PRIVATE_TAG_NAMES,\n  CENSORED_STRING_MARK,\n} from '../../constants'\n\nconst TEXT_MASKING_CHAR = 'x'\n\nexport type NodePrivacyLevelCache = Map<Node, NodePrivacyLevel>\n\n/**\n * Get node privacy level by iterating over its ancestors. When the direct parent privacy level is\n * know, it is best to use something like:\n *\n * derivePrivacyLevelGivenParent(getNodeSelfPrivacyLevel(node), parentNodePrivacyLevel)\n */\nexport function getNodePrivacyLevel(\n  node: Node,\n  defaultPrivacyLevel: NodePrivacyLevel,\n  cache?: NodePrivacyLevelCache\n): NodePrivacyLevel {\n  if (cache && cache.has(node)) {\n    return cache.get(node)!\n  }\n  const parentNode = getParentNode(node)\n  const parentNodePrivacyLevel = parentNode\n    ? getNodePrivacyLevel(parentNode, defaultPrivacyLevel, cache)\n    : defaultPrivacyLevel\n  const selfNodePrivacyLevel = getNodeSelfPrivacyLevel(node)\n  const nodePrivacyLevel = reducePrivacyLevel(selfNodePrivacyLevel, parentNodePrivacyLevel)\n  if (cache) {\n    cache.set(node, nodePrivacyLevel)\n  }\n  return nodePrivacyLevel\n}\n\n/**\n * Reduces the next privacy level based on self + parent privacy levels\n */\nexport function reducePrivacyLevel(\n  childPrivacyLevel: NodePrivacyLevel | undefined,\n  parentNodePrivacyLevel: NodePrivacyLevel\n): NodePrivacyLevel {\n  switch (parentNodePrivacyLevel) {\n    // These values cannot be overridden\n    case NodePrivacyLevel.HIDDEN:\n    case NodePrivacyLevel.IGNORE:\n      return parentNodePrivacyLevel\n  }\n  switch (childPrivacyLevel) {\n    case NodePrivacyLevel.ALLOW:\n    case NodePrivacyLevel.MASK:\n    case NodePrivacyLevel.MASK_USER_INPUT:\n    case NodePrivacyLevel.HIDDEN:\n    case NodePrivacyLevel.IGNORE:\n      return childPrivacyLevel\n    default:\n      return parentNodePrivacyLevel\n  }\n}\n\n/**\n * Determines the node's own privacy level without checking for ancestors.\n */\nexport function getNodeSelfPrivacyLevel(node: Node): NodePrivacyLevel | undefined {\n  // Only Element types can have a privacy level set\n  if (!isElementNode(node)) {\n    return\n  }\n\n  const privAttr = node.getAttribute(PRIVACY_ATTR_NAME)\n\n  // Overrules for replay purpose\n  if (node.tagName === 'BASE') {\n    return NodePrivacyLevel.ALLOW\n  }\n\n  // Overrules to enforce end-user protection\n  if (node.tagName === 'INPUT') {\n    const inputElement = node as HTMLInputElement\n    if (inputElement.type === 'password' || inputElement.type === 'email' || inputElement.type === 'tel') {\n      return NodePrivacyLevel.MASK\n    }\n    if (inputElement.type === 'hidden') {\n      return NodePrivacyLevel.MASK\n    }\n    const autocomplete = inputElement.getAttribute('autocomplete')\n    // Handle input[autocomplete=cc-number/cc-csc/cc-exp/cc-exp-month/cc-exp-year]\n    if (autocomplete && autocomplete.indexOf('cc-') === 0) {\n      return NodePrivacyLevel.MASK\n    }\n  }\n\n  // Check HTML privacy attributes and classes\n  if (privAttr === PRIVACY_ATTR_VALUE_HIDDEN || node.classList.contains(PRIVACY_CLASS_HIDDEN)) {\n    return NodePrivacyLevel.HIDDEN\n  }\n\n  if (privAttr === PRIVACY_ATTR_VALUE_MASK || node.classList.contains(PRIVACY_CLASS_MASK)) {\n    return NodePrivacyLevel.MASK\n  }\n\n  if (privAttr === PRIVACY_ATTR_VALUE_MASK_USER_INPUT || node.classList.contains(PRIVACY_CLASS_MASK_USER_INPUT)) {\n    return NodePrivacyLevel.MASK_USER_INPUT\n  }\n\n  if (privAttr === PRIVACY_ATTR_VALUE_ALLOW || node.classList.contains(PRIVACY_CLASS_ALLOW)) {\n    return NodePrivacyLevel.ALLOW\n  }\n\n  if (shouldIgnoreElement(node)) {\n    return NodePrivacyLevel.IGNORE\n  }\n}\n\n/**\n * Helper aiming to unify `mask` and `mask-user-input` privacy levels:\n *\n * In the `mask` case, it is trivial: we should mask the element.\n *\n * In the `mask-user-input` case, we should mask the element only if it is a \"form\" element or the\n * direct parent is a form element for text nodes).\n *\n * Other `shouldMaskNode` cases are edge cases that should not matter too much (ex: should we mask a\n * node if it is ignored or hidden? it doesn't matter since it won't be serialized).\n */\nexport function shouldMaskNode(node: Node, privacyLevel: NodePrivacyLevel) {\n  switch (privacyLevel) {\n    case NodePrivacyLevel.MASK:\n    case NodePrivacyLevel.HIDDEN:\n    case NodePrivacyLevel.IGNORE:\n      return true\n    case NodePrivacyLevel.MASK_USER_INPUT:\n      return isTextNode(node) ? isFormElement(node.parentNode) : isFormElement(node)\n    default:\n      return false\n  }\n}\n\nfunction isFormElement(node: Node | null): boolean {\n  if (!node || node.nodeType !== node.ELEMENT_NODE) {\n    return false\n  }\n  const element = node as HTMLInputElement\n  if (element.tagName === 'INPUT') {\n    switch (element.type) {\n      case 'button':\n      case 'color':\n      case 'reset':\n      case 'submit':\n        return false\n    }\n  }\n  return !!FORM_PRIVATE_TAG_NAMES[element.tagName]\n}\n\n/**\n * Text censoring non-destructively maintains whitespace characters in order to preserve text shape\n * during replay.\n */\nexport const censorText = (text: string) => text.replace(/\\S/g, TEXT_MASKING_CHAR)\n\nexport function getTextContent(\n  textNode: Node,\n  ignoreWhiteSpace: boolean,\n  parentNodePrivacyLevel: NodePrivacyLevel\n): string | undefined {\n  // The parent node may not be a html element which has a tagName attribute.\n  // So just let it be undefined which is ok in this use case.\n  const parentTagName = textNode.parentElement?.tagName\n  let textContent = textNode.textContent || ''\n\n  if (ignoreWhiteSpace && !textContent.trim()) {\n    return\n  }\n\n  const nodePrivacyLevel = parentNodePrivacyLevel\n\n  const isScript = parentTagName === 'SCRIPT'\n\n  if (isScript) {\n    // For perf reasons, we don't record script (heuristic)\n    textContent = CENSORED_STRING_MARK\n  } else if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n    // Should never occur, but just in case, we set to CENSORED_MARK.\n    textContent = CENSORED_STRING_MARK\n  } else if (shouldMaskNode(textNode, nodePrivacyLevel)) {\n    if (\n      // Scrambling the child list breaks text nodes for DATALIST/SELECT/OPTGROUP\n      parentTagName === 'DATALIST' ||\n      parentTagName === 'SELECT' ||\n      parentTagName === 'OPTGROUP'\n    ) {\n      if (!textContent.trim()) {\n        return\n      }\n    } else if (parentTagName === 'OPTION') {\n      // <Option> has low entropy in charset + text length, so use `CENSORED_STRING_MARK` when masked\n      textContent = CENSORED_STRING_MARK\n    } else {\n      textContent = censorText(textContent)\n    }\n  }\n  return textContent\n}\n\n/**\n * TODO: Preserve CSS element order, and record the presence of the tag, just don't render\n * We don't need this logic on the recorder side.\n * For security related meta's, customer can mask themmanually given they\n * are easy to identify in the HEAD tag.\n */\nexport function shouldIgnoreElement(element: Element): boolean {\n  if (element.nodeName === 'SCRIPT') {\n    return true\n  }\n\n  if (element.nodeName === 'LINK') {\n    const relAttribute = getLowerCaseAttribute('rel')\n    return (\n      // Link as script - Ignore only when rel=preload, modulepreload or prefetch\n      (/preload|prefetch/i.test(relAttribute) && getLowerCaseAttribute('as') === 'script') ||\n      // Favicons\n      relAttribute === 'shortcut icon' ||\n      relAttribute === 'icon'\n    )\n  }\n\n  if (element.nodeName === 'META') {\n    const nameAttribute = getLowerCaseAttribute('name')\n    const relAttribute = getLowerCaseAttribute('rel')\n    const propertyAttribute = getLowerCaseAttribute('property')\n    return (\n      // Favicons\n      /^msapplication-tile(image|color)$/.test(nameAttribute) ||\n      nameAttribute === 'application-name' ||\n      relAttribute === 'icon' ||\n      relAttribute === 'apple-touch-icon' ||\n      relAttribute === 'shortcut icon' ||\n      // Description\n      nameAttribute === 'keywords' ||\n      nameAttribute === 'description' ||\n      // Social\n      /^(og|twitter|fb):/.test(propertyAttribute) ||\n      /^(og|twitter):/.test(nameAttribute) ||\n      nameAttribute === 'pinterest' ||\n      // Robots\n      nameAttribute === 'robots' ||\n      nameAttribute === 'googlebot' ||\n      nameAttribute === 'bingbot' ||\n      // Http headers. Ex: X-UA-Compatible, Content-Type, Content-Language, cache-control,\n      // X-Translated-By\n      element.hasAttribute('http-equiv') ||\n      // Authorship\n      nameAttribute === 'author' ||\n      nameAttribute === 'generator' ||\n      nameAttribute === 'framework' ||\n      nameAttribute === 'publisher' ||\n      nameAttribute === 'progid' ||\n      /^article:/.test(propertyAttribute) ||\n      /^product:/.test(propertyAttribute) ||\n      // Verification\n      nameAttribute === 'google-site-verification' ||\n      nameAttribute === 'yandex-verification' ||\n      nameAttribute === 'csrf-token' ||\n      nameAttribute === 'p:domain_verify' ||\n      nameAttribute === 'verify-v1' ||\n      nameAttribute === 'verification' ||\n      nameAttribute === 'shopify-checkout-api-token'\n    )\n  }\n\n  function getLowerCaseAttribute(name: string) {\n    return (element.getAttribute(name) || '').toLowerCase()\n  }\n\n  return false\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}