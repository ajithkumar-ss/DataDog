{"ast":null,"code":"import { ExperimentalFeature, isExperimentalFeatureEnabled, isSafari } from '@datadog/browser-core';\nimport { NodePrivacyLevel } from '../../../constants';\nimport { shouldMaskNode } from '../privacy';\nimport { getElementInputValue, switchToAbsoluteUrl, getValidTagName } from './serializationUtils';\nimport { serializeAttribute } from './serializeAttribute';\nexport function serializeAttributes(element, nodePrivacyLevel, options) {\n  var _a;\n  if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n    return {};\n  }\n  var safeAttrs = {};\n  var tagName = getValidTagName(element.tagName);\n  var doc = element.ownerDocument;\n  for (var i = 0; i < element.attributes.length; i += 1) {\n    var attribute = element.attributes.item(i);\n    var attributeName = attribute.name;\n    var attributeValue = serializeAttribute(element, nodePrivacyLevel, attributeName, options.configuration);\n    if (attributeValue !== null) {\n      safeAttrs[attributeName] = attributeValue;\n    }\n  }\n  if (element.value && (tagName === 'textarea' || tagName === 'select' || tagName === 'option' || tagName === 'input')) {\n    var formValue = getElementInputValue(element, nodePrivacyLevel);\n    if (formValue !== undefined) {\n      safeAttrs.value = formValue;\n    }\n  }\n  /**\n   * <Option> can be selected, which occurs if its `value` matches ancestor `<Select>.value`\n   */\n  if (tagName === 'option' && nodePrivacyLevel === NodePrivacyLevel.ALLOW) {\n    // For privacy=`MASK`, all the values would be the same, so skip.\n    var optionElement = element;\n    if (optionElement.selected) {\n      safeAttrs.selected = optionElement.selected;\n    }\n  }\n  // remote css\n  if (tagName === 'link') {\n    var stylesheet = Array.from(doc.styleSheets).find(function (s) {\n      return s.href === element.href;\n    });\n    var cssText = getCssRulesString(stylesheet);\n    if (cssText && stylesheet && !isExperimentalFeatureEnabled(ExperimentalFeature.DISABLE_REPLAY_INLINE_CSS)) {\n      safeAttrs._cssText = cssText;\n    }\n  }\n  // dynamic stylesheet\n  if (tagName === 'style' && element.sheet) {\n    var cssText = getCssRulesString(element.sheet);\n    if (cssText) {\n      safeAttrs._cssText = cssText;\n    }\n  }\n  /**\n   * Forms: input[type=checkbox,radio]\n   * The `checked` property for <input> is a little bit special:\n   * 1. el.checked is a setter that returns if truthy.\n   * 2. getAttribute returns the string value\n   * getAttribute('checked') does not sync with `Element.checked`, so use JS property\n   * NOTE: `checked` property exists on `HTMLInputElement`. For serializer assumptions, we check for type=radio|check.\n   */\n  var inputElement = element;\n  if (tagName === 'input' && (inputElement.type === 'radio' || inputElement.type === 'checkbox')) {\n    if (nodePrivacyLevel === NodePrivacyLevel.ALLOW) {\n      safeAttrs.checked = !!inputElement.checked;\n    } else if (shouldMaskNode(inputElement, nodePrivacyLevel)) {\n      delete safeAttrs.checked;\n    }\n  }\n  /**\n   * Serialize the media playback state\n   */\n  if (tagName === 'audio' || tagName === 'video') {\n    var mediaElement = element;\n    safeAttrs.rr_mediaState = mediaElement.paused ? 'paused' : 'played';\n  }\n  /**\n   * Serialize the scroll state for each element only for full snapshot\n   */\n  var scrollTop;\n  var scrollLeft;\n  var serializationContext = options.serializationContext;\n  switch (serializationContext.status) {\n    case 0 /* SerializationContextStatus.INITIAL_FULL_SNAPSHOT */:\n      scrollTop = Math.round(element.scrollTop);\n      scrollLeft = Math.round(element.scrollLeft);\n      if (scrollTop || scrollLeft) {\n        serializationContext.elementsScrollPositions.set(element, {\n          scrollTop: scrollTop,\n          scrollLeft: scrollLeft\n        });\n      }\n      break;\n    case 1 /* SerializationContextStatus.SUBSEQUENT_FULL_SNAPSHOT */:\n      if (serializationContext.elementsScrollPositions.has(element)) {\n        ;\n        _a = serializationContext.elementsScrollPositions.get(element), scrollTop = _a.scrollTop, scrollLeft = _a.scrollLeft;\n      }\n      break;\n  }\n  if (scrollLeft) {\n    safeAttrs.rr_scrollLeft = scrollLeft;\n  }\n  if (scrollTop) {\n    safeAttrs.rr_scrollTop = scrollTop;\n  }\n  return safeAttrs;\n}\nexport function getCssRulesString(cssStyleSheet) {\n  if (!cssStyleSheet) {\n    return null;\n  }\n  var rules;\n  try {\n    rules = cssStyleSheet.rules || cssStyleSheet.cssRules;\n  } catch (_a) {\n    // if css is protected by CORS we cannot access cssRules see: https://www.w3.org/TR/cssom-1/#the-cssstylesheet-interface\n  }\n  if (!rules) {\n    return null;\n  }\n  var styleSheetCssText = Array.from(rules, isSafari() ? getCssRuleStringForSafari : getCssRuleString).join('');\n  return switchToAbsoluteUrl(styleSheetCssText, cssStyleSheet.href);\n}\nfunction getCssRuleStringForSafari(rule) {\n  // Safari does not escape attribute selectors containing : properly\n  // https://bugs.webkit.org/show_bug.cgi?id=184604\n  if (isCSSStyleRule(rule) && rule.selectorText.includes(':')) {\n    // This regex replaces [foo:bar] by [foo\\\\:bar]\n    var escapeColon = /(\\[[\\w-]+[^\\\\])(:[^\\]]+\\])/g;\n    return rule.cssText.replace(escapeColon, '$1\\\\$2');\n  }\n  return getCssRuleString(rule);\n}\nfunction getCssRuleString(rule) {\n  // If it's an @import rule, try to inline sub-rules recursively with `getCssRulesString`. This\n  // operation can fail if the imported stylesheet is protected by CORS, in which case we fallback\n  // to the @import rule CSS text.\n  return isCSSImportRule(rule) && getCssRulesString(rule.styleSheet) || rule.cssText;\n}\nfunction isCSSImportRule(rule) {\n  return 'styleSheet' in rule;\n}\nfunction isCSSStyleRule(rule) {\n  return 'selectorText' in rule;\n}","map":{"version":3,"names":["ExperimentalFeature","isExperimentalFeatureEnabled","isSafari","NodePrivacyLevel","shouldMaskNode","getElementInputValue","switchToAbsoluteUrl","getValidTagName","serializeAttribute","serializeAttributes","element","nodePrivacyLevel","options","HIDDEN","safeAttrs","tagName","doc","ownerDocument","i","attributes","length","attribute","item","attributeName","name","attributeValue","configuration","value","formValue","undefined","ALLOW","optionElement","selected","stylesheet","Array","from","styleSheets","find","s","href","cssText","getCssRulesString","DISABLE_REPLAY_INLINE_CSS","_cssText","sheet","inputElement","type","checked","mediaElement","rr_mediaState","paused","scrollTop","scrollLeft","serializationContext","status","Math","round","elementsScrollPositions","set","has","_a","get","rr_scrollLeft","rr_scrollTop","cssStyleSheet","rules","cssRules","styleSheetCssText","getCssRuleStringForSafari","getCssRuleString","join","rule","isCSSStyleRule","selectorText","includes","escapeColon","replace","isCSSImportRule","styleSheet"],"sources":["D:\\edu'\\Spritle\\Spritle\\node_modules\\@datadog\\browser-rum\\src\\domain\\record\\serialization\\serializeAttributes.ts"],"sourcesContent":["import { ExperimentalFeature, isExperimentalFeatureEnabled, isSafari } from '@datadog/browser-core'\n\nimport { NodePrivacyLevel } from '../../../constants'\nimport { shouldMaskNode } from '../privacy'\nimport { getElementInputValue, switchToAbsoluteUrl, getValidTagName } from './serializationUtils'\nimport type { SerializeOptions } from './serialization.types'\nimport { SerializationContextStatus } from './serialization.types'\nimport { serializeAttribute } from './serializeAttribute'\n\nexport function serializeAttributes(\n  element: Element,\n  nodePrivacyLevel: NodePrivacyLevel,\n  options: SerializeOptions\n): Record<string, string | number | boolean> {\n  if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n    return {}\n  }\n  const safeAttrs: Record<string, string | number | boolean> = {}\n  const tagName = getValidTagName(element.tagName)\n  const doc = element.ownerDocument\n\n  for (let i = 0; i < element.attributes.length; i += 1) {\n    const attribute = element.attributes.item(i)!\n    const attributeName = attribute.name\n    const attributeValue = serializeAttribute(element, nodePrivacyLevel, attributeName, options.configuration)\n    if (attributeValue !== null) {\n      safeAttrs[attributeName] = attributeValue\n    }\n  }\n\n  if (\n    (element as HTMLInputElement).value &&\n    (tagName === 'textarea' || tagName === 'select' || tagName === 'option' || tagName === 'input')\n  ) {\n    const formValue = getElementInputValue(element, nodePrivacyLevel)\n    if (formValue !== undefined) {\n      safeAttrs.value = formValue\n    }\n  }\n\n  /**\n   * <Option> can be selected, which occurs if its `value` matches ancestor `<Select>.value`\n   */\n  if (tagName === 'option' && nodePrivacyLevel === NodePrivacyLevel.ALLOW) {\n    // For privacy=`MASK`, all the values would be the same, so skip.\n    const optionElement = element as HTMLOptionElement\n    if (optionElement.selected) {\n      safeAttrs.selected = optionElement.selected\n    }\n  }\n\n  // remote css\n  if (tagName === 'link') {\n    const stylesheet = Array.from(doc.styleSheets).find((s) => s.href === (element as HTMLLinkElement).href)\n    const cssText = getCssRulesString(stylesheet)\n    if (cssText && stylesheet && !isExperimentalFeatureEnabled(ExperimentalFeature.DISABLE_REPLAY_INLINE_CSS)) {\n      safeAttrs._cssText = cssText\n    }\n  }\n\n  // dynamic stylesheet\n  if (tagName === 'style' && (element as HTMLStyleElement).sheet) {\n    const cssText = getCssRulesString((element as HTMLStyleElement).sheet)\n    if (cssText) {\n      safeAttrs._cssText = cssText\n    }\n  }\n\n  /**\n   * Forms: input[type=checkbox,radio]\n   * The `checked` property for <input> is a little bit special:\n   * 1. el.checked is a setter that returns if truthy.\n   * 2. getAttribute returns the string value\n   * getAttribute('checked') does not sync with `Element.checked`, so use JS property\n   * NOTE: `checked` property exists on `HTMLInputElement`. For serializer assumptions, we check for type=radio|check.\n   */\n  const inputElement = element as HTMLInputElement\n  if (tagName === 'input' && (inputElement.type === 'radio' || inputElement.type === 'checkbox')) {\n    if (nodePrivacyLevel === NodePrivacyLevel.ALLOW) {\n      safeAttrs.checked = !!inputElement.checked\n    } else if (shouldMaskNode(inputElement, nodePrivacyLevel)) {\n      delete safeAttrs.checked\n    }\n  }\n\n  /**\n   * Serialize the media playback state\n   */\n  if (tagName === 'audio' || tagName === 'video') {\n    const mediaElement = element as HTMLMediaElement\n    safeAttrs.rr_mediaState = mediaElement.paused ? 'paused' : 'played'\n  }\n\n  /**\n   * Serialize the scroll state for each element only for full snapshot\n   */\n  let scrollTop: number | undefined\n  let scrollLeft: number | undefined\n  const serializationContext = options.serializationContext\n  switch (serializationContext.status) {\n    case SerializationContextStatus.INITIAL_FULL_SNAPSHOT:\n      scrollTop = Math.round(element.scrollTop)\n      scrollLeft = Math.round(element.scrollLeft)\n      if (scrollTop || scrollLeft) {\n        serializationContext.elementsScrollPositions.set(element, { scrollTop, scrollLeft })\n      }\n      break\n    case SerializationContextStatus.SUBSEQUENT_FULL_SNAPSHOT:\n      if (serializationContext.elementsScrollPositions.has(element)) {\n        ;({ scrollTop, scrollLeft } = serializationContext.elementsScrollPositions.get(element)!)\n      }\n      break\n  }\n  if (scrollLeft) {\n    safeAttrs.rr_scrollLeft = scrollLeft\n  }\n  if (scrollTop) {\n    safeAttrs.rr_scrollTop = scrollTop\n  }\n\n  return safeAttrs\n}\n\nexport function getCssRulesString(cssStyleSheet: CSSStyleSheet | undefined | null): string | null {\n  if (!cssStyleSheet) {\n    return null\n  }\n  let rules: CSSRuleList | undefined\n  try {\n    rules = cssStyleSheet.rules || cssStyleSheet.cssRules\n  } catch {\n    // if css is protected by CORS we cannot access cssRules see: https://www.w3.org/TR/cssom-1/#the-cssstylesheet-interface\n  }\n  if (!rules) {\n    return null\n  }\n  const styleSheetCssText = Array.from(rules, isSafari() ? getCssRuleStringForSafari : getCssRuleString).join('')\n  return switchToAbsoluteUrl(styleSheetCssText, cssStyleSheet.href)\n}\n\nfunction getCssRuleStringForSafari(rule: CSSRule): string {\n  // Safari does not escape attribute selectors containing : properly\n  // https://bugs.webkit.org/show_bug.cgi?id=184604\n  if (isCSSStyleRule(rule) && rule.selectorText.includes(':')) {\n    // This regex replaces [foo:bar] by [foo\\\\:bar]\n    const escapeColon = /(\\[[\\w-]+[^\\\\])(:[^\\]]+\\])/g\n    return rule.cssText.replace(escapeColon, '$1\\\\$2')\n  }\n\n  return getCssRuleString(rule)\n}\n\nfunction getCssRuleString(rule: CSSRule): string {\n  // If it's an @import rule, try to inline sub-rules recursively with `getCssRulesString`. This\n  // operation can fail if the imported stylesheet is protected by CORS, in which case we fallback\n  // to the @import rule CSS text.\n  return (isCSSImportRule(rule) && getCssRulesString(rule.styleSheet)) || rule.cssText\n}\n\nfunction isCSSImportRule(rule: CSSRule): rule is CSSImportRule {\n  return 'styleSheet' in rule\n}\n\nfunction isCSSStyleRule(rule: CSSRule): rule is CSSStyleRule {\n  return 'selectorText' in rule\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}