{"ast":null,"code":"import { monitor } from '../tools/monitor';\nimport { getZoneJsOriginalValue } from '../tools/getZoneJsOriginalValue';\n// We want to use a real enum (i.e. not a const enum) here, to be able to iterate over it to automatically add _ddIsTrusted in e2e tests\n// eslint-disable-next-line no-restricted-syntax\nexport var DOM_EVENT;\n(function (DOM_EVENT) {\n  DOM_EVENT[\"BEFORE_UNLOAD\"] = \"beforeunload\";\n  DOM_EVENT[\"CLICK\"] = \"click\";\n  DOM_EVENT[\"DBL_CLICK\"] = \"dblclick\";\n  DOM_EVENT[\"KEY_DOWN\"] = \"keydown\";\n  DOM_EVENT[\"LOAD\"] = \"load\";\n  DOM_EVENT[\"POP_STATE\"] = \"popstate\";\n  DOM_EVENT[\"SCROLL\"] = \"scroll\";\n  DOM_EVENT[\"TOUCH_START\"] = \"touchstart\";\n  DOM_EVENT[\"TOUCH_END\"] = \"touchend\";\n  DOM_EVENT[\"TOUCH_MOVE\"] = \"touchmove\";\n  DOM_EVENT[\"VISIBILITY_CHANGE\"] = \"visibilitychange\";\n  DOM_EVENT[\"PAGE_SHOW\"] = \"pageshow\";\n  DOM_EVENT[\"FREEZE\"] = \"freeze\";\n  DOM_EVENT[\"RESUME\"] = \"resume\";\n  DOM_EVENT[\"DOM_CONTENT_LOADED\"] = \"DOMContentLoaded\";\n  DOM_EVENT[\"POINTER_DOWN\"] = \"pointerdown\";\n  DOM_EVENT[\"POINTER_UP\"] = \"pointerup\";\n  DOM_EVENT[\"POINTER_CANCEL\"] = \"pointercancel\";\n  DOM_EVENT[\"HASH_CHANGE\"] = \"hashchange\";\n  DOM_EVENT[\"PAGE_HIDE\"] = \"pagehide\";\n  DOM_EVENT[\"MOUSE_DOWN\"] = \"mousedown\";\n  DOM_EVENT[\"MOUSE_UP\"] = \"mouseup\";\n  DOM_EVENT[\"MOUSE_MOVE\"] = \"mousemove\";\n  DOM_EVENT[\"FOCUS\"] = \"focus\";\n  DOM_EVENT[\"BLUR\"] = \"blur\";\n  DOM_EVENT[\"CONTEXT_MENU\"] = \"contextmenu\";\n  DOM_EVENT[\"RESIZE\"] = \"resize\";\n  DOM_EVENT[\"CHANGE\"] = \"change\";\n  DOM_EVENT[\"INPUT\"] = \"input\";\n  DOM_EVENT[\"PLAY\"] = \"play\";\n  DOM_EVENT[\"PAUSE\"] = \"pause\";\n  DOM_EVENT[\"SECURITY_POLICY_VIOLATION\"] = \"securitypolicyviolation\";\n  DOM_EVENT[\"SELECTION_CHANGE\"] = \"selectionchange\";\n  DOM_EVENT[\"STORAGE\"] = \"storage\";\n})(DOM_EVENT || (DOM_EVENT = {}));\n/**\n * Add an event listener to an event target object (Window, Element, mock object...).  This provides\n * a few conveniences compared to using `element.addEventListener` directly:\n *\n * * supports IE11 by: using an option object only if needed and emulating the `once` option\n *\n * * wraps the listener with a `monitor` function\n *\n * * returns a `stop` function to remove the listener\n */\nexport function addEventListener(configuration, eventTarget, eventName, listener, options) {\n  return addEventListeners(configuration, eventTarget, [eventName], listener, options);\n}\n/**\n * Add event listeners to an event target object (Window, Element, mock object...).  This provides\n * a few conveniences compared to using `element.addEventListener` directly:\n *\n * * supports IE11 by: using an option object only if needed and emulating the `once` option\n *\n * * wraps the listener with a `monitor` function\n *\n * * returns a `stop` function to remove the listener\n *\n * * with `once: true`, the listener will be called at most once, even if different events are listened\n */\nexport function addEventListeners(configuration, eventTarget, eventNames, listener, _a) {\n  var _b = _a === void 0 ? {} : _a,\n    once = _b.once,\n    capture = _b.capture,\n    passive = _b.passive;\n  var listenerWithMonitor = monitor(function (event) {\n    if (!event.isTrusted && !event.__ddIsTrusted && !configuration.allowUntrustedEvents) {\n      return;\n    }\n    if (once) {\n      stop();\n    }\n    listener(event);\n  });\n  var options = passive ? {\n    capture: capture,\n    passive: passive\n  } : capture;\n  var add = getZoneJsOriginalValue(eventTarget, 'addEventListener');\n  eventNames.forEach(function (eventName) {\n    return add.call(eventTarget, eventName, listenerWithMonitor, options);\n  });\n  function stop() {\n    var remove = getZoneJsOriginalValue(eventTarget, 'removeEventListener');\n    eventNames.forEach(function (eventName) {\n      return remove.call(eventTarget, eventName, listenerWithMonitor, options);\n    });\n  }\n  return {\n    stop: stop\n  };\n}","map":{"version":3,"names":["monitor","getZoneJsOriginalValue","DOM_EVENT","addEventListener","configuration","eventTarget","eventName","listener","options","addEventListeners","eventNames","_a","_b","once","capture","passive","listenerWithMonitor","event","isTrusted","__ddIsTrusted","allowUntrustedEvents","stop","add","forEach","call","remove"],"sources":["D:\\edu'\\Spritle\\Spritle\\node_modules\\@datadog\\browser-core\\src\\browser\\addEventListener.ts"],"sourcesContent":["import { monitor } from '../tools/monitor'\nimport { getZoneJsOriginalValue } from '../tools/getZoneJsOriginalValue'\nimport type { Configuration } from '../domain/configuration'\nimport type { CookieStore, CookieStoreEventMap, VisualViewport, VisualViewportEventMap } from './types'\n\nexport type TrustableEvent<E extends Event = Event> = E & { __ddIsTrusted?: boolean }\n\n// We want to use a real enum (i.e. not a const enum) here, to be able to iterate over it to automatically add _ddIsTrusted in e2e tests\n// eslint-disable-next-line no-restricted-syntax\nexport enum DOM_EVENT {\n  BEFORE_UNLOAD = 'beforeunload',\n  CLICK = 'click',\n  DBL_CLICK = 'dblclick',\n  KEY_DOWN = 'keydown',\n  LOAD = 'load',\n  POP_STATE = 'popstate',\n  SCROLL = 'scroll',\n  TOUCH_START = 'touchstart',\n  TOUCH_END = 'touchend',\n  TOUCH_MOVE = 'touchmove',\n  VISIBILITY_CHANGE = 'visibilitychange',\n  PAGE_SHOW = 'pageshow',\n  FREEZE = 'freeze',\n  RESUME = 'resume',\n  DOM_CONTENT_LOADED = 'DOMContentLoaded',\n  POINTER_DOWN = 'pointerdown',\n  POINTER_UP = 'pointerup',\n  POINTER_CANCEL = 'pointercancel',\n  HASH_CHANGE = 'hashchange',\n  PAGE_HIDE = 'pagehide',\n  MOUSE_DOWN = 'mousedown',\n  MOUSE_UP = 'mouseup',\n  MOUSE_MOVE = 'mousemove',\n  FOCUS = 'focus',\n  BLUR = 'blur',\n  CONTEXT_MENU = 'contextmenu',\n  RESIZE = 'resize',\n  CHANGE = 'change',\n  INPUT = 'input',\n  PLAY = 'play',\n  PAUSE = 'pause',\n  SECURITY_POLICY_VIOLATION = 'securitypolicyviolation',\n  SELECTION_CHANGE = 'selectionchange',\n  STORAGE = 'storage',\n}\n\ninterface AddEventListenerOptions {\n  once?: boolean\n  capture?: boolean\n  passive?: boolean\n}\n\ntype EventMapFor<T> = T extends Window\n  ? WindowEventMap & {\n      // TS 4.9.5 does not support `freeze` and `resume` events yet\n      freeze: Event\n      resume: Event\n      // TS 4.9.5 does not define `visibilitychange` on Window (only Document)\n      visibilitychange: Event\n    }\n  : T extends Document\n    ? DocumentEventMap\n    : T extends HTMLElement\n      ? HTMLElementEventMap\n      : T extends VisualViewport\n        ? VisualViewportEventMap\n        : T extends ShadowRoot\n          ? // ShadowRootEventMap is not yet defined in our supported TS version. Instead, use\n            // GlobalEventHandlersEventMap which is more than enough as we only need to listen for events bubbling\n            // through the ShadowRoot like \"change\" or \"input\"\n            GlobalEventHandlersEventMap\n          : T extends XMLHttpRequest\n            ? XMLHttpRequestEventMap\n            : T extends Performance\n              ? PerformanceEventMap\n              : T extends Worker\n                ? WorkerEventMap\n                : T extends CookieStore\n                  ? CookieStoreEventMap\n                  : Record<never, never>\n\n/**\n * Add an event listener to an event target object (Window, Element, mock object...).  This provides\n * a few conveniences compared to using `element.addEventListener` directly:\n *\n * * supports IE11 by: using an option object only if needed and emulating the `once` option\n *\n * * wraps the listener with a `monitor` function\n *\n * * returns a `stop` function to remove the listener\n */\nexport function addEventListener<Target extends EventTarget, EventName extends keyof EventMapFor<Target> & string>(\n  configuration: Configuration,\n  eventTarget: Target,\n  eventName: EventName,\n  listener: (event: EventMapFor<Target>[EventName] & { type: EventName }) => void,\n  options?: AddEventListenerOptions\n) {\n  return addEventListeners(configuration, eventTarget, [eventName], listener, options)\n}\n\n/**\n * Add event listeners to an event target object (Window, Element, mock object...).  This provides\n * a few conveniences compared to using `element.addEventListener` directly:\n *\n * * supports IE11 by: using an option object only if needed and emulating the `once` option\n *\n * * wraps the listener with a `monitor` function\n *\n * * returns a `stop` function to remove the listener\n *\n * * with `once: true`, the listener will be called at most once, even if different events are listened\n */\nexport function addEventListeners<Target extends EventTarget, EventName extends keyof EventMapFor<Target> & string>(\n  configuration: Configuration,\n  eventTarget: Target,\n  eventNames: EventName[],\n  listener: (event: EventMapFor<Target>[EventName] & { type: EventName }) => void,\n  { once, capture, passive }: AddEventListenerOptions = {}\n) {\n  const listenerWithMonitor = monitor((event: TrustableEvent) => {\n    if (!event.isTrusted && !event.__ddIsTrusted && !configuration.allowUntrustedEvents) {\n      return\n    }\n    if (once) {\n      stop()\n    }\n    listener(event as unknown as EventMapFor<Target>[EventName] & { type: EventName })\n  })\n\n  const options = passive ? { capture, passive } : capture\n\n  const add = getZoneJsOriginalValue(eventTarget, 'addEventListener')\n  eventNames.forEach((eventName) => add.call(eventTarget, eventName, listenerWithMonitor, options))\n\n  function stop() {\n    const remove = getZoneJsOriginalValue(eventTarget, 'removeEventListener')\n    eventNames.forEach((eventName) => remove.call(eventTarget, eventName, listenerWithMonitor, options))\n  }\n\n  return {\n    stop,\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}