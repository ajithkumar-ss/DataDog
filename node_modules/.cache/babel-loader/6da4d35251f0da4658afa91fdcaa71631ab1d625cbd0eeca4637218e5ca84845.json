{"ast":null,"code":"/**\n * Browsers have not standardized various dimension properties. Mobile devices typically report\n * dimensions in reference to the visual viewport, while desktop uses the layout viewport. For example,\n * Mobile Chrome will change innerWidth when a pinch zoom takes place, while Chrome Desktop (mac) will not.\n *\n * With the new Viewport API, we now calculate and normalize dimension properties to the layout viewport.\n * If the VisualViewport API is not supported by a browser, it isn't reasonably possible to detect or normalize\n * which viewport is being measured. Therefore these exported functions will fallback to assuming that the layout\n * viewport is being measured by the browser\n */\n// Scrollbar widths vary across properties on different devices and browsers\nvar TOLERANCE = 25;\n/**\n * Use the Visual Viewport API's properties to measure scrollX/Y in reference to the layout viewport\n * in order to determine if window.scrollX/Y is measuring the layout or visual viewport.\n * This finding corresponds to which viewport mouseEvent.clientX/Y and window.innerWidth/Height measures.\n */\nfunction isVisualViewportFactoredIn(visualViewport) {\n  return Math.abs(visualViewport.pageTop - visualViewport.offsetTop - window.scrollY) > TOLERANCE || Math.abs(visualViewport.pageLeft - visualViewport.offsetLeft - window.scrollX) > TOLERANCE;\n}\nexport var convertMouseEventToLayoutCoordinates = function (clientX, clientY) {\n  var visualViewport = window.visualViewport;\n  var normalized = {\n    layoutViewportX: clientX,\n    layoutViewportY: clientY,\n    visualViewportX: clientX,\n    visualViewportY: clientY\n  };\n  if (!visualViewport) {\n    // On old browsers, we cannot normalize, so fallback to clientX/Y\n    return normalized;\n  } else if (isVisualViewportFactoredIn(visualViewport)) {\n    // Typically Mobile Devices\n    normalized.layoutViewportX = Math.round(clientX + visualViewport.offsetLeft);\n    normalized.layoutViewportY = Math.round(clientY + visualViewport.offsetTop);\n  } else {\n    // Typically Desktop Devices\n    normalized.visualViewportX = Math.round(clientX - visualViewport.offsetLeft);\n    normalized.visualViewportY = Math.round(clientY - visualViewport.offsetTop);\n  }\n  return normalized;\n};\nexport var getVisualViewport = function (visualViewport) {\n  return {\n    scale: visualViewport.scale,\n    offsetLeft: visualViewport.offsetLeft,\n    offsetTop: visualViewport.offsetTop,\n    pageLeft: visualViewport.pageLeft,\n    pageTop: visualViewport.pageTop,\n    height: visualViewport.height,\n    width: visualViewport.width\n  };\n};","map":{"version":3,"names":["TOLERANCE","isVisualViewportFactoredIn","visualViewport","Math","abs","pageTop","offsetTop","window","scrollY","pageLeft","offsetLeft","scrollX","convertMouseEventToLayoutCoordinates","clientX","clientY","normalized","layoutViewportX","layoutViewportY","visualViewportX","visualViewportY","round","getVisualViewport","scale","height","width"],"sources":["D:\\edu'\\Spritle\\spritle\\node_modules\\@datadog\\browser-rum\\src\\domain\\record\\viewports.ts"],"sourcesContent":["/**\n * Browsers have not standardized various dimension properties. Mobile devices typically report\n * dimensions in reference to the visual viewport, while desktop uses the layout viewport. For example,\n * Mobile Chrome will change innerWidth when a pinch zoom takes place, while Chrome Desktop (mac) will not.\n *\n * With the new Viewport API, we now calculate and normalize dimension properties to the layout viewport.\n * If the VisualViewport API is not supported by a browser, it isn't reasonably possible to detect or normalize\n * which viewport is being measured. Therefore these exported functions will fallback to assuming that the layout\n * viewport is being measured by the browser\n */\n\nimport type { VisualViewportRecord } from '../../types'\n\n// Scrollbar widths vary across properties on different devices and browsers\nconst TOLERANCE = 25\n\n/**\n * Use the Visual Viewport API's properties to measure scrollX/Y in reference to the layout viewport\n * in order to determine if window.scrollX/Y is measuring the layout or visual viewport.\n * This finding corresponds to which viewport mouseEvent.clientX/Y and window.innerWidth/Height measures.\n */\nfunction isVisualViewportFactoredIn(visualViewport: VisualViewport) {\n  return (\n    Math.abs(visualViewport.pageTop - visualViewport.offsetTop - window.scrollY) > TOLERANCE ||\n    Math.abs(visualViewport.pageLeft - visualViewport.offsetLeft - window.scrollX) > TOLERANCE\n  )\n}\n\ninterface LayoutCoordinates {\n  layoutViewportX: number\n  layoutViewportY: number\n  visualViewportX: number\n  visualViewportY: number\n}\n\nexport const convertMouseEventToLayoutCoordinates = (clientX: number, clientY: number): LayoutCoordinates => {\n  const visualViewport = window.visualViewport\n  const normalized: LayoutCoordinates = {\n    layoutViewportX: clientX,\n    layoutViewportY: clientY,\n    visualViewportX: clientX,\n    visualViewportY: clientY,\n  }\n\n  if (!visualViewport) {\n    // On old browsers, we cannot normalize, so fallback to clientX/Y\n    return normalized\n  } else if (isVisualViewportFactoredIn(visualViewport)) {\n    // Typically Mobile Devices\n    normalized.layoutViewportX = Math.round(clientX + visualViewport.offsetLeft)\n    normalized.layoutViewportY = Math.round(clientY + visualViewport.offsetTop)\n  } else {\n    // Typically Desktop Devices\n    normalized.visualViewportX = Math.round(clientX - visualViewport.offsetLeft)\n    normalized.visualViewportY = Math.round(clientY - visualViewport.offsetTop)\n  }\n  return normalized\n}\n\nexport const getVisualViewport = (visualViewport: VisualViewport): VisualViewportRecord['data'] => ({\n  scale: visualViewport.scale,\n  offsetLeft: visualViewport.offsetLeft,\n  offsetTop: visualViewport.offsetTop,\n  pageLeft: visualViewport.pageLeft,\n  pageTop: visualViewport.pageTop,\n  height: visualViewport.height,\n  width: visualViewport.width,\n})\n"],"mappings":"AAAA;;;;;;;;;;AAaA;AACA,IAAMA,SAAS,GAAG,EAAE;AAEpB;;;;;AAKA,SAASC,0BAA0BA,CAACC,cAA8B;EAChE,OACEC,IAAI,CAACC,GAAG,CAACF,cAAc,CAACG,OAAO,GAAGH,cAAc,CAACI,SAAS,GAAGC,MAAM,CAACC,OAAO,CAAC,GAAGR,SAAS,IACxFG,IAAI,CAACC,GAAG,CAACF,cAAc,CAACO,QAAQ,GAAGP,cAAc,CAACQ,UAAU,GAAGH,MAAM,CAACI,OAAO,CAAC,GAAGX,SAAS;AAE9F;AASA,OAAO,IAAMY,oCAAoC,GAAG,SAAAA,CAACC,OAAe,EAAEC,OAAe;EACnF,IAAMZ,cAAc,GAAGK,MAAM,CAACL,cAAc;EAC5C,IAAMa,UAAU,GAAsB;IACpCC,eAAe,EAAEH,OAAO;IACxBI,eAAe,EAAEH,OAAO;IACxBI,eAAe,EAAEL,OAAO;IACxBM,eAAe,EAAEL;GAClB;EAED,IAAI,CAACZ,cAAc,EAAE;IACnB;IACA,OAAOa,UAAU;EACnB,CAAC,MAAM,IAAId,0BAA0B,CAACC,cAAc,CAAC,EAAE;IACrD;IACAa,UAAU,CAACC,eAAe,GAAGb,IAAI,CAACiB,KAAK,CAACP,OAAO,GAAGX,cAAc,CAACQ,UAAU,CAAC;IAC5EK,UAAU,CAACE,eAAe,GAAGd,IAAI,CAACiB,KAAK,CAACN,OAAO,GAAGZ,cAAc,CAACI,SAAS,CAAC;EAC7E,CAAC,MAAM;IACL;IACAS,UAAU,CAACG,eAAe,GAAGf,IAAI,CAACiB,KAAK,CAACP,OAAO,GAAGX,cAAc,CAACQ,UAAU,CAAC;IAC5EK,UAAU,CAACI,eAAe,GAAGhB,IAAI,CAACiB,KAAK,CAACN,OAAO,GAAGZ,cAAc,CAACI,SAAS,CAAC;EAC7E;EACA,OAAOS,UAAU;AACnB,CAAC;AAED,OAAO,IAAMM,iBAAiB,GAAG,SAAAA,CAACnB,cAA8B;EAAmC,OAAC;IAClGoB,KAAK,EAAEpB,cAAc,CAACoB,KAAK;IAC3BZ,UAAU,EAAER,cAAc,CAACQ,UAAU;IACrCJ,SAAS,EAAEJ,cAAc,CAACI,SAAS;IACnCG,QAAQ,EAAEP,cAAc,CAACO,QAAQ;IACjCJ,OAAO,EAAEH,cAAc,CAACG,OAAO;IAC/BkB,MAAM,EAAErB,cAAc,CAACqB,MAAM;IAC7BC,KAAK,EAAEtB,cAAc,CAACsB;GACvB;AARkG,CAQjG","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}