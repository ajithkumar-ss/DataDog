{"ast":null,"code":"import { startsWith } from './utils/polyfills';\nimport { display } from './display';\nimport { getType } from './utils/typeUtils';\nexport function isMatchOption(item) {\n  var itemType = getType(item);\n  return itemType === 'string' || itemType === 'function' || item instanceof RegExp;\n}\n/**\n * Returns true if value can be matched by at least one of the provided MatchOptions.\n * When comparing strings, setting useStartsWith to true will compare the value with the start of\n * the option, instead of requiring an exact match.\n */\nexport function matchList(list, value, useStartsWith) {\n  if (useStartsWith === void 0) {\n    useStartsWith = false;\n  }\n  return list.some(function (item) {\n    try {\n      if (typeof item === 'function') {\n        return item(value);\n      } else if (item instanceof RegExp) {\n        return item.test(value);\n      } else if (typeof item === 'string') {\n        return useStartsWith ? startsWith(value, item) : item === value;\n      }\n    } catch (e) {\n      display.error(e);\n    }\n    return false;\n  });\n}","map":{"version":3,"names":["startsWith","display","getType","isMatchOption","item","itemType","RegExp","matchList","list","value","useStartsWith","some","test","e","error"],"sources":["D:\\edu'\\Spritle\\spritle\\node_modules\\@datadog\\browser-core\\src\\tools\\matchOption.ts"],"sourcesContent":["import { startsWith } from './utils/polyfills'\nimport { display } from './display'\nimport { getType } from './utils/typeUtils'\n\nexport type MatchOption = string | RegExp | ((value: string) => boolean)\n\nexport function isMatchOption(item: unknown): item is MatchOption {\n  const itemType = getType(item)\n  return itemType === 'string' || itemType === 'function' || item instanceof RegExp\n}\n\n/**\n * Returns true if value can be matched by at least one of the provided MatchOptions.\n * When comparing strings, setting useStartsWith to true will compare the value with the start of\n * the option, instead of requiring an exact match.\n */\nexport function matchList(list: MatchOption[], value: string, useStartsWith = false): boolean {\n  return list.some((item) => {\n    try {\n      if (typeof item === 'function') {\n        return item(value)\n      } else if (item instanceof RegExp) {\n        return item.test(value)\n      } else if (typeof item === 'string') {\n        return useStartsWith ? startsWith(value, item) : item === value\n      }\n    } catch (e) {\n      display.error(e)\n    }\n    return false\n  })\n}\n"],"mappings":"AAAA,SAASA,UAAU,QAAQ,mBAAmB;AAC9C,SAASC,OAAO,QAAQ,WAAW;AACnC,SAASC,OAAO,QAAQ,mBAAmB;AAI3C,OAAM,SAAUC,aAAaA,CAACC,IAAa;EACzC,IAAMC,QAAQ,GAAGH,OAAO,CAACE,IAAI,CAAC;EAC9B,OAAOC,QAAQ,KAAK,QAAQ,IAAIA,QAAQ,KAAK,UAAU,IAAID,IAAI,YAAYE,MAAM;AACnF;AAEA;;;;;AAKA,OAAM,SAAUC,SAASA,CAACC,IAAmB,EAAEC,KAAa,EAAEC,aAAqB;EAArB,IAAAA,aAAA;IAAAA,aAAA,QAAqB;EAAA;EACjF,OAAOF,IAAI,CAACG,IAAI,CAAC,UAACP,IAAI;IACpB,IAAI;MACF,IAAI,OAAOA,IAAI,KAAK,UAAU,EAAE;QAC9B,OAAOA,IAAI,CAACK,KAAK,CAAC;MACpB,CAAC,MAAM,IAAIL,IAAI,YAAYE,MAAM,EAAE;QACjC,OAAOF,IAAI,CAACQ,IAAI,CAACH,KAAK,CAAC;MACzB,CAAC,MAAM,IAAI,OAAOL,IAAI,KAAK,QAAQ,EAAE;QACnC,OAAOM,aAAa,GAAGV,UAAU,CAACS,KAAK,EAAEL,IAAI,CAAC,GAAGA,IAAI,KAAKK,KAAK;MACjE;IACF,CAAC,CAAC,OAAOI,CAAC,EAAE;MACVZ,OAAO,CAACa,KAAK,CAACD,CAAC,CAAC;IAClB;IACA,OAAO,KAAK;EACd,CAAC,CAAC;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}