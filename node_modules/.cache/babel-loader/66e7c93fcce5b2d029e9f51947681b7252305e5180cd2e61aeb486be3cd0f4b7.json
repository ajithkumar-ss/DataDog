{"ast":null,"code":"import { DOM_EVENT, ExperimentalFeature, ONE_MINUTE, addEventListeners, addTelemetryDebug, findLast, isExperimentalFeatureEnabled, relativeNow } from '@datadog/browser-core';\nimport { RumPerformanceEntryType } from '../../../browser/performanceCollection';\nimport { getSelectorFromElement } from '../../getSelectorFromElement';\n// Discard LCP timings above a certain delay to avoid incorrect data\n// It happens in some cases like sleep mode or some browser implementations\nexport var LCP_MAXIMUM_DELAY = 10 * ONE_MINUTE;\nvar wrongLcpReported = false;\nvar previousLcp;\n/**\n * Track the largest contentful paint (LCP) occurring during the initial View.  This can yield\n * multiple values, only the most recent one should be used.\n * Documentation: https://web.dev/lcp/\n * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/onLCP.ts\n */\nexport function trackLargestContentfulPaint(lifeCycle, configuration, firstHidden, eventTarget, callback) {\n  // Ignore entries that come after the first user interaction. According to the documentation, the\n  // browser should not send largest-contentful-paint entries after a user interact with the page,\n  // but the web-vitals reference implementation uses this as a safeguard.\n  var firstInteractionTimestamp = Infinity;\n  var stopEventListener = addEventListeners(configuration, eventTarget, [DOM_EVENT.POINTER_DOWN, DOM_EVENT.KEY_DOWN], function (event) {\n    firstInteractionTimestamp = event.timeStamp;\n  }, {\n    capture: true,\n    once: true\n  }).stop;\n  var biggestLcpSize = 0;\n  var unsubscribeLifeCycle = lifeCycle.subscribe(0 /* LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED */, function (entries) {\n    var lcpEntry = findLast(entries, function (entry) {\n      return entry.entryType === RumPerformanceEntryType.LARGEST_CONTENTFUL_PAINT && entry.startTime < firstInteractionTimestamp && entry.startTime < firstHidden.timeStamp && entry.startTime < LCP_MAXIMUM_DELAY &&\n      // Ensure to get the LCP entry with the biggest size, see\n      // https://bugs.chromium.org/p/chromium/issues/detail?id=1516655\n      entry.size > biggestLcpSize;\n    });\n    if (lcpEntry) {\n      var lcpTargetSelector = void 0;\n      if (lcpEntry.element) {\n        lcpTargetSelector = getSelectorFromElement(lcpEntry.element, configuration.actionNameAttribute);\n      }\n      if (isExperimentalFeatureEnabled(ExperimentalFeature.ZERO_LCP_TELEMETRY)) {\n        monitorLcpEntries(lcpEntry, entries.filter(function (entry) {\n          return entry.entryType === RumPerformanceEntryType.LARGEST_CONTENTFUL_PAINT;\n        }));\n      }\n      callback({\n        value: lcpEntry.startTime,\n        targetSelector: lcpTargetSelector\n      });\n      biggestLcpSize = lcpEntry.size;\n    }\n  }).unsubscribe;\n  return {\n    stop: function () {\n      stopEventListener();\n      unsubscribeLifeCycle();\n    }\n  };\n}\nfunction monitorLcpEntries(lcpEntry, lcpEntries) {\n  if (wrongLcpReported) {\n    return;\n  }\n  var wrongLcpDetected = lcpEntry.startTime === 0 ? 'LCP with startTime = 0' : previousLcp !== undefined && lcpEntry.startTime < previousLcp.startTime ? 'LCP with startTime < previous LCP' : previousLcp !== undefined && lcpEntry.size < previousLcp.size ? 'LCP with size < previous LCP' : undefined;\n  if (wrongLcpDetected) {\n    wrongLcpReported = true;\n    addTelemetryDebug(wrongLcpDetected, {\n      debug: {\n        entry: toSerializableLCP(lcpEntry),\n        previousLcp: previousLcp,\n        timeOrigin: performance.timeOrigin,\n        now: relativeNow(),\n        lcpEntries: lcpEntries.map(toSerializableLCP)\n      }\n    });\n  }\n  previousLcp = toSerializableLCP(lcpEntry);\n}\nfunction toSerializableLCP(entry) {\n  var jsonEntry = entry.toJSON();\n  delete jsonEntry.element;\n  return jsonEntry;\n}","map":{"version":3,"names":["DOM_EVENT","ExperimentalFeature","ONE_MINUTE","addEventListeners","addTelemetryDebug","findLast","isExperimentalFeatureEnabled","relativeNow","RumPerformanceEntryType","getSelectorFromElement","LCP_MAXIMUM_DELAY","wrongLcpReported","previousLcp","trackLargestContentfulPaint","lifeCycle","configuration","firstHidden","eventTarget","callback","firstInteractionTimestamp","Infinity","stopEventListener","POINTER_DOWN","KEY_DOWN","event","timeStamp","capture","once","stop","biggestLcpSize","unsubscribeLifeCycle","subscribe","entries","lcpEntry","entry","entryType","LARGEST_CONTENTFUL_PAINT","startTime","size","lcpTargetSelector","element","actionNameAttribute","ZERO_LCP_TELEMETRY","monitorLcpEntries","filter","value","targetSelector","unsubscribe","lcpEntries","wrongLcpDetected","undefined","debug","toSerializableLCP","timeOrigin","performance","now","map","jsonEntry","toJSON"],"sources":["D:\\edu'\\Spritle\\spritle\\node_modules\\@datadog\\browser-rum-core\\src\\domain\\view\\viewMetrics\\trackLargestContentfulPaint.ts"],"sourcesContent":["import type { RelativeTime } from '@datadog/browser-core'\nimport {\n  DOM_EVENT,\n  ExperimentalFeature,\n  ONE_MINUTE,\n  addEventListeners,\n  addTelemetryDebug,\n  findLast,\n  isExperimentalFeatureEnabled,\n  relativeNow,\n} from '@datadog/browser-core'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport type { LifeCycle } from '../../lifeCycle'\nimport type { RumConfiguration } from '../../configuration'\nimport { RumPerformanceEntryType } from '../../../browser/performanceCollection'\nimport type { RumLargestContentfulPaintTiming } from '../../../browser/performanceCollection'\nimport { getSelectorFromElement } from '../../getSelectorFromElement'\nimport type { FirstHidden } from './trackFirstHidden'\n\n// Discard LCP timings above a certain delay to avoid incorrect data\n// It happens in some cases like sleep mode or some browser implementations\nexport const LCP_MAXIMUM_DELAY = 10 * ONE_MINUTE\n\nexport interface LargestContentfulPaint {\n  value: RelativeTime\n  targetSelector?: string\n}\n\ntype SerializableLCP = Omit<RumLargestContentfulPaintTiming, 'toJSON' | 'element'>\n\nlet wrongLcpReported = false\nlet previousLcp: SerializableLCP\n\n/**\n * Track the largest contentful paint (LCP) occurring during the initial View.  This can yield\n * multiple values, only the most recent one should be used.\n * Documentation: https://web.dev/lcp/\n * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/onLCP.ts\n */\nexport function trackLargestContentfulPaint(\n  lifeCycle: LifeCycle,\n  configuration: RumConfiguration,\n  firstHidden: FirstHidden,\n  eventTarget: Window,\n  callback: (largestContentfulPaint: LargestContentfulPaint) => void\n) {\n  // Ignore entries that come after the first user interaction. According to the documentation, the\n  // browser should not send largest-contentful-paint entries after a user interact with the page,\n  // but the web-vitals reference implementation uses this as a safeguard.\n  let firstInteractionTimestamp = Infinity\n  const { stop: stopEventListener } = addEventListeners(\n    configuration,\n    eventTarget,\n    [DOM_EVENT.POINTER_DOWN, DOM_EVENT.KEY_DOWN],\n    (event) => {\n      firstInteractionTimestamp = event.timeStamp\n    },\n    { capture: true, once: true }\n  )\n\n  let biggestLcpSize = 0\n  const { unsubscribe: unsubscribeLifeCycle } = lifeCycle.subscribe(\n    LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED,\n    (entries) => {\n      const lcpEntry = findLast(\n        entries,\n        (entry): entry is RumLargestContentfulPaintTiming =>\n          entry.entryType === RumPerformanceEntryType.LARGEST_CONTENTFUL_PAINT &&\n          entry.startTime < firstInteractionTimestamp &&\n          entry.startTime < firstHidden.timeStamp &&\n          entry.startTime < LCP_MAXIMUM_DELAY &&\n          // Ensure to get the LCP entry with the biggest size, see\n          // https://bugs.chromium.org/p/chromium/issues/detail?id=1516655\n          entry.size > biggestLcpSize\n      )\n\n      if (lcpEntry) {\n        let lcpTargetSelector\n        if (lcpEntry.element) {\n          lcpTargetSelector = getSelectorFromElement(lcpEntry.element, configuration.actionNameAttribute)\n        }\n\n        if (isExperimentalFeatureEnabled(ExperimentalFeature.ZERO_LCP_TELEMETRY)) {\n          monitorLcpEntries(\n            lcpEntry,\n            entries.filter(\n              (entry): entry is RumLargestContentfulPaintTiming =>\n                entry.entryType === RumPerformanceEntryType.LARGEST_CONTENTFUL_PAINT\n            )\n          )\n        }\n\n        callback({\n          value: lcpEntry.startTime,\n          targetSelector: lcpTargetSelector,\n        })\n        biggestLcpSize = lcpEntry.size\n      }\n    }\n  )\n\n  return {\n    stop: () => {\n      stopEventListener()\n      unsubscribeLifeCycle()\n    },\n  }\n}\n\nfunction monitorLcpEntries(lcpEntry: RumLargestContentfulPaintTiming, lcpEntries: RumLargestContentfulPaintTiming[]) {\n  if (wrongLcpReported) {\n    return\n  }\n\n  const wrongLcpDetected =\n    lcpEntry.startTime === 0\n      ? 'LCP with startTime = 0'\n      : previousLcp !== undefined && lcpEntry.startTime < previousLcp.startTime\n        ? 'LCP with startTime < previous LCP'\n        : previousLcp !== undefined && lcpEntry.size < previousLcp.size\n          ? 'LCP with size < previous LCP'\n          : undefined\n\n  if (wrongLcpDetected) {\n    wrongLcpReported = true\n\n    addTelemetryDebug(wrongLcpDetected, {\n      debug: {\n        entry: toSerializableLCP(lcpEntry),\n        previousLcp,\n        timeOrigin: performance.timeOrigin,\n        now: relativeNow(),\n        lcpEntries: lcpEntries.map(toSerializableLCP),\n      },\n    })\n  }\n\n  previousLcp = toSerializableLCP(lcpEntry)\n}\n\nfunction toSerializableLCP(entry: RumLargestContentfulPaintTiming): SerializableLCP {\n  const jsonEntry = entry.toJSON()\n  delete jsonEntry.element\n  return jsonEntry\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}