{"ast":null,"code":"import { clearInterval, setInterval } from '../../tools/timer';\nimport { Observable } from '../../tools/observable';\nimport { ONE_SECOND, dateNow } from '../../tools/utils/timeUtils';\nimport { throttle } from '../../tools/utils/functionUtils';\nimport { generateUUID } from '../../tools/utils/stringUtils';\nimport { selectCookieStrategy, initCookieStrategy } from './storeStrategies/sessionInCookie';\nimport { getExpiredSessionState, isSessionInExpiredState, isSessionInNotStartedState } from './sessionState';\nimport { initLocalStorageStrategy, selectLocalStorageStrategy } from './storeStrategies/sessionInLocalStorage';\nimport { processSessionStoreOperations } from './sessionStoreOperations';\n/**\n * Every second, the storage will be polled to check for any change that can occur\n * to the session state in another browser tab, or another window.\n * This value has been determined from our previous cookie-only implementation.\n */\nexport var STORAGE_POLL_DELAY = ONE_SECOND;\n/**\n * Checks if cookies are available as the preferred storage\n * Else, checks if LocalStorage is allowed and available\n */\nexport function selectSessionStoreStrategyType(initConfiguration) {\n  var sessionStoreStrategyType = selectCookieStrategy(initConfiguration);\n  if (!sessionStoreStrategyType && initConfiguration.allowFallbackToLocalStorage) {\n    sessionStoreStrategyType = selectLocalStorageStrategy();\n  }\n  return sessionStoreStrategyType;\n}\n/**\n * Different session concepts:\n * - tracked, the session has an id and is updated along the user navigation\n * - not tracked, the session does not have an id but it is updated along the user navigation\n * - inactive, no session in store or session expired, waiting for a renew session\n */\nexport function startSessionStore(sessionStoreStrategyType, productKey, computeSessionState) {\n  var renewObservable = new Observable();\n  var expireObservable = new Observable();\n  var sessionStoreStrategy = sessionStoreStrategyType.type === 'Cookie' ? initCookieStrategy(sessionStoreStrategyType.cookieOptions) : initLocalStorageStrategy();\n  var expireSession = sessionStoreStrategy.expireSession;\n  var watchSessionTimeoutId = setInterval(watchSession, STORAGE_POLL_DELAY);\n  var sessionCache;\n  startSession();\n  var _a = throttle(function () {\n      var isTracked;\n      processSessionStoreOperations({\n        process: function (sessionState) {\n          if (isSessionInNotStartedState(sessionState)) {\n            return;\n          }\n          var synchronizedSession = synchronizeSession(sessionState);\n          isTracked = expandOrRenewSessionState(synchronizedSession);\n          return synchronizedSession;\n        },\n        after: function (sessionState) {\n          if (isTracked && !hasSessionInCache()) {\n            renewSessionInCache(sessionState);\n          }\n          sessionCache = sessionState;\n        }\n      }, sessionStoreStrategy);\n    }, STORAGE_POLL_DELAY),\n    throttledExpandOrRenewSession = _a.throttled,\n    cancelExpandOrRenewSession = _a.cancel;\n  function expandSession() {\n    processSessionStoreOperations({\n      process: function (sessionState) {\n        return hasSessionInCache() ? synchronizeSession(sessionState) : undefined;\n      }\n    }, sessionStoreStrategy);\n  }\n  /**\n   * allows two behaviors:\n   * - if the session is active, synchronize the session cache without updating the session store\n   * - if the session is not active, clear the session store and expire the session cache\n   */\n  function watchSession() {\n    processSessionStoreOperations({\n      process: function (sessionState) {\n        return isSessionInExpiredState(sessionState) ? getExpiredSessionState() : undefined;\n      },\n      after: synchronizeSession\n    }, sessionStoreStrategy);\n  }\n  function synchronizeSession(sessionState) {\n    if (isSessionInExpiredState(sessionState)) {\n      sessionState = getExpiredSessionState();\n    }\n    if (hasSessionInCache()) {\n      if (isSessionInCacheOutdated(sessionState)) {\n        expireSessionInCache();\n      } else {\n        sessionCache = sessionState;\n      }\n    }\n    return sessionState;\n  }\n  function startSession() {\n    processSessionStoreOperations({\n      process: function (sessionState) {\n        if (isSessionInNotStartedState(sessionState)) {\n          return getExpiredSessionState();\n        }\n      },\n      after: function (sessionState) {\n        sessionCache = sessionState;\n      }\n    }, sessionStoreStrategy);\n  }\n  function expandOrRenewSessionState(sessionState) {\n    if (isSessionInNotStartedState(sessionState)) {\n      return false;\n    }\n    var _a = computeSessionState(sessionState[productKey]),\n      trackingType = _a.trackingType,\n      isTracked = _a.isTracked;\n    sessionState[productKey] = trackingType;\n    delete sessionState.isExpired;\n    if (isTracked && !sessionState.id) {\n      sessionState.id = generateUUID();\n      sessionState.created = String(dateNow());\n    }\n    return isTracked;\n  }\n  function hasSessionInCache() {\n    return sessionCache[productKey] !== undefined;\n  }\n  function isSessionInCacheOutdated(sessionState) {\n    return sessionCache.id !== sessionState.id || sessionCache[productKey] !== sessionState[productKey];\n  }\n  function expireSessionInCache() {\n    sessionCache = getExpiredSessionState();\n    expireObservable.notify();\n  }\n  function renewSessionInCache(sessionState) {\n    sessionCache = sessionState;\n    renewObservable.notify();\n  }\n  return {\n    expandOrRenewSession: throttledExpandOrRenewSession,\n    expandSession: expandSession,\n    getSession: function () {\n      return sessionCache;\n    },\n    renewObservable: renewObservable,\n    expireObservable: expireObservable,\n    restartSession: startSession,\n    expire: function () {\n      cancelExpandOrRenewSession();\n      expireSession();\n      synchronizeSession(getExpiredSessionState());\n    },\n    stop: function () {\n      clearInterval(watchSessionTimeoutId);\n    }\n  };\n}","map":{"version":3,"names":["clearInterval","setInterval","Observable","ONE_SECOND","dateNow","throttle","generateUUID","selectCookieStrategy","initCookieStrategy","getExpiredSessionState","isSessionInExpiredState","isSessionInNotStartedState","initLocalStorageStrategy","selectLocalStorageStrategy","processSessionStoreOperations","STORAGE_POLL_DELAY","selectSessionStoreStrategyType","initConfiguration","sessionStoreStrategyType","allowFallbackToLocalStorage","startSessionStore","productKey","computeSessionState","renewObservable","expireObservable","sessionStoreStrategy","type","cookieOptions","expireSession","watchSessionTimeoutId","watchSession","sessionCache","startSession","_a","isTracked","process","sessionState","synchronizedSession","synchronizeSession","expandOrRenewSessionState","after","hasSessionInCache","renewSessionInCache","throttledExpandOrRenewSession","throttled","cancelExpandOrRenewSession","cancel","expandSession","undefined","isSessionInCacheOutdated","expireSessionInCache","trackingType","isExpired","id","created","String","notify","expandOrRenewSession","getSession","restartSession","expire","stop"],"sources":["D:\\edu'\\Spritle\\spritle\\node_modules\\@datadog\\browser-core\\src\\domain\\session\\sessionStore.ts"],"sourcesContent":["import { clearInterval, setInterval } from '../../tools/timer'\nimport { Observable } from '../../tools/observable'\nimport { ONE_SECOND, dateNow } from '../../tools/utils/timeUtils'\nimport { throttle } from '../../tools/utils/functionUtils'\nimport { generateUUID } from '../../tools/utils/stringUtils'\nimport type { InitConfiguration } from '../configuration'\nimport { selectCookieStrategy, initCookieStrategy } from './storeStrategies/sessionInCookie'\nimport type { SessionStoreStrategyType } from './storeStrategies/sessionStoreStrategy'\nimport { getExpiredSessionState, isSessionInExpiredState, isSessionInNotStartedState } from './sessionState'\nimport type { SessionState } from './sessionState'\nimport { initLocalStorageStrategy, selectLocalStorageStrategy } from './storeStrategies/sessionInLocalStorage'\nimport { processSessionStoreOperations } from './sessionStoreOperations'\n\nexport interface SessionStore {\n  expandOrRenewSession: () => void\n  expandSession: () => void\n  getSession: () => SessionState\n  restartSession: () => void\n  renewObservable: Observable<void>\n  expireObservable: Observable<void>\n  expire: () => void\n  stop: () => void\n}\n\n/**\n * Every second, the storage will be polled to check for any change that can occur\n * to the session state in another browser tab, or another window.\n * This value has been determined from our previous cookie-only implementation.\n */\nexport const STORAGE_POLL_DELAY = ONE_SECOND\n\n/**\n * Checks if cookies are available as the preferred storage\n * Else, checks if LocalStorage is allowed and available\n */\nexport function selectSessionStoreStrategyType(\n  initConfiguration: InitConfiguration\n): SessionStoreStrategyType | undefined {\n  let sessionStoreStrategyType = selectCookieStrategy(initConfiguration)\n  if (!sessionStoreStrategyType && initConfiguration.allowFallbackToLocalStorage) {\n    sessionStoreStrategyType = selectLocalStorageStrategy()\n  }\n  return sessionStoreStrategyType\n}\n\n/**\n * Different session concepts:\n * - tracked, the session has an id and is updated along the user navigation\n * - not tracked, the session does not have an id but it is updated along the user navigation\n * - inactive, no session in store or session expired, waiting for a renew session\n */\nexport function startSessionStore<TrackingType extends string>(\n  sessionStoreStrategyType: SessionStoreStrategyType,\n  productKey: string,\n  computeSessionState: (rawTrackingType?: string) => { trackingType: TrackingType; isTracked: boolean }\n): SessionStore {\n  const renewObservable = new Observable<void>()\n  const expireObservable = new Observable<void>()\n\n  const sessionStoreStrategy =\n    sessionStoreStrategyType.type === 'Cookie'\n      ? initCookieStrategy(sessionStoreStrategyType.cookieOptions)\n      : initLocalStorageStrategy()\n  const { expireSession } = sessionStoreStrategy\n\n  const watchSessionTimeoutId = setInterval(watchSession, STORAGE_POLL_DELAY)\n  let sessionCache: SessionState\n\n  startSession()\n\n  const { throttled: throttledExpandOrRenewSession, cancel: cancelExpandOrRenewSession } = throttle(() => {\n    let isTracked: boolean\n    processSessionStoreOperations(\n      {\n        process: (sessionState) => {\n          if (isSessionInNotStartedState(sessionState)) {\n            return\n          }\n\n          const synchronizedSession = synchronizeSession(sessionState)\n          isTracked = expandOrRenewSessionState(synchronizedSession)\n          return synchronizedSession\n        },\n        after: (sessionState) => {\n          if (isTracked && !hasSessionInCache()) {\n            renewSessionInCache(sessionState)\n          }\n          sessionCache = sessionState\n        },\n      },\n      sessionStoreStrategy\n    )\n  }, STORAGE_POLL_DELAY)\n\n  function expandSession() {\n    processSessionStoreOperations(\n      {\n        process: (sessionState) => (hasSessionInCache() ? synchronizeSession(sessionState) : undefined),\n      },\n      sessionStoreStrategy\n    )\n  }\n\n  /**\n   * allows two behaviors:\n   * - if the session is active, synchronize the session cache without updating the session store\n   * - if the session is not active, clear the session store and expire the session cache\n   */\n  function watchSession() {\n    processSessionStoreOperations(\n      {\n        process: (sessionState) => (isSessionInExpiredState(sessionState) ? getExpiredSessionState() : undefined),\n        after: synchronizeSession,\n      },\n      sessionStoreStrategy\n    )\n  }\n\n  function synchronizeSession(sessionState: SessionState) {\n    if (isSessionInExpiredState(sessionState)) {\n      sessionState = getExpiredSessionState()\n    }\n    if (hasSessionInCache()) {\n      if (isSessionInCacheOutdated(sessionState)) {\n        expireSessionInCache()\n      } else {\n        sessionCache = sessionState\n      }\n    }\n    return sessionState\n  }\n\n  function startSession() {\n    processSessionStoreOperations(\n      {\n        process: (sessionState) => {\n          if (isSessionInNotStartedState(sessionState)) {\n            return getExpiredSessionState()\n          }\n        },\n        after: (sessionState) => {\n          sessionCache = sessionState\n        },\n      },\n      sessionStoreStrategy\n    )\n  }\n\n  function expandOrRenewSessionState(sessionState: SessionState) {\n    if (isSessionInNotStartedState(sessionState)) {\n      return false\n    }\n\n    const { trackingType, isTracked } = computeSessionState(sessionState[productKey])\n    sessionState[productKey] = trackingType\n    delete sessionState.isExpired\n    if (isTracked && !sessionState.id) {\n      sessionState.id = generateUUID()\n      sessionState.created = String(dateNow())\n    }\n    return isTracked\n  }\n\n  function hasSessionInCache() {\n    return sessionCache[productKey] !== undefined\n  }\n\n  function isSessionInCacheOutdated(sessionState: SessionState) {\n    return sessionCache.id !== sessionState.id || sessionCache[productKey] !== sessionState[productKey]\n  }\n\n  function expireSessionInCache() {\n    sessionCache = getExpiredSessionState()\n    expireObservable.notify()\n  }\n\n  function renewSessionInCache(sessionState: SessionState) {\n    sessionCache = sessionState\n    renewObservable.notify()\n  }\n\n  return {\n    expandOrRenewSession: throttledExpandOrRenewSession,\n    expandSession,\n    getSession: () => sessionCache,\n    renewObservable,\n    expireObservable,\n    restartSession: startSession,\n    expire: () => {\n      cancelExpandOrRenewSession()\n      expireSession()\n      synchronizeSession(getExpiredSessionState())\n    },\n    stop: () => {\n      clearInterval(watchSessionTimeoutId)\n    },\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}