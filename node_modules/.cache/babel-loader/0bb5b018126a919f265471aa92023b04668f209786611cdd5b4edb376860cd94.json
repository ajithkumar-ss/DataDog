{"ast":null,"code":"var AbstractLifeCycle = /** @class */function () {\n  function AbstractLifeCycle() {\n    this.callbacks = {};\n  }\n  AbstractLifeCycle.prototype.notify = function (eventType, data) {\n    var eventCallbacks = this.callbacks[eventType];\n    if (eventCallbacks) {\n      eventCallbacks.forEach(function (callback) {\n        return callback(data);\n      });\n    }\n  };\n  AbstractLifeCycle.prototype.subscribe = function (eventType, callback) {\n    var _this = this;\n    if (!this.callbacks[eventType]) {\n      this.callbacks[eventType] = [];\n    }\n    this.callbacks[eventType].push(callback);\n    return {\n      unsubscribe: function () {\n        _this.callbacks[eventType] = _this.callbacks[eventType].filter(function (other) {\n          return callback !== other;\n        });\n      }\n    };\n  };\n  return AbstractLifeCycle;\n}();\nexport { AbstractLifeCycle };","map":{"version":3,"names":["AbstractLifeCycle","callbacks","prototype","notify","eventType","data","eventCallbacks","forEach","callback","subscribe","_this","push","unsubscribe","filter","other"],"sources":["D:\\edu'\\Spritle\\Spritle\\node_modules\\@datadog\\browser-core\\src\\tools\\abstractLifeCycle.ts"],"sourcesContent":["import type { Subscription } from './observable'\n\n/**\n * Type helper to extract event types that have \"void\" data. This allows to call `notify` without a\n * second argument. Ex:\n *\n * ```\n * interface EventMap {\n *   foo: void\n * }\n * const LifeCycle = AbstractLifeCycle<EventMap>\n * new LifeCycle().notify('foo')\n * ```\n */\ntype EventTypesWithoutData<EventMap> = {\n  [K in keyof EventMap]: EventMap[K] extends void ? K : never\n}[keyof EventMap]\n\nexport class AbstractLifeCycle<EventMap> {\n  private callbacks: { [key in keyof EventMap]?: Array<(data: any) => void> } = {}\n\n  notify<EventType extends EventTypesWithoutData<EventMap>>(eventType: EventType): void\n  notify<EventType extends keyof EventMap>(eventType: EventType, data: EventMap[EventType]): void\n  notify(eventType: keyof EventMap, data?: unknown) {\n    const eventCallbacks = this.callbacks[eventType]\n    if (eventCallbacks) {\n      eventCallbacks.forEach((callback) => callback(data))\n    }\n  }\n\n  subscribe<EventType extends keyof EventMap>(\n    eventType: EventType,\n    callback: (data: EventMap[EventType]) => void\n  ): Subscription {\n    if (!this.callbacks[eventType]) {\n      this.callbacks[eventType] = []\n    }\n    this.callbacks[eventType]!.push(callback)\n    return {\n      unsubscribe: () => {\n        this.callbacks[eventType] = this.callbacks[eventType]!.filter((other) => callback !== other)\n      },\n    }\n  }\n}\n"],"mappings":"AAkBA,IAAAA,iBAAA;EAAA,SAAAA,kBAAA;IACU,KAAAC,SAAS,GAA6D,EAAE;EAyBlF;EArBED,iBAAA,CAAAE,SAAA,CAAAC,MAAM,GAAN,UAAOC,SAAyB,EAAEC,IAAc;IAC9C,IAAMC,cAAc,GAAG,IAAI,CAACL,SAAS,CAACG,SAAS,CAAC;IAChD,IAAIE,cAAc,EAAE;MAClBA,cAAc,CAACC,OAAO,CAAC,UAACC,QAAQ;QAAK,OAAAA,QAAQ,CAACH,IAAI,CAAC;MAAd,CAAc,CAAC;IACtD;EACF,CAAC;EAEDL,iBAAA,CAAAE,SAAA,CAAAO,SAAS,GAAT,UACEL,SAAoB,EACpBI,QAA6C;IAF/C,IAAAE,KAAA;IAIE,IAAI,CAAC,IAAI,CAACT,SAAS,CAACG,SAAS,CAAC,EAAE;MAC9B,IAAI,CAACH,SAAS,CAACG,SAAS,CAAC,GAAG,EAAE;IAChC;IACA,IAAI,CAACH,SAAS,CAACG,SAAS,CAAE,CAACO,IAAI,CAACH,QAAQ,CAAC;IACzC,OAAO;MACLI,WAAW,EAAE,SAAAA,CAAA;QACXF,KAAI,CAACT,SAAS,CAACG,SAAS,CAAC,GAAGM,KAAI,CAACT,SAAS,CAACG,SAAS,CAAE,CAACS,MAAM,CAAC,UAACC,KAAK;UAAK,OAAAN,QAAQ,KAAKM,KAAK;QAAlB,CAAkB,CAAC;MAC9F;KACD;EACH,CAAC;EACH,OAAAd,iBAAC;AAAD,CAAC,CA1BD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}