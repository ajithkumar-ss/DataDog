{"ast":null,"code":"import { includes, timeStampNow, Observable, assign, getRelativeTime, ONE_MINUTE, ValueHistory, generateUUID, clocksNow, ONE_SECOND, elapsed } from '@datadog/browser-core';\nimport { trackEventCounts } from '../trackEventCounts';\nimport { PAGE_ACTIVITY_VALIDATION_DELAY, waitPageActivityEnd } from '../waitPageActivityEnd';\nimport { getSelectorFromElement } from '../getSelectorFromElement';\nimport { createClickChain } from './clickChain';\nimport { getActionNameFromElement } from './getActionNameFromElement';\nimport { listenActionEvents } from './listenActionEvents';\nimport { computeFrustration } from './computeFrustration';\n// Maximum duration for click actions\nexport var CLICK_ACTION_MAX_DURATION = 10 * ONE_SECOND;\nexport var ACTION_CONTEXT_TIME_OUT_DELAY = 5 * ONE_MINUTE; // arbitrary\nexport function trackClickActions(lifeCycle, domMutationObservable, configuration) {\n  var history = new ValueHistory(ACTION_CONTEXT_TIME_OUT_DELAY);\n  var stopObservable = new Observable();\n  var currentClickChain;\n  lifeCycle.subscribe(10 /* LifeCycleEventType.SESSION_RENEWED */, function () {\n    history.reset();\n  });\n  lifeCycle.subscribe(5 /* LifeCycleEventType.VIEW_ENDED */, stopClickChain);\n  var stopActionEventsListener = listenActionEvents(configuration, {\n    onPointerDown: function (pointerDownEvent) {\n      return processPointerDown(configuration, lifeCycle, domMutationObservable, pointerDownEvent);\n    },\n    onPointerUp: function (_a, startEvent, getUserActivity) {\n      var clickActionBase = _a.clickActionBase,\n        hadActivityOnPointerDown = _a.hadActivityOnPointerDown;\n      return startClickAction(configuration, lifeCycle, domMutationObservable, history, stopObservable, appendClickToClickChain, clickActionBase, startEvent, getUserActivity, hadActivityOnPointerDown);\n    }\n  }).stop;\n  var actionContexts = {\n    findActionId: function (startTime) {\n      return history.findAll(startTime);\n    }\n  };\n  return {\n    stop: function () {\n      stopClickChain();\n      stopObservable.notify();\n      stopActionEventsListener();\n    },\n    actionContexts: actionContexts\n  };\n  function appendClickToClickChain(click) {\n    if (!currentClickChain || !currentClickChain.tryAppend(click)) {\n      var rageClick_1 = click.clone();\n      currentClickChain = createClickChain(click, function (clicks) {\n        finalizeClicks(clicks, rageClick_1);\n      });\n    }\n  }\n  function stopClickChain() {\n    if (currentClickChain) {\n      currentClickChain.stop();\n    }\n  }\n}\nfunction processPointerDown(configuration, lifeCycle, domMutationObservable, pointerDownEvent) {\n  var clickActionBase = computeClickActionBase(pointerDownEvent, configuration.actionNameAttribute);\n  var hadActivityOnPointerDown = false;\n  waitPageActivityEnd(lifeCycle, domMutationObservable, configuration, function (pageActivityEndEvent) {\n    hadActivityOnPointerDown = pageActivityEndEvent.hadActivity;\n  },\n  // We don't care about the activity duration, we just want to know whether an activity did happen\n  // within the \"validation delay\" or not. Limit the duration so the callback is called sooner.\n  PAGE_ACTIVITY_VALIDATION_DELAY);\n  return {\n    clickActionBase: clickActionBase,\n    hadActivityOnPointerDown: function () {\n      return hadActivityOnPointerDown;\n    }\n  };\n}\nfunction startClickAction(configuration, lifeCycle, domMutationObservable, history, stopObservable, appendClickToClickChain, clickActionBase, startEvent, getUserActivity, hadActivityOnPointerDown) {\n  var click = newClick(lifeCycle, history, getUserActivity, clickActionBase, startEvent);\n  appendClickToClickChain(click);\n  var stopWaitPageActivityEnd = waitPageActivityEnd(lifeCycle, domMutationObservable, configuration, function (pageActivityEndEvent) {\n    if (pageActivityEndEvent.hadActivity && pageActivityEndEvent.end < click.startClocks.timeStamp) {\n      // If the clock is looking weird, just discard the click\n      click.discard();\n    } else {\n      if (pageActivityEndEvent.hadActivity) {\n        click.stop(pageActivityEndEvent.end);\n      } else if (hadActivityOnPointerDown()) {\n        click.stop(\n        // using the click start as activity end, so the click will have some activity but its\n        // duration will be 0 (as the activity started before the click start)\n        click.startClocks.timeStamp);\n      } else {\n        click.stop();\n      }\n    }\n  }, CLICK_ACTION_MAX_DURATION).stop;\n  var viewEndedSubscription = lifeCycle.subscribe(5 /* LifeCycleEventType.VIEW_ENDED */, function (_a) {\n    var endClocks = _a.endClocks;\n    click.stop(endClocks.timeStamp);\n  });\n  var stopSubscription = stopObservable.subscribe(function () {\n    click.stop();\n  });\n  click.stopObservable.subscribe(function () {\n    viewEndedSubscription.unsubscribe();\n    stopWaitPageActivityEnd();\n    stopSubscription.unsubscribe();\n  });\n}\nfunction computeClickActionBase(event, actionNameAttribute) {\n  var rect = event.target.getBoundingClientRect();\n  return {\n    type: \"click\" /* ActionType.CLICK */,\n    target: {\n      width: Math.round(rect.width),\n      height: Math.round(rect.height),\n      selector: getSelectorFromElement(event.target, actionNameAttribute)\n    },\n    position: {\n      // Use clientX and Y because for SVG element offsetX and Y are relatives to the <svg> element\n      x: Math.round(event.clientX - rect.left),\n      y: Math.round(event.clientY - rect.top)\n    },\n    name: getActionNameFromElement(event.target, actionNameAttribute)\n  };\n}\nfunction newClick(lifeCycle, history, getUserActivity, clickActionBase, startEvent) {\n  var id = generateUUID();\n  var startClocks = clocksNow();\n  var historyEntry = history.add(id, startClocks.relative);\n  var eventCountsSubscription = trackEventCounts({\n    lifeCycle: lifeCycle,\n    isChildEvent: function (event) {\n      return event.action !== undefined && (Array.isArray(event.action.id) ? includes(event.action.id, id) : event.action.id === id);\n    }\n  });\n  var status = 0 /* ClickStatus.ONGOING */;\n  var activityEndTime;\n  var frustrationTypes = [];\n  var stopObservable = new Observable();\n  function stop(newActivityEndTime) {\n    if (status !== 0 /* ClickStatus.ONGOING */) {\n      return;\n    }\n    activityEndTime = newActivityEndTime;\n    status = 1 /* ClickStatus.STOPPED */;\n    if (activityEndTime) {\n      historyEntry.close(getRelativeTime(activityEndTime));\n    } else {\n      historyEntry.remove();\n    }\n    eventCountsSubscription.stop();\n    stopObservable.notify();\n  }\n  return {\n    event: startEvent,\n    stop: stop,\n    stopObservable: stopObservable,\n    get hasError() {\n      return eventCountsSubscription.eventCounts.errorCount > 0;\n    },\n    get hasPageActivity() {\n      return activityEndTime !== undefined;\n    },\n    getUserActivity: getUserActivity,\n    addFrustration: function (frustrationType) {\n      frustrationTypes.push(frustrationType);\n    },\n    startClocks: startClocks,\n    isStopped: function () {\n      return status === 1 /* ClickStatus.STOPPED */ || status === 2 /* ClickStatus.FINALIZED */;\n    },\n    clone: function () {\n      return newClick(lifeCycle, history, getUserActivity, clickActionBase, startEvent);\n    },\n    validate: function (domEvents) {\n      stop();\n      if (status !== 1 /* ClickStatus.STOPPED */) {\n        return;\n      }\n      var _a = eventCountsSubscription.eventCounts,\n        resourceCount = _a.resourceCount,\n        errorCount = _a.errorCount,\n        longTaskCount = _a.longTaskCount;\n      var clickAction = assign({\n        type: \"click\" /* ActionType.CLICK */,\n        duration: activityEndTime && elapsed(startClocks.timeStamp, activityEndTime),\n        startClocks: startClocks,\n        id: id,\n        frustrationTypes: frustrationTypes,\n        counts: {\n          resourceCount: resourceCount,\n          errorCount: errorCount,\n          longTaskCount: longTaskCount\n        },\n        events: domEvents !== null && domEvents !== void 0 ? domEvents : [startEvent],\n        event: startEvent\n      }, clickActionBase);\n      lifeCycle.notify(1 /* LifeCycleEventType.AUTO_ACTION_COMPLETED */, clickAction);\n      status = 2 /* ClickStatus.FINALIZED */;\n    },\n    discard: function () {\n      stop();\n      status = 2 /* ClickStatus.FINALIZED */;\n    }\n  };\n}\nexport function finalizeClicks(clicks, rageClick) {\n  var isRage = computeFrustration(clicks, rageClick).isRage;\n  if (isRage) {\n    clicks.forEach(function (click) {\n      return click.discard();\n    });\n    rageClick.stop(timeStampNow());\n    rageClick.validate(clicks.map(function (click) {\n      return click.event;\n    }));\n  } else {\n    rageClick.discard();\n    clicks.forEach(function (click) {\n      return click.validate();\n    });\n  }\n}","map":{"version":3,"names":["includes","timeStampNow","Observable","assign","getRelativeTime","ONE_MINUTE","ValueHistory","generateUUID","clocksNow","ONE_SECOND","elapsed","trackEventCounts","PAGE_ACTIVITY_VALIDATION_DELAY","waitPageActivityEnd","getSelectorFromElement","createClickChain","getActionNameFromElement","listenActionEvents","computeFrustration","CLICK_ACTION_MAX_DURATION","ACTION_CONTEXT_TIME_OUT_DELAY","trackClickActions","lifeCycle","domMutationObservable","configuration","history","stopObservable","currentClickChain","subscribe","reset","stopClickChain","stopActionEventsListener","onPointerDown","pointerDownEvent","processPointerDown","onPointerUp","_a","startEvent","getUserActivity","clickActionBase","hadActivityOnPointerDown","startClickAction","appendClickToClickChain","stop","actionContexts","findActionId","startTime","findAll","notify","click","tryAppend","rageClick_1","clone","clicks","finalizeClicks","computeClickActionBase","actionNameAttribute","pageActivityEndEvent","hadActivity","newClick","stopWaitPageActivityEnd","end","startClocks","timeStamp","discard","viewEndedSubscription","endClocks","stopSubscription","unsubscribe","event","rect","target","getBoundingClientRect","type","width","Math","round","height","selector","position","x","clientX","left","y","clientY","top","name","id","historyEntry","add","relative","eventCountsSubscription","isChildEvent","action","undefined","Array","isArray","status","activityEndTime","frustrationTypes","newActivityEndTime","close","remove","hasError","eventCounts","errorCount","hasPageActivity","addFrustration","frustrationType","push","isStopped","validate","domEvents","resourceCount","longTaskCount","clickAction","duration","counts","events","rageClick","isRage","forEach","map"],"sources":["D:\\edu'\\Spritle\\Spritle\\node_modules\\@datadog\\browser-rum-core\\src\\domain\\action\\trackClickActions.ts"],"sourcesContent":["import type { Duration, ClocksState, RelativeTime, TimeStamp } from '@datadog/browser-core'\nimport {\n  includes,\n  timeStampNow,\n  Observable,\n  assign,\n  getRelativeTime,\n  ONE_MINUTE,\n  ValueHistory,\n  generateUUID,\n  clocksNow,\n  ONE_SECOND,\n  elapsed,\n} from '@datadog/browser-core'\nimport type { FrustrationType } from '../../rawRumEvent.types'\nimport { ActionType } from '../../rawRumEvent.types'\nimport type { RumConfiguration } from '../configuration'\nimport type { LifeCycle } from '../lifeCycle'\nimport { LifeCycleEventType } from '../lifeCycle'\nimport { trackEventCounts } from '../trackEventCounts'\nimport { PAGE_ACTIVITY_VALIDATION_DELAY, waitPageActivityEnd } from '../waitPageActivityEnd'\nimport { getSelectorFromElement } from '../getSelectorFromElement'\nimport type { ClickChain } from './clickChain'\nimport { createClickChain } from './clickChain'\nimport { getActionNameFromElement } from './getActionNameFromElement'\nimport type { MouseEventOnElement, UserActivity } from './listenActionEvents'\nimport { listenActionEvents } from './listenActionEvents'\nimport { computeFrustration } from './computeFrustration'\n\ninterface ActionCounts {\n  errorCount: number\n  longTaskCount: number\n  resourceCount: number\n}\n\nexport interface ClickAction {\n  type: ActionType.CLICK\n  id: string\n  name: string\n  target?: {\n    selector: string\n    selector_with_stable_attributes?: string\n    width: number\n    height: number\n  }\n  position?: { x: number; y: number }\n  startClocks: ClocksState\n  duration?: Duration\n  counts: ActionCounts\n  event: MouseEventOnElement\n  frustrationTypes: FrustrationType[]\n  events: Event[]\n}\n\nexport interface ActionContexts {\n  findActionId: (startTime?: RelativeTime) => string | string[] | undefined\n}\n\ntype ClickActionIdHistory = ValueHistory<ClickAction['id']>\n\n// Maximum duration for click actions\nexport const CLICK_ACTION_MAX_DURATION = 10 * ONE_SECOND\nexport const ACTION_CONTEXT_TIME_OUT_DELAY = 5 * ONE_MINUTE // arbitrary\n\nexport function trackClickActions(\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  configuration: RumConfiguration\n) {\n  const history: ClickActionIdHistory = new ValueHistory(ACTION_CONTEXT_TIME_OUT_DELAY)\n  const stopObservable = new Observable<void>()\n  let currentClickChain: ClickChain | undefined\n\n  lifeCycle.subscribe(LifeCycleEventType.SESSION_RENEWED, () => {\n    history.reset()\n  })\n\n  lifeCycle.subscribe(LifeCycleEventType.VIEW_ENDED, stopClickChain)\n\n  const { stop: stopActionEventsListener } = listenActionEvents<{\n    clickActionBase: ClickActionBase\n    hadActivityOnPointerDown: () => boolean\n  }>(configuration, {\n    onPointerDown: (pointerDownEvent) =>\n      processPointerDown(configuration, lifeCycle, domMutationObservable, pointerDownEvent),\n    onPointerUp: ({ clickActionBase, hadActivityOnPointerDown }, startEvent, getUserActivity) =>\n      startClickAction(\n        configuration,\n        lifeCycle,\n        domMutationObservable,\n        history,\n        stopObservable,\n        appendClickToClickChain,\n        clickActionBase,\n        startEvent,\n        getUserActivity,\n        hadActivityOnPointerDown\n      ),\n  })\n\n  const actionContexts: ActionContexts = {\n    findActionId: (startTime?: RelativeTime) => history.findAll(startTime),\n  }\n\n  return {\n    stop: () => {\n      stopClickChain()\n      stopObservable.notify()\n      stopActionEventsListener()\n    },\n    actionContexts,\n  }\n\n  function appendClickToClickChain(click: Click) {\n    if (!currentClickChain || !currentClickChain.tryAppend(click)) {\n      const rageClick = click.clone()\n      currentClickChain = createClickChain(click, (clicks) => {\n        finalizeClicks(clicks, rageClick)\n      })\n    }\n  }\n\n  function stopClickChain() {\n    if (currentClickChain) {\n      currentClickChain.stop()\n    }\n  }\n}\n\nfunction processPointerDown(\n  configuration: RumConfiguration,\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  pointerDownEvent: MouseEventOnElement\n) {\n  const clickActionBase = computeClickActionBase(pointerDownEvent, configuration.actionNameAttribute)\n\n  let hadActivityOnPointerDown = false\n\n  waitPageActivityEnd(\n    lifeCycle,\n    domMutationObservable,\n    configuration,\n    (pageActivityEndEvent) => {\n      hadActivityOnPointerDown = pageActivityEndEvent.hadActivity\n    },\n    // We don't care about the activity duration, we just want to know whether an activity did happen\n    // within the \"validation delay\" or not. Limit the duration so the callback is called sooner.\n    PAGE_ACTIVITY_VALIDATION_DELAY\n  )\n\n  return { clickActionBase, hadActivityOnPointerDown: () => hadActivityOnPointerDown }\n}\n\nfunction startClickAction(\n  configuration: RumConfiguration,\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  history: ClickActionIdHistory,\n  stopObservable: Observable<void>,\n  appendClickToClickChain: (click: Click) => void,\n  clickActionBase: ClickActionBase,\n  startEvent: MouseEventOnElement,\n  getUserActivity: () => UserActivity,\n  hadActivityOnPointerDown: () => boolean\n) {\n  const click = newClick(lifeCycle, history, getUserActivity, clickActionBase, startEvent)\n  appendClickToClickChain(click)\n\n  const { stop: stopWaitPageActivityEnd } = waitPageActivityEnd(\n    lifeCycle,\n    domMutationObservable,\n    configuration,\n    (pageActivityEndEvent) => {\n      if (pageActivityEndEvent.hadActivity && pageActivityEndEvent.end < click.startClocks.timeStamp) {\n        // If the clock is looking weird, just discard the click\n        click.discard()\n      } else {\n        if (pageActivityEndEvent.hadActivity) {\n          click.stop(pageActivityEndEvent.end)\n        } else if (hadActivityOnPointerDown()) {\n          click.stop(\n            // using the click start as activity end, so the click will have some activity but its\n            // duration will be 0 (as the activity started before the click start)\n            click.startClocks.timeStamp\n          )\n        } else {\n          click.stop()\n        }\n      }\n    },\n    CLICK_ACTION_MAX_DURATION\n  )\n\n  const viewEndedSubscription = lifeCycle.subscribe(LifeCycleEventType.VIEW_ENDED, ({ endClocks }) => {\n    click.stop(endClocks.timeStamp)\n  })\n\n  const stopSubscription = stopObservable.subscribe(() => {\n    click.stop()\n  })\n\n  click.stopObservable.subscribe(() => {\n    viewEndedSubscription.unsubscribe()\n    stopWaitPageActivityEnd()\n    stopSubscription.unsubscribe()\n  })\n}\n\ntype ClickActionBase = Pick<ClickAction, 'type' | 'name' | 'target' | 'position'>\n\nfunction computeClickActionBase(event: MouseEventOnElement, actionNameAttribute?: string): ClickActionBase {\n  const rect = event.target.getBoundingClientRect()\n  return {\n    type: ActionType.CLICK,\n    target: {\n      width: Math.round(rect.width),\n      height: Math.round(rect.height),\n      selector: getSelectorFromElement(event.target, actionNameAttribute),\n    },\n    position: {\n      // Use clientX and Y because for SVG element offsetX and Y are relatives to the <svg> element\n      x: Math.round(event.clientX - rect.left),\n      y: Math.round(event.clientY - rect.top),\n    },\n    name: getActionNameFromElement(event.target, actionNameAttribute),\n  }\n}\n\nconst enum ClickStatus {\n  // Initial state, the click is still ongoing.\n  ONGOING,\n  // The click is no more ongoing but still needs to be validated or discarded.\n  STOPPED,\n  // Final state, the click has been stopped and validated or discarded.\n  FINALIZED,\n}\n\nexport type Click = ReturnType<typeof newClick>\n\nfunction newClick(\n  lifeCycle: LifeCycle,\n  history: ClickActionIdHistory,\n  getUserActivity: () => UserActivity,\n  clickActionBase: ClickActionBase,\n  startEvent: MouseEventOnElement\n) {\n  const id = generateUUID()\n  const startClocks = clocksNow()\n  const historyEntry = history.add(id, startClocks.relative)\n  const eventCountsSubscription = trackEventCounts({\n    lifeCycle,\n    isChildEvent: (event) =>\n      event.action !== undefined &&\n      (Array.isArray(event.action.id) ? includes(event.action.id, id) : event.action.id === id),\n  })\n  let status = ClickStatus.ONGOING\n  let activityEndTime: undefined | TimeStamp\n  const frustrationTypes: FrustrationType[] = []\n  const stopObservable = new Observable<void>()\n\n  function stop(newActivityEndTime?: TimeStamp) {\n    if (status !== ClickStatus.ONGOING) {\n      return\n    }\n    activityEndTime = newActivityEndTime\n    status = ClickStatus.STOPPED\n    if (activityEndTime) {\n      historyEntry.close(getRelativeTime(activityEndTime))\n    } else {\n      historyEntry.remove()\n    }\n    eventCountsSubscription.stop()\n    stopObservable.notify()\n  }\n\n  return {\n    event: startEvent,\n    stop,\n    stopObservable,\n\n    get hasError() {\n      return eventCountsSubscription.eventCounts.errorCount > 0\n    },\n    get hasPageActivity() {\n      return activityEndTime !== undefined\n    },\n    getUserActivity,\n    addFrustration: (frustrationType: FrustrationType) => {\n      frustrationTypes.push(frustrationType)\n    },\n    startClocks,\n\n    isStopped: () => status === ClickStatus.STOPPED || status === ClickStatus.FINALIZED,\n\n    clone: () => newClick(lifeCycle, history, getUserActivity, clickActionBase, startEvent),\n\n    validate: (domEvents?: Event[]) => {\n      stop()\n      if (status !== ClickStatus.STOPPED) {\n        return\n      }\n\n      const { resourceCount, errorCount, longTaskCount } = eventCountsSubscription.eventCounts\n      const clickAction: ClickAction = assign(\n        {\n          type: ActionType.CLICK as const,\n          duration: activityEndTime && elapsed(startClocks.timeStamp, activityEndTime),\n          startClocks,\n          id,\n          frustrationTypes,\n          counts: {\n            resourceCount,\n            errorCount,\n            longTaskCount,\n          },\n          events: domEvents ?? [startEvent],\n          event: startEvent,\n        },\n        clickActionBase\n      )\n      lifeCycle.notify(LifeCycleEventType.AUTO_ACTION_COMPLETED, clickAction)\n      status = ClickStatus.FINALIZED\n    },\n\n    discard: () => {\n      stop()\n      status = ClickStatus.FINALIZED\n    },\n  }\n}\n\nexport function finalizeClicks(clicks: Click[], rageClick: Click) {\n  const { isRage } = computeFrustration(clicks, rageClick)\n  if (isRage) {\n    clicks.forEach((click) => click.discard())\n    rageClick.stop(timeStampNow())\n    rageClick.validate(clicks.map((click) => click.event))\n  } else {\n    rageClick.discard()\n    clicks.forEach((click) => click.validate())\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}